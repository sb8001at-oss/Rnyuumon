{
  "hash": "164ece4cb1f61080f97d41305f54d37a",
  "result": {
    "engine": "knitr",
    "markdown": "# オブジェクト指向とクラス\n\n\n\n\n\nRは**オブジェクト指向プログラミング言語**であるとされています。オブジェクト指向とは、プログラミングで取り扱う「**もの（Objects）**」を**オブジェクト**として扱い、オブジェクトには**クラス**とメソッドが設定されるような形でプログラミング言語を設計する考え方を指す言葉です。\n\nオブジェクト指向に関わる言葉はたくさんあります（カプセル化・継承・ポリモルフィズム・クラス・インスタンス・メソッド・アクセサ等々、[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)を参照）。他のオブジェクト指向言語、例えばPythonやRubyではこのあたりの理解がプログラミングにおいてとても重要になるのですが、Rでははっきりと理解していなくても、（少なくとも小規模データの解析やグラフ描画程度であれば）大きな問題にはなりません。オブジェクト指向の概念が重要となるのは、恒久的にメンテナンスを続けて使用され続けるプログラム（例えばライブラリなど）や、オンラインで大規模に開発し、常にメンテナンスが必要となるプログラム（Webアプリケーションなど）を作成する時になります。以下にオブジェクト指向の言葉の意味を説明しますが、なんとなくわかる、という程度で通常のデータ解析で困ることはないでしょう。\n\nこの章では、やや抽象的なプログラミングに関する内容について説明します。Rでグラフ作成やデータ処理、統計解析を行うのにすぐに必要となる事項ではありませんので、飛ばして次の章に進んで頂いても問題はありません。\n\n## クラス\n\nオブジェクトには**クラス**という特性があります。Rでは、数値（numeric）、文字列（character）、論理型（logical）、リスト（list）、行列（matrix、array）、因子（factor）、データフレーム（data.frame）、時系列（ts）などがクラスとして設定されています。クラスは`class`関数を用いて確認することができます。\n\n\n::: {.cell filename='オブジェクトのクラス'}\n\n```{.r .cell-code}\n1 |> class()\n## [1] \"numeric\"\n\"a\" |> class()\n## [1] \"character\"\nT |> class()\n## [1] \"logical\"\n\nc(1, 1, 1) |> class() # ベクター自体には特別なクラスはない\n## [1] \"numeric\"\nlist(1, 1, 1) |> class()\n## [1] \"list\"\nmatrix(1:4, nrow = 2) |> class()\n## [1] \"matrix\" \"array\"\n\nfactor(1) |> class()\n## [1] \"factor\"\niris |> class()\n## [1] \"data.frame\"\nNile |> class()\n## [1] \"ts\"\n```\n:::\n\n\nクラスの役割は、**「オブジェクトの型と取扱いの方法」**を定めるところにあります。例えばデータフレームであれば、「同じ長さのベクトルのリストで、行と列を持つ表の形をしていて、行と列に名前を登録できるもの」という「型」を持っています。また、`plot.data.frame`関数のように、データフレームを「取り扱う方法」が準備されています。このように、クラスは「型」と「取り扱い方」をセットにし、データの取り扱いを簡単にする役割を持ちます。\n\nデータフレームをクラスとするオブジェクトは、この「型」を元にした構造を持ち、値や行・列の数・名前が異なるものになっています。つまり、データフレームという「型」は同じですが、中身が違うものがオブジェクトとして作り出されていることになります。プログラミング言語では、この「型」から作り出されたオブジェクトのことを、**インスタンス**と呼びます。\n\nつまり、data.frameはクラスであり、data.frameクラスのオブジェクトである`iris`や`cars`はインスタンスである、ということになります。\n\n## Pythonでのクラスの例\n\nクラスとインスタンスに関しては、他の言語での例を見た方がわかりやすいかと思います。以下はPythonの[Documentation](https://docs.python.org/ja/3/tutorial/classes.html)に記載されている`Dog`クラスの定義とインスタンス作成の例です。\n\nRを含めて、多くのプログラミング言語では**クラスを定義**することができます。クラスにはクラス名が必要です（下の例では`Dog`がクラス名）。クラスを定義するときには、インスタンスの要素（`name`（名前）と`tricks`（芸）という2つ）、インスタンスを演算に用いる**メソッド**、**アクセサ**（アクセス・メソッド）と呼ばれる、インスタンスの要素を変更する方法（下の例では`add_trick`メソッド、**セッター（setter）**と呼ばれる）と要素を呼び出す方法（**ゲッター（getter）**）を準備するのが一般的です。\n\nインスタンスを作成する場合には、クラス名にカッコをつけ、`__init__`に示した引数（`self`はそのオブジェクト自身を指すので、`name`が引数）を指定して実行します。下の例では`dog_Fido`と`dog_Buddy`という2つのインスタンスを作成し、それぞれ`name`に`\"Fido\"`、`\"Buddy`\"を設定しています。\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# クラスの定義\nclass Dog:\n    # メソッドの定義\n    def __init__(self, name):\n        self.name = name\n        self.tricks = []\n    # アクセサの定義\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n# インスタンス（クラスオブジェクト）の作成\ndog_Fido = Dog('Fido')\ndog_Buddy = Dog('Buddy')\n```\n:::\n\n\n### RとPythonでのクラスの比較\n\nこれだけではよく分からないと思いますので、もう少し説明を加えます。\n\nクラスの設定の目的の一つは、データを**カプセル化**することです。カプセル化というのは、バラバラのデータや取り扱い方法をひとまとめにして、取り扱いやすくすることです。上の例では、犬の名前（`name`）、芸（`trick`）と取り扱い方法（メソッド）をひとまとめにしています。こうすることで、その犬の名前と芸をひとまとめ、つまりカプセル化しているわけです。\n\nRでは、このようなカプセル化を行うのに、リストが用いられています。ですので、非常に単純化すると、カプセル化とはリストみたいなものだと思ってもらうと良いかと思います。\n\nまた、犬の名前や芸がころころ変わってしまうと、犬の名前とその犬ができる芸の関係を維持するのが難しくなってしまいます。ですので、**アクセサ**を準備して、関数を用いないと名前や芸などの要素を追加・変更できないようにしています。\n\nRでは、listの要素を変える方法、例えば、リストの要素への代入（セッター）や、リストの要素を呼び出す方法（ゲッター）が、アクセサに当たります。\n\nオブジェクトを作成すると、そのクラスのオブジェクトとして変数ができます。この変数は、「型」から作られた「もの」、つまりインスタンスになります。下のRの例では、`lst_Fibo`がリスト（クラス）のオブジェクト（インスタンス）である、ということになります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# これが__init__に当たる、オブジェクト作成時の方法\nlst_Fibo <- list(name = \"Fibo\", tricks = c(\"ballcatch\", \"zigzag\"))\n\nlst_Fibo$name <- \"Pochi\" # これがアクセサ（セッター）みたいなもの\n\nlst_Fibo$name # これもアクセサ（ゲッター）みたいなもの\n## [1] \"Pochi\"\n\nlst_Fibo # オブジェクトの名前の要素が変わる\n## $name\n## [1] \"Pochi\"\n## \n## $tricks\n## [1] \"ballcatch\" \"zigzag\"\n```\n:::\n\n\nこのように見ると、リストは大体クラスの要件を満たしているように見えます。ただし、リストでは要素の数を自由自在に増やしたり減らしたりすることができます。例えば、登録されている犬の名前（`name`）を変えたり、`tricks`を削って`birthday`を追加する、といったことがリストでは簡単にできてしまいます。このような変換を行うと、Pythonの型（クラス）で定義したものとは違う要素を持つオブジェクトを簡単に作れてしまうことになります。\n\n他言語のクラスでは、インスタンスごとに取り扱いが変わることがないように、要素の追加や削除は原則できないようになっています。また、クラスの定義を行うときに、要素のデータ型や要素に対する取り扱いの方法（メソッド）を定義しておき、要素の型、取り扱いの方法を厳密に定めておくのが一般的です。このようにクラスの「要素」・「型」・「取り扱い方」を厳密に定めておくことで、そのクラスのインスタンスをいつ用いても同じ方法で取り扱えることを担保しています。\n\nこのような性質は、「誰が、いつ、どのような形でそのクラスのインスタンスを用いても、同じ方法で取り扱うことができる」ために重要となります。ですので、複数人が関わる大規模な開発や大きなアプリケーション、メンテナンスを常時必要とする長期プロジェクトなどではクラスの厳密な定義が非常に重要となります。\n\n一方で、Rはその場限りの解析に用いることが多い言語です。もちろん、ライブラリの構築時や、恒常的に組織でメンテナンスし、使い続けるRのプログラムを開発する場合には、クラスの定義と取り扱いは重要となります。ですが、その場限りの解析では、データのカプセル化の役割をリストが十分に果たすことができます。このような理由から、Rでクラスを定義し、用いる方法は（少なくとも簡単な統計解析においては）、あまり重要視されていません。\n\n## Rのクラスとアトリビュート（attributes）\n\n因子（[10章](./chapter10.html)）やデータフレーム（[12章](./chapter12.html)）で説明した通り、Rではクラスはアトリビュート（attributes）として設定されています。ただし、クラスは必ずしもアトリビュートとして設定されているわけではありません。クラスにはアトリビュートとして設定されるものと、されていないものがあります。\n\n数値や文字列、リスト、行列などはアトリビュートとしてクラス名を持たないのに対し、因子やデータフレーム、時系列はアトリビュートとしてクラスが登録されています。\n\n\n::: {.cell filename='各クラスに設定されたAttributes'}\n\n```{.r .cell-code}\n1 |>  attributes()\n## NULL\n\"a\" |> attributes()\n## NULL\nT |> attributes()\n## NULL\n\nc(1, 1, 1) |> attributes()\n## NULL\nlist(1, 1, 1) |> attributes()\n## NULL\nmatrix(1:4, nrow = 2) |> attributes()\n## $dim\n## [1] 2 2\n\nfactor(1) |> attributes()\n## $levels\n## [1] \"1\"\n## \n## $class\n## [1] \"factor\"\niris |> attributes() |> lapply(head)\n## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n## [1] 1 2 3 4 5 6\nNile |> attributes()\n## $tsp\n## [1] 1871 1970    1\n## \n## $class\n## [1] \"ts\"\n```\n:::\n\n\nこのようなアトリビュートの差は、**親クラス**（superclass、スーパークラス）と呼ばれるものの違いによります。Rを含め、オブジェクト指向の言語では、クラスを定義するときに、他のクラスの定義を流用し、機能や要素等を追加した上で新しいクラスとすることができます。このように、他のクラスの定義を流用することを、**継承**（inheritance）と呼びます。つまり、数値や文字列、リストなどと、データフレーム、因子、時系列では親クラスが異なるクラスである、ということになります。\n\nRで親クラスを把握するときに用いる関数として、`pryr::otype`があります[@pryr_bib]。`pryr::otype`の引数にオブジェクトを取ると、そのオブジェクトの親クラスを調べることができます。\n\n\n::: {.cell filename='plyr::otypeで親クラスを確認する'}\n\n```{.r .cell-code}\n# 数値、文字列はbaseクラスを親とする\n1 |> pryr::otype()\n## [1] \"base\"\n\"a\" |> pryr::otype()\n## [1] \"base\"\nT |> pryr::otype()\n## [1] \"base\"\n\n# リスト・行列はbaseクラスを親とする\nc(1, 1, 1) |> pryr::otype()\n## [1] \"base\"\nlist(1, 1, 1) |> pryr::otype()\n## [1] \"base\"\nmatrix(1:4, nrow = 2) |> pryr::otype()\n## [1] \"base\"\n\n# 因子・データフレーム・時系列はS3クラスを親とする\nfactor(1) |> pryr::otype()\n## [1] \"S3\"\niris |> pryr::otype()\n## [1] \"S3\"\nNile |> pryr::otype()\n## [1] \"S3\"\n```\n:::\n\n\n上のように、数値や文字列、リストなどのアトリビュートにクラスを持たないオブジェクトの親クラスはbase、因子やデータフレーム、時系列などのアトリビュートを持つオブジェクトの親クラスはS3となっています。\n\nRには、これらの親クラスの他に、S4、[R6](https://r6.r-lib.org/articles/Introduction.html) [@R6_bib]等の親クラスが存在します。\n\n\n::: {.cell filename='S3の例'}\n\n```{.r .cell-code}\nlm_obj <- lm(iris$Sepal.Length~iris$Sepal.Width)\nlm_obj |> pryr::otype()\n## [1] \"S3\"\n```\n:::\n\n::: {.cell filename='S4の例'}\n\n```{.r .cell-code}\npacman::p_load(lme4)\nlme4_obj <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)\nlme4_obj |> pryr::otype()\n## [1] \"S4\"\n```\n:::\n\n::: {.cell filename='R6の例'}\n\n```{.r .cell-code}\npacman::p_load(cmdstanr)\nmod <- \n    file.path(cmdstan_path(), \"examples\", \"bernoulli\", \"bernoulli.stan\") |>\n    cmdstan_model()\nmod |> pryr::otype() # otypeではS3扱い\n## [1] \"S3\"\nmod |> class() # 中身はR6\n## [1] \"CmdStanModel\" \"R6\"\n```\n:::\n\n\nRにはこの他にも、[`reference class`](http://adv-r.had.co.nz/R5.html)（昔はR5として開発されていたものだと思います）、[`aoos`](https://wahani.github.io/aoos/) [@aoos_bib]、[`S7`](https://rconsortium.github.io/S7/) [@S7_bib]などのオブジェクト指向プログラミングに関するクラスがあります。色々あって混乱しているのは、「S3とS4がイマイチ」と思う人が多かったためでしょう。\n\n`S7`を開発しているのが`ggplot2`を開発したHadley Wickhamなので（2023年現在）、いずれは`S7`が主流になるのかもしれませんが、現状では簡単にRにオブジェクト指向のクラスを持ち込む場合にはS3を、少し複雑なプロジェクトにはS4を用いるのが一般的であるように見えます。特に[Bioconductor](https://www.bioconductor.org/)のライブラリではS4のオブジェクトが用いられています。\n\n## RでのS3、S4クラスオブジェクトの取り扱い\n\n上に述べたように、Rではライブラリを作成する等の特殊な場合を除いて、クラスを定義することはありません。クラスの定義は入門で学ぶには少し高度な内容となるので、他の文献に説明を譲ります。\n\nしかし、統計の関数の返り値はS3やS4を親クラスとしたオブジェクトとなっている場合が多いため、オブジェクトの取り扱い方を理解しておくことは統計解析において重要となります。\n\n典型的なS3の例として線形回帰の結果（lmオブジェクト）、S4の例として線形混合モデルの結果（lmerModオブジェクト、[lme4パッケージ](https://cran.r-project.org/web/packages/lme4/index.html) [@lme4_bib]より）を用いて、オブジェクトの取り扱い方を説明します。\n\nS3オブジェクトでもS4オブジェクトでも、オブジェクトの内容を確認する場合には、まず`str`関数でオブジェクトの構造を理解するところから始めます。\n\n\n::: {.cell filename='S3：str関数で構造を確認する'}\n\n```{.r .cell-code}\nlm_obj |> str(list.len=3) # S3オブジェクト（一部表示）\n## List of 12\n##  $ coefficients : Named num [1:2] 6.526 -0.223\n##   ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"iris$Sepal.Width\"\n##  $ residuals    : Named num [1:150] -0.644 -0.956 -1.111 -1.234 -0.722 ...\n##   ..- attr(*, \"names\")= chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n##  $ effects      : Named num [1:150] -71.566 -1.188 -1.081 -1.187 -0.759 ...\n##   ..- attr(*, \"names\")= chr [1:150] \"(Intercept)\" \"iris$Sepal.Width\" \"\" \"\" ...\n##   [list output truncated]\n##  - attr(*, \"class\")= chr \"lm\"\n```\n:::\n\n::: {.cell filename='S4：str関数で構造を確認する'}\n\n```{.r .cell-code}\nlme4_obj |> str(list.len=3) # S4オブジェクト（一部表示）\n## Formal class 'lmerMod' [package \"lme4\"] with 13 slots\n##   ..@ resp   :Reference class 'lmerResp' [package \"lme4\"] with 9 fields\n##   .. ..$ Ptr    :<externalptr> \n##   .. ..$ mu     : num [1:180] 254 273 293 313 332 ...\n##   .. ..$ offset : num [1:180] 0 0 0 0 0 0 0 0 0 0 ...\n##   .. .. [list output truncated]\n##   .. ..and 28 methods, of which 14 are  possibly relevant:\n##   .. ..  allInfo, copy#envRefClass, initialize, initialize#lmResp,\n##   .. ..  initializePtr, initializePtr#lmResp, objective, ptr, ptr#lmResp,\n##   .. ..  setOffset, setResp, setWeights, updateMu, wrss\n##   ..@ Gp     : int [1:2] 0 36\n##   ..@ call   : language lmer(formula = Reaction ~ Days + (Days | Subject), data = sleepstudy)\n##   .. [list output truncated]\n```\n:::\n\n\nどちらも`str`関数の引数を指定しない場合にはとても沢山の出力が示されるのですが、特徴としては、\n\n - \\$または\\@から始まる行がたくさん記載されている\n - \\$・\\@の後ろに「単語 : データ型」といった表記がある\n - S3には\\$のみ、S4には\\$と\\@が記載されている\n - ところどころにattrという記載がある\n - `str`関数の引数がS3の時は、1行目に「List of 〇〇」の表記がある\n\nということが分かるかと思います。\n\n\\$や\\@は要素の呼び出しに用いるものです。これらはリストやデータフレームで、名前を用いて要素を呼び出す際の`$`と同じものです。\\$・\\@の後に続き単語はリストやデータフレームの名前に当たるもので、`$`・`@`に続けて記載することで要素を呼び出すことができます。S3・S4クラスにはゲッター（getter）の関数が備わっている場合もあり、関数を用いて要素を呼び出せる場合もあります。\n\n`@`はS4クラスに特有の呼び出しの記号で、S3クラスでは用いることがありません。attrはattributesの意味で、その要素に付属するattributesを示しています。要素を`attributes`関数の引数にすることで、そのattributesの内容を取り出すことができます。\n\n最後に、S3オブジェクトの「List of 〇〇」についてですが、RではS3オブジェクトはデータの登録や関数の適用に特徴のあるリストとして実装されています。データの登録に関しては、S3クラスの定義に従い、型チェック等が組み込まれます。また、アトリビュートにクラスが追加されます。\n\n関数の適用に関しては、ジェネリック関数を用いて、そのクラスのオブジェクトを引数にした場合の演算が定義されます。このように、関数名は同じだけどオブジェクトのクラスによって出力が異なる性質のことを**ポリモルフィズム**と呼びます。\n\n以下にS3とS4クラスの値の呼び出しや、関数の適用例を挙げます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# S3クラス\nlm_obj |> class()\n## [1] \"lm\"\n\n# S3クラス：要素の取り出し\nlm_obj$coefficients\n##      (Intercept) iris$Sepal.Width \n##        6.5262226       -0.2233611\n\n# S3クラス：アトリビュートを読み出す\nlm_obj$coefficients |> attributes()\n## $names\n## [1] \"(Intercept)\"      \"iris$Sepal.Width\"\n\n# S3クラス：関数の引数にする（plot.lmが呼び出されている）\nlm_obj |> plot(which = 1)\n```\n\n::: {.cell-output-display}\n![](chapter18_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# S4クラス\nlme4_obj |> class()\n## [1] \"lmerMod\"\n## attr(,\"package\")\n## [1] \"lme4\"\n\n# S4クラス：要素の取り出し\nlme4_obj@pp$beta0\n## [1] 0 0\n\n# S4クラス：アトリビュートを読み出す\nlme4_obj@pp$X |> attributes() |> _$dim\n## [1] 180   2\n\n# S4クラス：関数の引数にする（summary.lmerModが呼び出されている）\nsummary(lme4_obj)\n## Linear mixed model fit by REML ['lmerMod']\n## Formula: Reaction ~ Days + (Days | Subject)\n##    Data: sleepstudy\n## \n## REML criterion at convergence: 1743.6\n## \n## Scaled residuals: \n##     Min      1Q  Median      3Q     Max \n## -3.9536 -0.4634  0.0231  0.4634  5.1793 \n## \n## Random effects:\n##  Groups   Name        Variance Std.Dev. Corr\n##  Subject  (Intercept) 612.10   24.741       \n##           Days         35.07    5.922   0.07\n##  Residual             654.94   25.592       \n## Number of obs: 180, groups:  Subject, 18\n## \n## Fixed effects:\n##             Estimate Std. Error t value\n## (Intercept)  251.405      6.825  36.838\n## Days          10.467      1.546   6.771\n## \n## Correlation of Fixed Effects:\n##      (Intr)\n## Days -0.138\n\n# S4クラス：アクセサ（値を取り出す関数）\ncoef(lme4_obj)\n## $Subject\n##     (Intercept)       Days\n## 308    253.6637 19.6662617\n## 309    211.0064  1.8476053\n## 310    212.4447  5.0184295\n## 330    275.0957  5.6529356\n## 331    273.6654  7.3973743\n## 332    260.4447 10.1951090\n## 333    268.2456 10.2436499\n## 334    244.1725 11.5418676\n## 335    251.0714 -0.2848792\n## 337    286.2956 19.0955511\n## 349    226.1949 11.6407181\n## 350    238.3351 17.0815038\n## 351    255.9830  7.4520239\n## 352    272.2688 14.0032871\n## 369    254.6806 11.3395008\n## 370    225.7921 15.2897709\n## 371    252.2122  9.4791297\n## 372    263.7197 11.7513080\n## \n## attr(,\"class\")\n## [1] \"coef.mer\"\n```\n:::\n",
    "supporting": [
      "chapter18_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}