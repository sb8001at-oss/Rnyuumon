{
  "hash": "f499ccb7b4fb8b029f256cd2b70dcc3a",
  "result": {
    "markdown": "# データの読み込みと書き出し（I/O）\n\n統計に用いるデータは，通常Excelのような表計算ソフトや，データベースなどで作成されます．Rを用いてデータ解析・統計解析を行うためには，まずRにデータを読み込む必要があります．\n\nデータ解析・統計解析が終われば，Rでの解析結果を書き出し，Excelなどで取り扱う必要があります．\n\nこのように，Rで解析を行うためには，データの読み込み・書き出しが必須となります．Rはこのような，データの読み込み・書き出し（Input/Output，**I/O**と呼ばれる）のための関数を多数備えています．\n\n## ディレクトリの操作\n\nまず，データを読み込み，書き出すためには，読み込む・書き出すためのフォルダが必要となります．このフォルダのことを<font color=\"red\">**ディレクトリ**</font>と呼びます．Rでは，そのセッションごとに，<font color=\"red\">**ワーキングディレクトリ（working directory）**</font>というものが設定されます．Rからはこのワーキングディレクトリの中のファイルを確認することができます．\n\nワーキングディレクトリは通常，Rstdioを起動した時に，右下のカラムのfilesタブに表示されています．\n\n![図1：ワーキングディレクトリをfilesタブで確認する](./image/filestab.png)\n\nこのfilesタブでは，任意のフォルダに移動することができます．上図の右上，...と記載されている部分をクリックするとウインドウが開きます．このウインドウ上で任意のフォルダに移動すれば，filesタブに示されるフォルダが変わります．ただし，表示するフォルダを変えるだけではワーキングディレクトリを変更することはできません．\n\nfilesタブに表示されたフォルダにワーキングディレクトリを設定するには，filesタブの右上，「More」から「Set As Working Directory」を選択します．\n\n![図2：MoreのリストからSet As Working Directoryを選ぶ](./image/filestab_options.png)\n\nワーキングディレクトリを変更せずに，ワーキングディレクトリを表示し直す場合は，同じ「More」から「Go To Working Directory」を選択します．\n\nワーキングディレクトリの変更は，上の「Session」からでも変更できます．\n\n![図3：「Session」からワーキングディレクトリを変更する](./image/Session_SetWD.png)\n\nデフォルトのワーキングディレクトリ（Rstudioを開いた時に設定されているワーキングディレクトリ）を変更する場合には，「Tools」→「Option」を選択し，「Default working directory」に任意のフォルダを選択します．\n\n![図4：デフォルトのワーキングディレクトリを変更する](./image/DefaultWD.png)\n\n### getwd関数とsetwd関数\n\n上記のように，Rstudioの機能を使えばワーキングディレクトリを簡単に変更することができます．ただし，データのフォルダ構造によっては，Rでの演算中にワーキングディレクトリを変更したい，といった場合もあります．\n\nワーキングディレクトリの確認と設定は，<font color = \"red\">**getwd関数とsetwd関数**</font>を用いて行うことができます．\n\n<font color = \"red\">**getwd関数**</font>は現在のワーキングディレクトリを確認するための関数です．getwd関数は引数を取らず，実行すると現在のワーキングディレクトリのアドレスを文字列で返します．\n\n<font color = \"red\">**setwd関数**</font>はワーキングディレクトリを変更するための関数です．setwd関数は**文字列のディレクトリのアドレス**を引数に取ります．setwd関数を実行すると，ワーキングディレクトリがアドレスで指定したフォルダに変更されます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd() # ワーキングディレクトリを確認\nsetwd(\"directory/name/as/character\") # ワーキングディレクトリを変更\n```\n:::\n\n\n### 絶対パスと相対パス\n\nディレクトリを指定する際には，**ディレクトリのアドレス**を用います．Windowsでは，フォルダを開き，上のアドレスバーを右クリックすると，アドレスをテキストとしてコピーすることができます．この方法でコピーできるアドレスのことを<font color = \"red\">**絶対パス**</font>と呼びます．絶対パスは，ルートディレクトリ（大元のフォルダ）からそのフォルダまでのアドレスが全て記載されています．\n\n![図5：ディレクトリのアドレス（Windowsの場合）](./image/directory_address.png)\n\nディレクトリのアドレスには，<font color = \"red\">**相対パス**</font>と呼ばれるものもあります．相対パスは，現在のディレクトリの上や下といった，現在のディレクトリからの位置を相対的に表すものです．\n\nsetwd関数は，この絶対パス，相対パスのいずれも使用することができます．絶対パスの場合には，ルートからのすべてのアドレスを文字列で指定します．一方，相対パスの場合は，.（ピリオド）を用いて，現在のディレクトリからの位置を以下のように指定します．\n\n-   <font color = \"red\">**「./」**</font>は今のディレクトリのアドレスを示す記号\n-   <font color = \"red\">**「../」**</font>は今のディレクトリの一つ上のディレクトリを示す記号\n\n上の記号を用いて，一つ下にあるディレクトリは以下のように示すことができます．\n\n<font color = \"red\">**\"./一つ下のフォルダ名\"**</font>\n\nまた，setwd関数は，下のフォルダであれば，そのフォルダまでのパスを記載するだけでもディレクトリを指定することができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"../\") # 一つ上のフォルダにワーキングディレクトリを移動\nsetwd(\"./NameF\") # 一つ下の「NameF」というフォルダにワーキングディレクトリを移動\nsetwd(\"NameF\") # 上と同じ\nsetwd(\"NameF/NameF2\") # NameFフォルダ内のNameF2というフォルダに移動\n```\n:::\n\n\n## ディレクトリ内のファイルの確認\n\nワーキングディレクトリ内のファイルやフォルダは，Rで開いたり，確認したりすることができます．<font color = \"red\">**dir関数とlist.files関数**</font>はワーキングディレクトリ内のファイル・フォルダを表示するための関数です．いずれもファイル・フォルダ名を文字列のベクターとして返します．**list.dirs関数**はワーキングディレクトリ以下にあるフォルダのアドレスを文字列のベクターとして返します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir() # ディレクトリ名とファイル名が返ってくる\nlist.files() # dir関数と同じ\nlist.dirs() # ディレクトリ名のみ返ってくる\n```\n:::\n\n\n## フォルダとファイルの作成\n\n現在のワーキングディレクトリにフォルダを作成する際には，**dir.create関数**を用います．dir.create関数は作成するフォルダ名の文字列を引数に取ります．ワーキングディレクトリ内にファイルを作成する関数はいくつもあります．単にファイルを作るのであればfile.create関数を，文字列をテキストで保存する場合にはcat関数を用います．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(\"tmp\") # 現在のワーキングディレクトリに「tmp」というフォルダを作成\nsetwd(\"tmp\") # 作成したフォルダにワーキングディレクトリを移動\nfile.create(\"filename.txt\") # 空のテキストファイルを作成\ncat(\"Hello world\", file=\"helloworld.txt\") # Hello worldと書き込まれたテキストファイルを作成\n```\n:::\n\n\n## ワークスペースイメージ（.Rdata）の保存\n\n<font color=\"red\">**ワークスペース**</font>とは，Rを実行している時に取り扱っているオブジェクトなどの環境のことです．RGUIやRstudioを閉じるときには，下の図のようなウインドウが表示され，ワークスペースのイメージを保存するかどうか尋ねられます．ワークスペースを保存すると，現在のワーキングディレクトリに「**.RData**」というファイルが作成されます．この.RDataがワークスペースのイメージです．\n\n![図6：Rstudio終了時のワークスペース保存](./image/save_workspace.png)\n\n.RDataファイルはRstudioを閉じるときだけでなく，Rstudioのメニューから「Session → Save Workspace As...」を選ぶことでも保存できます．また，**save.image関数**を用いても，.RDataファイルを作成することができます．\n\n現在のワークスペースの情報は，Rstudio右上のパネルの「Environment」で確認できます．このパネルには，現在Rで取り扱っている変数（オブジェクト）の一覧を確認することができます．\n\n![図7：Environmentパネル](./image/environment_pane.png)\n\nこのパネルに表示されているのと同じ，オブジェクトのリストをR上で取得する場合には，<font color = \"red\">**ls関数**</font>を用います．\n\nRを閉じると，オブジェクトはメモリから削除されます．次にRStudioを起動したときには，デフォルトのワーキングディレクトリに存在する.RDataから自動的にワークスペースのイメージが読み込まれます．別途，.RDataファイルを指定してワークスペースを読み込む場合には，<font color=\"red\">**load関数**</font>を用います．load関数で.RDataファイルを読み込むことで，.RDataファイルを保存した際に使用していたオブジェクトがメモリ上に展開されます．\n\nこのように，ワークスペースを保存・読み込むことで，以前のデータ分析環境を読み込み，データ分析の続きを行うことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls() # 現在メモリ上にある全てのオブジェクトを表示\nsave.image() # ワークスペースのイメージを保存する\nload(\".Rdata\") # ワークスペースのイメージを読み込む\n```\n:::\n\n\n## オブジェクトの保存と読み込み\n\nワークスペース全体ではなく，個別のオブジェクトも，一時的に保存し，読み込むことができます．オブジェクトの保存と読み込みには，<font color=\"red\">**save関数とload関数**</font>を用います．\n\n<font color=\"red\">**save関数**</font>はオブジェクトと文字列のファイル名の2つを引数に取り，オブジェクトを引数で指定したファイル名で保存する関数です．ファイル名は何でもよく，ファイルの拡張子にも特に指定はないのですが，<font color=\"red\">**「.rda」**</font>を拡張子としたファイル名とするのが一般的です．\n\n保存したオブジェクトを読み込む関数が，<font color=\"red\">**load関数**</font>です．load関数はファイル名の文字列を引数に取り，save関数で保存した.rdaファイルを読み込みます．load関数で読み込むと，Rのワークスペースには保存したオブジェクトが現れます．\n\nsave・load関数と同様の関数として，dput関数とdget関数というものもありますが，こちらはそれほど利用されません．dput関数で保存したファイルはload関数で読み込めず，save関数で保存したファイルはdget関数で読み込めないため，dput関数でオブジェクトを保存した場合には，dget関数で読み込む必要があります．dget関数はオブジェクトを返す関数ですので，ワークスペースにオブジェクトが再現されるわけではありません．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nsave(x, file = \"Robject.rda\") # オブジェクトを保存\nrm(x) # xを削除する\nload(\"Robject.rda\") # オブジェクトの読み込み\nx # xが読み込まれている\n\ndput(x, \"Robject_dput.rda\") # オブジェクトを保存\ndget(\"Robject_dput.rda\") # オブジェクトが返ってくる\n\ndget(\"Robject.rda\") # エラー．saveで保存するとdgetで読み込めない\nload(\"Robject_dput.rda\") # エラー．dputで保存するとloadで読み込めない\n```\n:::\n\n\n## データの読み込み\n\n### Excelからデータを読み込む（古典的な方法）\n\n統計を行うデータは，通常Excelのような表計算ソフトか，データベースで準備するのが一般的です．このようなデータをRで取り込む際には，一昔前までは**「テキストファイルに変換」**してから読み込むのが一般的でした．\n\n最近ではライブラリを使用することでExcelやデータベースのファイルから直接データを読み込むことができますが，ライブラリなしのRではこのような読み込みはできません．ライブラリが使用できないときには，以下のような方法でExcelファイルをテキストで保存し，Rで読み込むことになります．\n\nまた，Web上に保存されているデータがテキストである場合も少なくありません．このような，Web上のテキストファイルの読み込みにも，以下に示すテキスト読み込みの方法を用いることができます．\n\n#### Excel：csv・タブ切りテキストへの変換\n\nまずは，Excelでのテキストファイルの変換について説明します．Rで読み込むテキストは，大きく分けると3種類です．\n\n-   **コンマ切りテキスト**（comma-separated values, **csv**）\n-   **タブ切りテキスト**（tab-separated values, **tsv**）\n-   スペース切りテキスト\n-   固定幅テキスト\n\nこれらのうち，スペース切りテキストはデータにスペースが入っていると使えないので通常は避けられます．固定幅テキストはやや取り扱いにくいため，Excelからの変換には用いません．したがって，Excelファイルは主にコンマ切りテキストかタブ切りテキストに変換して，Rで読み込むことになります．\n\nExcelファイルからコンマ切り・タブ切りテキストへの変換はExcel上で行います．Excelの「ファイル」メニューから「名前を付けて保存」を選択し，ファイル名の下のドロップダウンリストから「CSV UTF-8 (コンマ区切り)(*.csv)」もしくは「テキスト (タブ区切り)(*.txt)」を選択します．拡張子である「.csv」や「.txt」は自動的に付与されます．\n\n::: {.callout-tip}\n\n## エンコーディング\n\nテキストには**エンコーディング**というものがあり，日本語テキストは**UTF-8，Shift-JIS（CP932），EUC-JP**のいずれかのエンコーディングを持ちます．エンコーディングが異なると文字化けを起こします．RのデフォルトのエンコーディングはUTF-8です．WindowsではShift-JISが用いられている場合があるため，エンコーディングに注意が必要となります．\n:::\n\n![図8：Excelでコンマ切り・タブ切りテキストを作成する](./image/excel_changeformats.png)\n\n::: {.callout-tip}\n\n## Excelの空欄データ\n\nExcelには「データをセルから消したのに何らかのデータが残る」という謎仕様があります． 空のExcelファイルを作成し（Book1），G7までを1で埋めます（Book2，下図9）．数値をバックスペースで消して保存すると（Book3），何故かBook1よりBook3の方がファイルサイズが大きくなります（下図10）．Rからテキスト変換したファイルを読み込むと，この「無いけど残っているデータ」を読み込んでしまうので，エラーが生じることがあります．データをdeleteで削除，もしくは右クリックから削除を選ぶと，この残ったデータを削除することができます．\n:::\n\n![図9：Excelのセルに1を入力し，バックスペースで削除する](./image/book2_excel.png)\n\n![図10：バックスペースで削除すると，ファイルサイズが増える](./image/filesize_excel.png)\n\n### scan関数\n\nまずは，1行のデータを読み込む場合について説明します．1行のデータであれば，**scan関数**を用いて読み込むことができます．scan関数の第一引数は文字列のファイル名です．ファイル名を指定するときには，必ず**拡張子を含めて記載します**．scan関数には，**「sep」**という引数を指定することができます．sepはデータ間の区切り文字を指定するものです．コンマ切りテキスト，CSVであれば<font color = \"red\">**「sep = \",\"」**</font>，タブ切りテキストであれば<font color = \"red\">**「sep = \"\\\\t\"」**</font>を指定します．scan関数の返り値はベクターとなります．\n\nただし，whatという引数を設定すると，返り値をリストにすることができます．whatは空のリストを指定する引数で，リストの要素の個数に従い，scanで読み取った結果が代入されます．代入の順番は，1つ目がリストの1要素目，2つ目がリストの2要素目...となります．リストの長さより多い要素は再びリストの1要素目に代入されます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscan(\"./data/scansample.txt\", sep = \",\") # コンマ切りテキストを読み込む\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8\n```\n:::\n\n```{.r .cell-code}\nscan(\"./data/scansample.txt\", sep = \",\", what = list(\"\", \"\")) # 出力をリストにする\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"1\" \"3\" \"5\" \"7\"\n\n[[2]]\n[1] \"2\" \"4\" \"6\" \"8\"\n```\n:::\n:::\n\n\n### read.table関数\n\nExcelから読み込む表は，通常行と列を持つ，テーブルの形をしています．テキストに変換したExcelの表をデータフレームとして読み込む関数が<font color=\"red\">**read.table関数**</font>です．read.table関数は第一引数にテキストファイルのファイル名を取ります．scan関数と同様に，ファイル名には拡張子を含める必要があります．\n\nread.table関数はscan関数と同じく，**「sep」**引数を取ります．sep引数には，コンマ切りテキスト，CSVであれば<font color = \"red\">**「sep = \",\"」**</font>，タブ切りテキストであれば<font color = \"red\">**「sep = \"\\\\t\"」**</font>を指定します．\n\nread.table関数は，<font color = \"red\">**「header」**</font>という引数を取ります．この引数にTRUEを指定すると（「header = T」），読み込むテキストの1行目を列名として，データを読み込みます．\n\nread.table関数でよく用いられる引数はファイル名，sep，headerの3つですが，その他たくさんの引数を取ることができます．read.table関数の引数の一覧を以下の表1に示します．\n\n\n::: {.cell}\n::: {.cell-output-display}\nTable: 表1：read.table関数の引数\n\n|引数             |データ型       |意味                                     |デフォルト値      |\n|:----------------|:--------------|:----------------------------------------|:-----------------|\n|file             |文字列         |ファイル名                               |ー                |\n|header           |論理型         |1行目を列名とするか                      |FALSE             |\n|sep              |文字列         |区切り文字（コンマやタブ)                |ー                |\n|quote            |文字列         |文字列が囲まれている文字（\"など）        |\"\\\"'\"             |\n|dec              |文字列         |小数点の文字                             |\".\"               |\n|numerals         |文字列         |文字列を数値に変換するときの正確性       |ー                |\n|row.names        |文字列ベクター |行名                                     |ー                |\n|col.names        |文字列ベクター |列名                                     |ー                |\n|as.is            |文字列         |文字列を因子に変えるときのルール         |!stringAsFactors  |\n|tryLogical       |論理型         |TRUEなどを論理型に変換するか             |TRUE              |\n|na.strings       |文字列         |NAとして取り扱う文字列                   |\"NA\"              |\n|colClasses       |文字列         |列のクラスを指定                         |NA                |\n|nrows            |数値           |読み込む行数                             |-1                |\n|skip             |数値           |読み込まない行数                         |0                 |\n|check.names      |論理型         |列名をチェックするか                     |TRUE              |\n|fill             |論理型         |空きになっている要素をスペースで埋めるか |!blank.lines.skip |\n|strip.white      |論理型         |スペースを取り除くか                     |FALSE             |\n|blank.lines.skip |論理型         |空行をスキップするか                     |TRUE              |\n|comment.char     |文字列         |コメントの開始文字                       |\"#\"               |\n|allowEscapes     |論理型         |エスケープ記号を変換するか               |FALSE             |\n|flush            |論理型         |1行1データかどうか                       |FALSE             |\n|stringAsFactors  |論理型         |文字列を因子に自動変換するか             |FALSE             |\n|fileEncoding     |文字列         |エンコーディングの指定                   |\"\"                |\n|encoding         |文字列         |エンコーディング（変更はしない）         |\"unknown\"         |\n|text             |文字列         |fileから読み込まず，直接データを入力     |ー                |\n|skipNul          |論理型         |空データをスキップするか                 |FALSE             |\n:::\n:::\n\n\n### read.csv関数，read.delim関数\n\nread.table関数の仲間には，csvの読み込み用の<font color = \"red\">**read.csv関数**</font>，タブ切りテキスト読み込み用の<font color = \"red\">**read.delim関数**</font>，固定幅テキストの読み込み用の**read.fwf関数**が準備されています．read.csv関数はsep引数にコンマ，read.delim関数はsep引数にタブがデフォルト値として設定されており，sep引数を記入することなくデータを読み込むことができます．\n\n:::{.callout-tip collapse=\"true\"}\n\n## ヨーロッパで準備されたファイルのデータ読み込み\n\nヨーロッパではコンマ（,）をセミコロン（;），小数点（ピリオド .）をコンマ（,）と記載するため，通常のread.csv関数，read.delim関数ではテキストファイルをまともに読み込むことができません．ヨーロッパで生成されるテキストファイルには，専用の関数（read.csv2，read.delim2）が設けられています．\n:::\n\n#### stringAsFactorsとfileEncoding\n\nread.table関数の「stringAsFactors」という引数は，昔はTRUEがデフォルトとされており，read.table関数で読み込んだ文字列はすべて因子に変換されていました．Rのバージョン4.0.0よりstringAsFactorsのデフォルト値がFALSEに変更されたため，現在のread.table関数では，文字列は文字列のまま読み込まれます．WindowsではテキストファイルのエンコーディングがShift JISになっている場合がありますので，「fileEncoding = \"CP932\"」を引数に指定しないと読み込めないことがあります．エンコーディングがUTF-8であれば，fileEncodingを指定する必要はありません．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.table(\"filename.txt\", sep=\"\\t\", header=T)\nread.table(\"filename.txt\", sep=\"\\t\", header=T, stringAsFactors = T)\nread.csv(\"filename.csv\")\nread.csv2(\"filename.csv\") # ヨーロッパ仕様\nread.delim(\"filename.tsv\")\nread.delim2(\"filename.tsv\") # ヨーロッパ仕様\n\nread.fwf(\"filename.txt\") # 固定幅テキスト\n```\n:::\n\n\n### クリップボードからの読み込み\n\nRでは，コピーしたテキストをクリップボードから読み込むこともできます．Ctrl+Cなどでコピーしたテキストを読み込む場合には，read.table関数の引数に\"clipboard\"を指定します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.table(\"clipboard\")\n```\n:::\n\n\n## データの書き出し\n\nRからのデータの書き出しは，通常テキストファイルで行います．Excelファイルに直接書き出すこともできなくは無いのですが（[xlsxパッケージ](https://cran.r-project.org/web/packages/xlsx/index.html)を利用する），それほど一般的ではありません．データの書き出しに用いられる関数には，**write関数**，**write.table関数**などがあります．\n\n### write・cat関数\n\nベクターや行列などのデータの書き出しには，write関数・cat関数を用います．write関数はcat関数のラッパーで，2つの関数の間には大きな差はありません．cat関数はオブジェクトをコンソールに表示するために用いられますが，ファイルを出力する事もできます．print関数を用いてもコンソールへ表示することはできますが，ファイルを保存することはできません．\n\ncat関数，write関数は，オブジェクトとファイル名を引数に取ります．共にsep引数で区切り文字を指定することができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1, 2, 3)\ncat(vec) # consoleにvecを表示\nwrite(vec) # cat関数と同じ\n\nprint(vec) # print関数でも表示できる\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(vec, file=\"cat.txt\")\nwrite(vec, file=\"vector.txt\", sep=\"\\t\")\nprint(vec, \"print.txt\") # エラー\n```\n:::\n\n\n### write.table関数\n\nRでは，データ処理の多くはデータフレームを用いて行います．統計結果もデータフレームにまとめて取り扱う場合が多いです．\n\nテキストファイルをデータフレームとして取り込むread.table関数と逆に，データフレームをテキストファイルとして書き出す関数が<font color=\"red\">**write.table関数**</font>です．\n\nwrite.table関数はデータフレームとファイル名を引数に取り，データフレームをそのファイル名のテキストファイルとして書き出します．\n\nwrite.table関数の代表的な引数は，**sep，col.names，row.names，quote**の4つです．sepはread.table関数と同じく区切り文字を指定する引数です．col.namesとrow.namesは論理型を取り，TRUEであれば列名・行名を保存し，FALSEであれば列名・行名を省いて保存します．quoteも論理型を取り，文字列・因子をダブルクオーテーションで囲むするかどうかを指定します．\n\nread.table関数にread.csv関数があったように，write.table関数にはCSV用の<font color=\"red\">**write.csv関数**</font>があります．write.csv関数はsepのデフォルト値にコンマが設定されています．ヨーロッパ仕様のwrite.csv2関数もありますが，日本で使用することはまれです．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.table(df_obj, \"filename.txt\", sep = \"\\t\")\n\n# 列名あり，行名なし，ダブルクオーテーションなしで保存\nwrite.table(df_obj, \"filename.txt\", sep = \"\\t\", col.names = T, row.names = F, quote = F) \n\nwrite.csv(df_obj, \"filename.csv\")\nwrite.csv2(df_obj, \"filename.csv\") #  ヨーロッパ仕様\n```\n:::\n\n\n## readr\n\nRのデフォルトのI/Oは上記の通りですが，read.table関数，write.table関数を用いると，指定する引数が多かったり，列のデータ型が思うように設定されなかったりすることがよく起こります．また，デフォルトの関数群は実行速度が遅く，大きなデータを取り扱う場合にはとても時間がかかる，という問題もあります．\n\nこれらの不都合を解決するI/Oに関するライブラリが<font color=\"red\">**readrパッケージ**</font>です．readrパッケージは，Rのデフォルトの関数名のピリオドをアンダースコア（_）に変換した関数群を備えており，列の型をうまく設定してくれる仕組みを備えています．また，デフォルトの関数よりも実行速度が速いため，大きなデータを取り扱う場合には，readrの関数群を用いたほうが良いでしょう．\n\nreadrパッケージはtidyverseを構成するライブラリの一つであり，インストール・ロードはtidyverseライブラリのインストール・ロードと同時に行うことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse)\n```\n:::\n\n\n### readr：テキストデータの読み込み\n\nreadrでのテキストデータの読み込みには，<font color=\"red\">**read_table関数**</font>を用います．read_table関数の使い方はread.table関数とほぼ同じです．read.table関数と同じく，read_table関数も区切り文字をsep引数で設定します．read_table関数のデフォルトの区切り文字はスペースですので，sepを設定しない場合にはスペース切りテキストの読み込みに対応しています．読み込まれたファイルは，<font color=\"red\">**tibble**</font>というデータ型の，データフレームに変換されます．\n\nコンマ切りテキスト（CSV）の読み込みには，read_csvが，タブ切りテキスト（TSV）の読み込みには<font color=\"red\">**read_csv関数とread_tsv関数**</font>が準備されています．これらの他に，ヨーロッパ仕様のCSVを読み込むread_csv2関数，|を区切り文字とするread_delim関数，固定幅テキストの読み込みを行うread_fwf関数などがあります．\n\nreadrパッケージの読み込み関数は圧縮ファイルの読み込みにも対応しており，gzip（.gz），bzip2（.bz2），lzma（.xz），zip（.zip）などの圧縮ファイルを直接読み込むことができます．また，インターネットからテキストファイルを直接読み込むことができます．インターネットから直接読み込む場合には，テキストファイルが保存されているwebアドレス（http://, https://, ftp:// など）をファイル名として設定します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_table(\"filename.txt\") # sep=\" \"（スペース切り）がデフォルト\nread_delim(\"filename.txt\") # sep=\"|\"がデフォルト\nread_csv(\"filename.csv\") # コンマ切りテキスト\nread_csv2(\"filename.csv\") # ヨーロッパ仕様\nread_tsv(\"filename.tsv\") # タブ切りテキスト\nread_fwf(\"filename.txt\") # 固定幅テキスト\n\nread_delim(clipboard()) # クリップボードの読み込み\n\nread_table(\"filename.zip\") # zipファイルも直接読み込める\n```\n:::\n\n\n### tibble\n\nreadrの読み込み関数は，読み込んだデータを<font color=\"red\">**tibble**</font>というデータ型に変換します．このtibbleは概ねデータフレームと同じで，取り扱いもデータフレームと同様に行うことができます．\n\ntibbleはtibble関数で，データフレームと同じように作成することができます．また，as_tibble関数を用いることで，行列や通常のデータフレームをtibbleに変換することができます．\n\nreadrに限らず，tidyverseのライブラリ群はデータフレームをこのtibbleに変換するように設定されているものが多いです．tibbleのデータフレームは，表示した時に列のデータ型を表示する，10行以上の行は省略する，列も省略する等の特徴があります．tibbleについては，tidyr・dplyr，purrrパッケージに関する章で詳しく説明します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse)\n\ntibble(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = c(T, F, T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n      x y     z    \n  <int> <chr> <lgl>\n1     1 a     TRUE \n2     2 b     FALSE\n3     3 c     TRUE \n```\n:::\n\n```{.r .cell-code}\nas_tibble(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n:::\n\n\n### readr：テキストファイルの書き出し\n\nreadrパッケージにはwrite.table関数に当たる，テキスト書き出しの関数を備えています．readrが備えている関数は，データフレームをCSVとして保存する<font color=\"red\">**write_csv関数**</font>，タブ切りテキストとして保存する<font color=\"red\">**write_tsv関数**</font>，スペース切りテキストとして保存する**write_delim関数**があります．write_table関数というものは設定されていないので，基本的にはCSVかタブ切りテキストとして保存することが想定されているようです．\n\nread_table関数と同様に，write_関数もテキストの圧縮ファイルの保存に対応しています．対応している圧縮ファイルはgzip（.gz），bzip2（.bz2），lzma（.xz）です．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(x, \"filename.csv\") # コンマ切り\nwrite_tsv(x, \"filename.tsv\") # タブ切り\nwrite_delim(x, \"filename.txt\") # スペース切り\nwrite_csv2(x, \"filename.csv\") # ヨーロッパ仕様\n\nwrite_csv(x, \"filename.gz\") # gzipで圧縮して出力\nwrite_csv(x, \"filename.bz2\") # bzip2で圧縮して出力\nwrite_csv(x, \"filename.xz\") # lzmaで圧縮して出力\n```\n:::\n\n\n## readxl\n\nR使いは上記のように，昔からExcelをテキストファイルに変換してはRに読み込むというステップを踏み続けてきました．このExcelからテキストへの変換の手間を無くすライブラリが<font color=\"red\">**readxl**</font>パッケージです．\n\nreadxlパッケージもtidyverseと同じく，[Posit Software](https://posit.co/)が開発しているライブラリですが，tidyverseには含まれていません．tidyverseとは別に，readxlパッケージを独立に読み込む必要があります．\n\nreadxlパッケージで使用する関数は，ほぼ<font color=\"red\">**read_excel関数**</font>だけです．read_excel関数は，.xlsおよび.xlsxファイルの読み込みに対応しており，ファイル名で指定したExcelファイルからテーブルをtibbleとして読み込みます．read_excel関数にはsheetという引数を設定することができます．read_excel関数はsheetに設定した番号（もしくはシート名）のシートを読み込みます．\n\nreadxlパッケージにはread_excel関数以外に，Excelファイルのメタデータ読み込みのための関数などを備えています．\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(readxl)\nread_excel(\"filename.xlsx\", sheet = 1) # read_xlsxが読み込まれる\nread_excel(\"filename.xls\", sheet = 1) # read_xlsが読み込まれる\n```\n:::\n\n\n::: {Callout-tip}\nExcelには昔使用されていたファイルである.xlsファイルと，Excel2007から使われている.xlsxファイルがあります．\n\n.xlsファイルはバイナリファイルで，内部的には1と0でデータが表現されています．\n\n.xlsxファイルは実際にはzipファイルで，xmlというフォーマットで記載されたデータがzipファイルのフォルダ内に含まれています．.xlsxファイルは拡張子を.zipに書き換えるとzipファイルとして解凍することができ，中身を確認することができます．\n\n.xlsと.xlsxは全然違うファイルですが，read_excel関数は拡張子によって.xlsを読み込むread_xls関数と.xlsxを読み込むread_xlsx関数を切り替えて呼び出しています．\n:::\n\n#### その他のデータ読み込みライブラリ\n\n[Posit Software](https://posit.co/)はreadxlの他にも，多数のデータ読み込み用ライブラリを開発しています．以下に示したライブラリを利用することで，様々なデータ型のファイルをRで読み込み，統計に用いることができます．\n\n- [googlesheet4](https://googlesheets4.tidyverse.org/)：Googleスプレッドシートの読み込み\n- [haven](https://haven.tidyverse.org/)：SAS，SPSS，Stataファイルの読み込み\n- [jsonlite](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html)：jsonファイルの読み込み\n- [httr](https://httr.r-lib.org/)：Webからの読み込み\n- [rvest](https://rvest.tidyverse.org/)：スクレイピング用ライブラリ\n- [DBI](https://dbi.r-dbi.org/)：データベースの読み込み\n\n## data.table\n\n近年のデータサイエンスでは，100万～数千億程度のデータを取り扱うこともあります．個人のPCでRを使ってこのような超大規模のデータを取り扱うのは現実的ではありませんが，数万～数十万行ぐらいのデータをPCで取り扱う場合は増えてきています．例えば，生物分野では[マイクロアレイ](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%A2%E3%83%AC%E3%82%A4)や[高速シークエンサー](https://jp.illumina.com/content/dam/illumina-marketing/apac/japan/documents/pdf/primer_illumina_sequencing_introduction-j.pdf)のデータは数万～数十万行で，分析を個人が，自分のPCで取り扱うこともあるかと思います．自分でマイクロアレイやシークエンサーを使ってデータを出さなくても，[GEO Dataset](https://www.ncbi.nlm.nih.gov/gds)などからデータを取得して，解析してみるのも昔よりは一般的に行われています．\n\nこのような，超巨大データを取り扱う場合，R謹製のread.table関数では手に余りますし，read_table関数を用いても，読み込んだ後のデータ処理が重く，取り扱いに苦労します．このような大規模データの読み込みに特化したライブラリが，<font color=\"red\">**data.tableパッケージ**</font>です．\n\n[data.tableパッケージ](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)は，大規模データを読み込み，Rで高速に利用できるよう設計されたライブラリです．\n\ndata.tableパッケージでデータを読み込むときには，<font color=\"red\">**fread関数**</font>を用います．fread関数はhtmlからの読み込みにも対応しています．読み込んだデータはdata.tableクラスのオブジェクトとなります．\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(data.table)\n\n# flights14（NYのフライトデータ，25万行11列）をinputとする\ninput <- \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv\"\n\n# freadで読み込む\nflights <- fread(input) # 219MBのデータ読み込み\nclass(flights)\ndim(flights)\n```\n:::\n\n\ndata.tableの取り扱いの方法はほぼデータフレームと同じです．data.tableはインデックスからデータの要約ができる機構を備えています．ただし，後の章で説明するtidyr・dplyrの関数も適用できますので，データの要約はtidyr・dplyrで行ってもよいでしょう．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights[5, 1] # 通常のインデックスに対応\nflights[1:5] # 行列を指定しない場合は，行のインデックスになる\nflights[1:5, 2:5] # ベクターでの読み出しにも対応\n\nhead(flights[origin == \"JFK\", ]) # originがJFKの行を選択\nhead(flights[, .(month, day)]) # monthとdayの列を選択\nhead(flights$origin) # originの列を抽出\n```\n:::\n\n\n> data.tableが使われ始めた頃は，data.tableオブジェクトの取り扱い方がデータフレームとは大きく異なっており，かなりとっつきにくかったのですが，現在ではデータフレームとほぼ同じ取り扱いができるようになっています．\n",
    "supporting": [
      "chapter13_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}