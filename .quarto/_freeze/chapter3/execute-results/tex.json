{
  "hash": "4cb65daff5dfcddd7b78bec91347659e",
  "result": {
    "markdown": "# オブジェクトと変数・定数\n\n## プログラミング言語としてのR\n\nR言語は統計の計算を行うために開発されたプログラミング言語です．プログラミング言語としての仕様はS言語という，ベル研究所によって開発された言語を参考としています．R言語は，「動的型付け，型推論，インタプリタ型，オブジェクト指向の関数型言語」というタイプのプログラミング言語です．プログラミング未体験の方にはすべての単語が意味不明であるかと思いますが，単語の意味については順々に紹介していきます．\n\nまずは，<font color=\"red\">**「インタプリタ」**</font>について説明します．インタプリタとは，プログラムをコンパイルすることなく実行することができる環境のことを指します．\n\nこの，<font color=\"red\">**「コンパイル」**</font>というのは，プログラムを機械語に置き換える変換のことを指します．\n\n<font color=\"red\">**「機械語」**</font>というのも聞き覚えがない言葉だと思います．機械語とは，コンピュータが読み取れる，1と0だけからなる数字の列のことです．コンピュータは我々の言語や画像などをそのまま処理することはできず，1ビット単位（1と0）の情報だけを取り扱うことができます．プログラミング言語のうち，例えばCやJavaでは，プログラムはまず機械語に変換，コンパイルされます．コンパイルされたプログラムだけがコンピュータ上で実行できます（下図）．\n\n![図1：コンパイルと機械語への変換](./image/compile.png)\n\n一方，インタプリタ型の言語では，プログラミング言語をコンパイルすることなく実行することができます．インタプリタ型の言語には[Python](https://www.python.org/)や[Ruby](https://www.ruby-lang.org/ja/)，[PHP](https://www.php.net/)，[Julia](https://julialang.org/)などがあります．コンパイルには通常時間がかかりますが，インタプリタ型言語ではコンパイルに時間をかけることなく，すぐにプログラムを実行することができるというメリットがあります．一方で，プログラムを実行し，完了するまでの時間はコンパイルを行うプログラミング言語よりも遅くなるというデメリットもあります．\n\nRはインタプリタ型の言語ですので，記述したプログラム（スクリプトとも呼びます）はすぐに実行されます．一方で，Rでの計算速度はインタプリタ型言語の中でもかなり遅い部類に入ります．ただし，Rは主にad hocな（その場一回限りの）統計解析に用いられる言語です．1回限りであれば，それほど計算が早くなくても問題とはなりませんし，入力したプログラムがすぐに実行されるという性質も統計解析との相性がよいものです．コンピュータの性能も昔より遥かに高くなっており，R言語での計算が遅いと感じることは減ってきています．\n\n## オブジェクトとは？\n\nRは<font color=\"red\">**オブジェクト指向（Object oriented）**</font>の言語である，とされています．この<font color=\"red\">**「オブジェクト指向」**</font>という言葉はプログラミング言語ではよく用いられるものですが，厳密な定義は複雑です．\n\nこの<font color=\"red\">**オブジェクト**</font>というのは，プログラミングで取り扱うものすべてを指す言葉です．プログラミングでは，<font color=\"red\">**数値**</font>や<font color=\"red\">**文字**</font>などを取り扱い，数値の演算を行ったり，文字に対して検索や置換，文字の追加などを行います．このとき，取り扱う数値や文字はオブジェクト，つまりプログラミングで用いる「もの」であるということになります．Rでは数値や文字の他に，<font color=\"red\">**因子（factor）**</font>や<font color=\"red\">**論理値（booleanまたはlogical）**</font>，<font color=\"red\">**関数（function）**</font>などを取り扱います．これらのすべてがプログラミングで取り扱う「もの」，つまりオブジェクトです．\n\n上で述べたように，プログラミングで用いるオブジェクトには数値，文字，因子，関数など，様々な種類のものがあります．数値も文字もプログラミングで扱う「もの」であることは共通していますが，数値と文字に対して同じ演算をしたい，ということは通常ありません．数値なら掛け算や割り算を行うことがあっても，文字に対して掛け算や割り算はしません．プログラミング言語も，数値なら数値の演算，文字なら文字の演算を行う必要があります．このように，数値なら数値の，文字なら文字の処理を行うために，オブジェクトには<font color=\"red\">**「型（type）」**</font>というものがあります．\n\n\n::: {.cell filename='型と演算の関係'}\n\n```{.r .cell-code}\n1*1 # 数値同士を掛け算することがあっても，\n## [1] 1\n1*\"dog\" # 数値と文字列を掛け算できてしまうと困る（エラーが出る）\n## Error in 1 * \"dog\": non-numeric argument to binary operator\n```\n:::\n\n\n## 型（type）とは？\n\n<font color=\"red\">**型（type）**</font>とは，そのオブジェクトの種類を定めるためのラベルのようなものです．例えば，Rで数値を入力すると，Rは自動的にその数値がnumericであるという風に認識します．同様に，\"（ダブルクオーテーション）で文字を囲うと，Rは自動的にその文字がcharacter（文字列型）であると認識します．Rはこの認識した型に従い，そのオブジェクトに対する演算を行います．\n\nオブジェクトの型は<font color=\"red\">**mode関数**</font>で確認することができます．関数については後ほど詳しく説明します．\n\n\n::: {.cell filename='typeof関数で型を確認する'}\n\n```{.r .cell-code}\nmode(1) # 1は数値\n## [1] \"numeric\"\nmode(\"Hello world\") # \"Hello world\"は文字列\n## [1] \"character\"\nmode(\"1\") # \"1\"は文字列\n## [1] \"character\"\n```\n:::\n\n\n上記のように，「1」の数字をmode()のカッコの中に入れると，numericが返ってきます．これは，1というオブジェクトの型がnumeric（数値）であることを示しています．同様に，ダブルクオーテーションで囲まれた\"Hello world\"をmode()のカッコに入れると，characterが返ってきます．これは，\"Hello world\"の型がcharacter（文字列）であることを意味しています．では，ダブルクオーテーションで囲まれた\"1\"がどうなるかというと，これはcharacter，つまり文字列であるということになります．\n\nRでは，このように「ダブルクオーテーションで囲まれている」というオブジェクトの状態を調べ，囲まれていればそのオブジェクトは文字列型であると判断します．同様に，オブジェクトが「数値でかつダブルクオーテーションに囲まれていない」場合には，そのオブジェクトが数値型であると判断します．このように，プログラム上でオブジェクトの型を特に指定していなくても，Rは自動的にそのオブジェクトの型を決定してくれます．このようなプログラムの性質を<font color=\"red\">**「型推論」**</font>と呼びます．\n\nでは，Rの代表的な型について，これから簡単に説明していきます．\n\n### 文字列（character）\n\n一般的なプログラミング言語で最も取り扱うことが多いオブジェクトは<font color=\"red\">**文字列型（character）**</font>です．文字列，つまり文章などを検索したり，一部を取り出したり，条件に合っているか確認したりすることはプログラミング利用の目的の一つとなります．\n\nRは統計学のプログラミング言語ですので，どちらかというと文字列よりは数値を取り扱うことが多いのですが，文字列を取り扱える仕組みを一通り備えています．\n\nRで文字列型のオブジェクトを作成するときには，\"（ダブルクオーテーション）もしくは'（シングルクォーテーション）で文字を囲みます．ダブルクオーテーション・シングルクオーテーションのどちらを用いても文字列のオブジェクトを作成することはできます．\n\n\n::: {.cell filename='文字列オブジェクトの例'}\n\n```{.r .cell-code}\n\"Hello world\" # ダブルクオーテーションで囲った場合\n## [1] \"Hello world\"\n'Hello R' # シングルクオーテーションで囲った場合\n## [1] \"Hello R\"\n```\n:::\n\n\nでは，ダブルクオーテーションとシングルクオーテーションの違いは何かというと，何も違いません．どちらを用いても問題ないのですが，Rではダブルクオーテーションを用いるのが一般的です．\n\n#### エスケープ文字（エスケープシーケンス）\n\nプログラミング言語によっては，ダブルクオーテーションとシングルクオーテーションで<font color=\"red\">**エスケープ文字（エスケープシーケンス）**</font>の取扱いに違いがある場合があります．エスケープシーケンスとは，バックスラッシュ（＼，日本語キーボードでは¥）とアルファベットを組み合わせて，特定の意味を持たせる表現のことを指します．例えば，\\\\nは改行を，\\\\tはタブを示す記号です．RではC言語由来のエスケープシーケンスを利用できることになっています．以下にエスケープシーケンスの例を挙げます．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：エスケープ文字の例</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> エスケープ文字 </th>\n   <th style=\"text-align:left;\"> エスケープ文字の意味 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> \\a </td>\n   <td style=\"text-align:left;\"> アラート </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\b </td>\n   <td style=\"text-align:left;\"> バックスペース </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\f </td>\n   <td style=\"text-align:left;\"> ページ分割 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\n </td>\n   <td style=\"text-align:left;\"> 改行 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\r </td>\n   <td style=\"text-align:left;\"> キャリッジリターン </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\t </td>\n   <td style=\"text-align:left;\"> 水平タブ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\v </td>\n   <td style=\"text-align:left;\"> 垂直タブ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\\\ </td>\n   <td style=\"text-align:left;\"> バックスラッシュ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\' </td>\n   <td style=\"text-align:left;\"> シングルクオーテーション </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> \\&quot; </td>\n   <td style=\"text-align:left;\"> ダブルクオーテーション </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nRで表示しているときに必要となるエスケープ記号は，ダブルクオーテーションやシングルクオーテーションを用いるときのみです．ただし，Rのデータをテキストファイルなどに書き出すときには，エスケープ文字，特に\\\\n（改行）や\\\\t（タブ）を用いることがあります．データ書き出しの際のエスケープ文字に関しては，別の章で詳しく説明します．\n\nエスケープシーケンスを変換した文字列を表示する場合には，writeLines関数を用います．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(\"Hello world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello world\n```\n:::\n\n```{.r .cell-code}\nwriteLines(\"Hello\\nworld\") # \\nは改行に変換\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nworld\n```\n:::\n\n```{.r .cell-code}\nprint(\"Hello\\nworld\") # print関数はエスケープシーケンスを変換しない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\\nworld\"\n```\n:::\n:::\n\n\n#### 文字列を結合する\n\nRで文字列を用いるときに，文字列Aと文字列Bをくっつけたい，ということがあります．このようなときに用いるのが，<font color=\"red\">**paste関数**</font>です．paste関数はカッコの中に2つ以上の文字列をコンマでつないで入れると，文字列をスペースを挟んでつなぎ合わせてくれます．文字列の間にスペースが必要ない場合には，paste0関数を用います．\n\n\n::: {.cell filename='文字列をつなぐpaste関数'}\n\n```{.r .cell-code}\npaste(\"Hello\", \"world\")\n## [1] \"Hello world\"\npaste0(\"Hello\", \"R\")\n## [1] \"HelloR\"\n```\n:::\n\n\n文字列の取扱いに関しては，別の章で詳しく説明します．\n\n### 数値（numeric）\n\nRは統計の言語ですので，数値データを取り扱う機会が特に多いです．グラフを記述したり，データを要約する場合にも主に取り扱うのは数値です．Rでは，数値は<font color=\"red\">**numeric**</font>という型を持ちます．\n\n#### 数値型のdouble（浮動小数点）とinteger（整数）\n\n数値には更に詳細な型があります．詳細な型は<font color=\"red\">**typeof関数**</font>で調べることができます．Rでの数値は通常doubleという型を持ちます．\n\n> プログラミング言語の小数点を含む数値は，その精度（桁数）により，single（浮動小数点型），double（倍精度浮動小数点型）などの型を持ちます．このsingleはdoubleよりオブジェクトのファイルサイズが小さい代わりに，あまり大きい桁数の数値は取り扱えないという特徴があります．Rにはsingleという型はなく，doubleのみが使用されます．\n\n数値にはdouble以外に，integer（整数）という型もあります．Rで整数型の数値を利用する時には，数字の後ろにLをつけます．数値であっても，ダブルクオーテーションで囲うと文字列 （character）になります．\n\n\n::: {.cell filename='double型とinteger型'}\n\n```{.r .cell-code}\nmode(1) # modeでの型はnumeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1) # これはdouble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1L) # これはinteger\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(\"1\") # これはcharacter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nRではintegerを取り扱う機会は非常に少なく，通常数値はdoubleとして取り扱います．\n\n#### クラス（class）\n\nRではオブジェクトは型以外に，<font color=\"red\">**クラス（class）**</font>という性質を別に持っています．Rでの数値型は，numeric（数値）というクラスを持ちます．クラスの確認には<font color=\"red\">**class関数**</font>を用います．\n\n\n::: {.cell filename='クラス，モードとtypeof関数'}\n\n```{.r .cell-code}\nmode(1) # 型はnumeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(1) # typeofだとdouble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nclass(1) # クラスはnumeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n> Rのオブジェクトは型だけでなく，アトリビュート（Attribute）という性質を別に持っています．クラスはこのAttributeの一つです．オブジェクト指向プログラミングではクラスは非常に重要な意味を持ちますので，別の機会に詳しく説明します．\n\n#### 演算子（operator）\n\n数値を扱う際には，四則演算等の計算を行うことがあります．この四則演算を行うための記号のことを，<font color=\"red\">**演算子**</font>と呼びます．Rでは以下の四則演算子を利用できます．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表2：Rで使える演算子</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 演算子 </th>\n   <th style=\"text-align:left;\"> 演算の種類 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> + </td>\n   <td style=\"text-align:left;\"> 足し算 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> - </td>\n   <td style=\"text-align:left;\"> 引き算 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> * </td>\n   <td style=\"text-align:left;\"> 掛け算 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> / </td>\n   <td style=\"text-align:left;\"> 割り算 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> %% </td>\n   <td style=\"text-align:left;\"> 剰余（割り算の余り） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> %/% </td>\n   <td style=\"text-align:left;\"> 整数の割り算 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ^ </td>\n   <td style=\"text-align:left;\"> 累乗 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n演算子それぞれの計算結果は以下のようになります．ほとんどの演算子はExcelなどで用いられているものと同じです．\n\n\n::: {.cell filename='四則演算の例'}\n\n```{.r .cell-code}\n3+2 # 足し算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n3-2 # 引き算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n3*2 # 掛け算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n3/2 # 割り算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5\n```\n:::\n\n```{.r .cell-code}\n3%%2 # 剰余（余り）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n3%/%2 # 整数の割り算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n3^2 # 累乗\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n### 因子（factor）\n\n<font color=\"red\">**因子（factor）**</font>はR以外のプログラミング言語にはない型の一つです．因子とは，カテゴリを表すときに用いる型です．カテゴリとは，例えば男性/女性や，成人/未成年，喫煙者/非喫煙者などの，そのデータの性質を表す要素のことを指します．統計では，例えば男性と女性で分けて数値を集計する，といったシチュエーションがたくさんあります．このように，カテゴリごとの集計や統計を行いやすくするために準備されている型が因子です．因子は<font color=\"red\">**factor関数**</font>を用いて作成します．\n\n\n::: {.cell filename='因子型（factor）'}\n\n```{.r .cell-code}\nfactor(\"male\") # 男性を示す因子\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] male\nLevels: male\n```\n:::\n\n```{.r .cell-code}\nmode(factor(\"male\")) # 因子の型はfactor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n> 因子には，レベル（Levels）というアトリビュートが付いています．因子はカテゴリを示すものですので，通常1つだけで用いることはありません（カテゴリが1つだけであれば，カテゴリ分けする必要がありません）．因子については後ほど詳しく説明します．\n\n### 論理型（logical）\n\n<font color=\"red\">**論理型（logical）**</font>は，<font color=\"red\">**TRUE（真）**</font>と<font color=\"red\">**FALSE（偽）**</font>からなる2値の型です．TRUEとFALSEはその名の通り，その関係が正しいか，間違っているかを意味するものです．論理型はそのまま使用することもありますが，プログラミングでは<font color=\"red\">**比較演算子**</font>と共に用いることが多い型です．\n\n#### 比較演算子\n\n<font color=\"red\">**比較演算子**</font>とは，演算子の右と左を比較して，その関係が正しい（TRUE）のか，間違っているのか（FALSE）を返す演算子です．比較演算子の例を以下に示します．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表3：Rで使える比較演算子</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 比較演算子 </th>\n   <th style=\"text-align:left;\"> 比較演算子の意味 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> == </td>\n   <td style=\"text-align:left;\"> 等しい </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> != </td>\n   <td style=\"text-align:left;\"> 等しくない </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &lt; </td>\n   <td style=\"text-align:left;\"> 小なり </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &lt;= </td>\n   <td style=\"text-align:left;\"> 小なりイコール </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &gt; </td>\n   <td style=\"text-align:left;\"> 大なり </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &gt;= </td>\n   <td style=\"text-align:left;\"> 大なりイコール </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &amp; </td>\n   <td style=\"text-align:left;\"> かつ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &amp;&amp; </td>\n   <td style=\"text-align:left;\"> かつ </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> | </td>\n   <td style=\"text-align:left;\"> または </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> || </td>\n   <td style=\"text-align:left;\"> または </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n&と\\|は比較演算子同士を結びつけるための演算子（論理演算子）です．&と&&，\\|と\\|\\|の違いについては，後ほど説明します．\n\n比較演算子を用いた演算の例を以下に示します．比較演算子や論理型は主に<font color=\"red\">**条件分岐**</font>で用います．\n\n\n::: {.cell filename='比較演算子'}\n\n```{.r .cell-code}\n1 == 1 # 等しいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 == 2 # 等しくないのでFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n1 != 1 # 等しいのでFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n1 != 2 # 等しくないのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 < 2 # 2は1より小さいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 < 1 # 1は1より小さくないのでFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n1 <= 2 # 2は1より小さいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 <= 1 # 1は1に等しいのでTURE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n3 > 2 # 3は2より大きいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n2 > 2 # 2は2より大きくないのでFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n3 >= 2 # 3は2より大きいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n2 >= 2 # 2は2と等しいのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 == 1 & 2 == 2 # TRUEかつTRUEなのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 == 1 & 2 == 3 # TRUEかつFALSEなのでFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n1 == 1 | 2 == 2 # TRUEまたはTRUEなのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n1 == 1 | 2 == 3 # TRUEまたはFALSEなのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### 演算子の優先順位\n\n数値の計算で掛け算・割り算を足し算・引き算より前に計算するように，演算子の優先順位，計算する順番は決まっています．概ね通常の計算と同じですが，以下のような順序で演算子は計算されます．\n\n1.  カッコでくくられている計算\n2.  累乗（\\^）\n3.  剰余・整数の割り算（%%・%/%）\n4.  掛け算・割り算（\\*・/）\n5.  足し算・引き算（+・-）\n6.  比較演算子（==，!=，\\<，\\<=，\\>，\\>=）\n7.  論理演算子（&，\\|）\n\n計算式は長くなることが多く，演算子の計算順を間違う場合も多いため，優先する計算は積極的にカッコで囲むとよいでしょう．\n\n\n::: {.cell filename='演算子の計算順序'}\n\n```{.r .cell-code}\n(2 + 1) / 3 # カッコ内は最優先\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n2 ^ 3 %% 5 # 累乗は剰余より先に計算(8/5の余り)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n3 / 3 %% 2 # 剰余は割り算より先に計算（3/1を計算）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n3 / 3 + 1 # 割り算は足し算より先に計算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n3 + 3 > 5 # 比較演算子は足し算より後に計算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5 > 1 & 6 > 2 # 論理演算子は最後に計算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### その他のクラス\n\n以上の4つ（文字列，数値，因子，論理型）がRでの基本的な型になります．しかし，Rにはこの4つ以外の型を持つオブジェクトも存在します．\n\n#### 欠損値など\n\nデータ分析では欠損値や，計算結果が表示できないもの，計算結果が無限大になるものなど，データとしてうまく取り扱えない値が生じることがよくあります．このような場合に対応するため，Rは欠損値，計算できない値，無限大にそれぞれNA，NaN，Infという型が設定されています．Rでは中身が何もないオブジェクト，NULLというものを作成することもできます．\n\n\n::: {.cell filename='欠損値，非数，無限大'}\n\n```{.r .cell-code}\nNA # 欠損値（Not Available）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\n0/0 # 非数（NaN，Not A Number）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n\n```{.r .cell-code}\n1/0 # 無限大（Inf）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\n10000^1000000 # 大きすぎて取り扱えない数値もInfになる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\nNULL # 中身がないオブジェクト（NULL）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n#### 複素数（complex）\n\nRでは複素数（整数+虚数）を取り扱うこともできます．複素数を表すときには，数値の後にiを入力します．\n\n\n::: {.cell filename='複素数の作成と演算'}\n\n```{.r .cell-code}\n1 + 1i # 複素数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1+1i\n```\n:::\n\n```{.r .cell-code}\nmode(1 + 1i) # 複素数の型はcomplex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"complex\"\n```\n:::\n\n```{.r .cell-code}\n(1 + 1i) + (3 + 3i) # 複素数同士の足し算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4+4i\n```\n:::\n:::\n\n\n#### 日時のクラス（Date，POSIXct，POSIXlt，difftime）\n\n日付は数値や文字列とは異なる性質を持ちます．統計では日付や時間を演算に用いることもあります．Rでは日付はDateというクラスを持ちます．また，日時のデータはPOSIXctやPOSIXltというクラスに属します．\n\nDateやPOSIXct，POSIXltは引き算などの演算に用いることができます．日時の差はdulationsというクラスを持ちます．\n\nDate，POSIXct，POSIXlt，dulationはいずれもクラスで，データの型としてはdouble，つまり数値型のデータとして取り扱われます．\n\n\n::: {.cell filename='日時のクラスと型'}\n\n```{.r .cell-code}\nSys.Date() # 現在の日付を表示する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-31\"\n```\n:::\n\n```{.r .cell-code}\nclass(Sys.Date()) # 日付のクラスはDate\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(Sys.Date()) # 日付の型はdouble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nSys.time() # 現在の日時を表示する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023-10-31 14:56:04 JST\"\n```\n:::\n\n```{.r .cell-code}\nclass(Sys.time()) # 日時のクラスはPOSIXctとPOSIXlt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n\n```{.r .cell-code}\ntypeof(Sys.time()) # 日時の型はdouble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nSys.Date() - as.Date(\"2023-01-01\") # 2022/1/1から今日までの日数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 303 days\n```\n:::\n\n```{.r .cell-code}\nclass(Sys.Date() - as.Date(\"2023-01-01\")) # 日時の差のクラスはdifftime\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"difftime\"\n```\n:::\n:::\n\n\n> Rには，これらの型の他に，S3，S4，R5（Reference Class），R6というデータ型が存在します．これらのデータ型は関数などの計算結果に用いられていることがあります．これらのオブジェクトについては，クラスとオブジェクト指向と関連していますので，クラスの詳しい説明に合わせて解説します．\n\n## 変数と定数\n\n### 変数\n\nココまでは，数値や文字列などの，単純なオブジェクトについて説明してきました．単純なオブジェクトはプログラミングの要素として重要です．しかし，オブジェクトを毎回作成し直すのは面倒です．オブジェクトを作ったら，それを一時的に保管しておいて，後から演算に使える方が便利です．\n\n電卓では，このような「一時的に結果を記録する」方法として，メモリー機能があります．Excelなどでは，計算結果をセルに記録しておくこともあるでしょう．プログラミング言語にも，計算結果を一時的に保管しておくものが準備されています．この「計算結果を一時的に保管しておくもの」のことを，プログラミング言語では<font color=\"red\">**変数**</font>と呼びます．\n\n変数には名前がついています．名前付きの箱の中にオブジェクトを入れているようなものが変数です．下の図では，変数「dog」にオブジェクト「犬」を入れています．「犬」を取り出して使いたいときには，変数である「dog」を持ってくればよい，ということになります．\n\n![図2：変数のイメージ](./image/variable_image.png)\n\nRで変数を作成する場合には，変数名に「\\<-」の記号でオブジェクトを<font color=\"red\">**代入**</font>します．\n\n\n::: {.cell filename='変数への代入'}\n\n```{.r .cell-code}\ndog <- \"inu\" # dogという変数に\"inu\"という文字列を代入する\nnumber <- 1 # numberという変数に，1という数値を代入する\ndog # 変数dogには\"inu\"が入っている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"inu\"\n```\n:::\n\n```{.r .cell-code}\nnumber # 変数numberには1が入っている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n変数には型があり，代入したオブジェクトと同じ型を持つことになります．また，変数はそのまま演算に用いることができます．\n\n\n::: {.cell filename='変数の型'}\n\n```{.r .cell-code}\nmode(dog) # dogの中身は文字列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nmode(number) # numberの中身は数値\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\npaste(dog, \"walk\") # dogの中身と\"walk\"をつなぐ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"inu walk\"\n```\n:::\n\n```{.r .cell-code}\nnumber + 5 # numberの中身に5を足す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\ndog + 1 # dogの中身は文字列なので，足し算はできない\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in dog + 1: non-numeric argument to binary operator\n```\n:::\n:::\n\n\n変数への代入は，「=」や「-\\>」の演算子によっても行うことができます．ただし，これらを代入に用いると，プログラムを理解しにくくなるため，Rでは「\\<-」を用いることが推奨されています．\n\n\n::: {.cell filename='=や->による代入'}\n\n```{.r .cell-code}\ndog = \"犬\" # イコールも代入に使うことができる\n2 -> number # ->も代入に使える（方向は<-と逆になる）\ndog\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"犬\"\n```\n:::\n\n```{.r .cell-code}\nnumber\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n### 定数\n\n変数のうち，一度代入したら中身を変えられないもののことを<font color=\"red\">**定数**</font>と呼びます．他のプログラミング言語では定数を設定できるものが多いのですが，Rには定数を設定する方法はありません．変数の中身はいつでも置き換えできます．変数を置き換えると，置き換えたオブジェクトの型で変数の型も置き換わります．\n\n\n::: {.cell filename='変数の置き換え'}\n\n```{.r .cell-code}\ndog <- \"inu\" # 変数に文字列を代入\nmode(dog) # 型は文字列になる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ndog <- 1 # 変数に数値を入れ直す\nmode(dog) # 変数の型は数値になる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n> 多くのプログラミング言語では，このように変数の型が変化するのを抑える仕組み（型宣言）を持っています．型宣言が必要な言語では，変数は厳密に型のチェックを受けます（静的型付け）．Rはこのような仕組みがなく，代入されたオブジェクトに従って型が決まり，型チェックされることなくプログラムが実行されます．このような言語のことを動的型付けと呼びます．\n\nプログラム中で変数の型が変わると，バグの原因となります．Rでは，プログラムを書いているうちに変数の型が変化していて，計算結果がおかしくなる，ということがたびたび起きます．変数の型を確認しながらプログラミングした方がよいでしょう．\n\n定数とは少し異なりますが，Rでは代入なしに使える変数もあります．例えば，円周率のπは「pi」という変数名で始めから登録されています．このような変数にも別のオブジェクトを代入することはできますが，後々混乱する原因となるため避けたほうがよいでしょう．\n\nまた，統計を試すことができるデータが代入されている変数（データセット）もたくさん設定されています．データセットについては，後ほど詳しく説明します．\n\n\n::: {.cell filename='あらかじめ設定されている変数'}\n\n```{.r .cell-code}\npi # 円周率\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.141593\n```\n:::\n\n```{.r .cell-code}\nletters # アルファベット（小文字）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n\n```{.r .cell-code}\nLETTERS # アルファベット（大文字）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n:::\n\n```{.r .cell-code}\nmonth.abb # 月（短縮表記）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n```\n:::\n\n```{.r .cell-code}\nmonth.name # 月\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n```\n:::\n\n```{.r .cell-code}\npi <- 3 # piに3を代入する\npi # piは3になってしまう\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 値渡しと参照渡し\n\nRでは，変数への代入が行われるたびに，その変数に対するメモリのアドレスを新規に作成し直す，という特徴があるため，他の言語で理解が必要となる値渡しと参照渡しの問題がほとんど起きません．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1 # xに1を代入\ny <- x # yにxを代入（yとxはメモリを共有）\nx <- 2 # xに2を代入（xのメモリのアドレスが変わる）\nx # xは新しいアドレスを参照（2が返ってくる）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ny # yは古いアドレスを参照（1が返ってくる）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n> 上のコードでは，参照渡しであれば，xの値が2になった場合，xとメモリを共有しているyも2になります．Rでは，代入時にメモリのアドレスが変更になるため（値渡し），参照渡しが起こることは基本的にありません．この特徴はプログラミング初心者には優しいのですが，変数の変更のたびにメモリ上にオブジェクトを新規作成するため，Rの実行速度が遅い原因になります．\n\n## 便利なオブジェクト\n\nここまでは，オブジェクトが一つだけの場合のデータ型や，変数について見てきました．しかし，統計で取り扱うのは，通常たくさんの数値や記録です．数値や記録がたくさんある場合には，数値や記録を一つづつ別々に取り扱うのは非効率です．多くのプログラミング言語では，このようなたくさんの数値や記録を取り扱う専用のオブジェクトを備えています．Rでは，たくさんの記録を取り扱うオブジェクトとして，<font color=\"red\">**ベクター（vector）**</font>，<font color=\"red\">**リスト（list）**</font>，<font color=\"red\">**データフレーム（data.frame）**</font>，<font color=\"red\">**行列（matrix）**</font>の4つが用いられます．この4つについて簡単に説明します．それぞれのオブジェクトについてはさらに別章で詳しく説明します．\n\n### ベクター（vector）\n\nRで最も基本的なオブジェクトは，ベクター（vector）です．ベクターは同じ型を持つオブジェクトの集まりで，1次元の，つまり縦横の構造がないデータとして取り扱われます．ベクターは<font color=\"red\">**c関数**</font>（cはcombine，「結合する」の意味）で作成することができます．\n\nベクターは同じ型を持つデータの集まりです．ですので，ベクターの要素に文字列が交じると，自動的にすべての要素が文字列になる，という特徴があります．\n\n\n::: {.cell filename='ベクターの作成'}\n\n```{.r .cell-code}\nvec_n <- c(1, 2, 3, 4) # 数値のベクター\nvec_c <- c(\"dog\", \"cat\", \"pig\", \"horse\") # 文字列のベクター\nvec_temp <- c(1, 2, 3, \"dog\") # 文字列が交じると文字列のベクターになる\n\nvec_n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nvec_c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"   \"cat\"   \"pig\"   \"horse\"\n```\n:::\n\n```{.r .cell-code}\nvec_temp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"   \"2\"   \"3\"   \"dog\"\n```\n:::\n:::\n\n\nRでは数値1つや文字列1つの要素も，ベクターとして取り扱われます．ですので，Rのオブジェクトの最小単位はベクターとなります．要素が1つであれば，c関数でつなぎ合わせる必要はありません．\n\n\n::: {.cell filenames='要素が1つだけのベクター'}\n\n```{.r .cell-code}\n1 # 数字1つでもベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n\"Hello world\" # 文字列1つでもベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello world\"\n```\n:::\n:::\n\n\n> vectorはベクトルと表記されることもあります．この文書では，Rのオブジェクトをベクター，方向と大きさを持つ量のことをベクトルと表記することとします．\n\n#### ベクターに要素を追加する\n\nベクターに要素を追加するために，append関数というものが用意されています．しかし，上記のc関数でもベクターに要素を追加することができます．\n\nappend関数では位置を特定して要素を追加することができますが，位置を特定して要素を追加することはまれです．\n\n\n::: {.cell filename='ベクターに要素を追加する'}\n\n```{.r .cell-code}\nappend(vec_n, 5) # 上の数値ベクターに5を追加\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nc(vec_n, 5) # 上と同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n#### ベクターの要素を取り出す\n\nベクターの要素を取り出すときには，<font color=\"red\">**インデックス**</font>というものを用います．インデックスとは，ベクターなどの複数の値を取り扱うオブジェクトにおいて，値のある位置を示す数値のことです．インデックスはベクターの変数の後に，四角カッコ（\\[\\]）に数値を入れることで指定することができます．Rではインデックスは1から始まります．\n\n> 多くのプログラミング言語では，インデックスは0から始まります．インデックスが1から始まるプログラミング言語はまれです．\n\n![図3：ベクターとインデックス](./image/vector_index.png)\n\n\n::: {.cell filename='ベクターの要素をインデックスで取り出す'}\n\n```{.r .cell-code}\nvec <- c(4, 3, 2, 1) # 数値のベクターを作成する\nvec[1] # インデックス1には4が入っている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nvec[3] # インデックス3には2が入っている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n#### ベクターの要素の置き換え\n\nベクターの要素を置き換えるときには，置き換えたいベクターのインデックスを指定し，代入します．この時，数値のベクターの要素を文字列に置き換えると，ベクター全体が文字列に置き換わるので注意して下さい．\n\n\n::: {.cell filename='ベクターの要素を置き換える'}\n\n```{.r .cell-code}\nvec # 数値のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3 2 1\n```\n:::\n\n```{.r .cell-code}\nvec[3] <- 5 # インデックス3の数値を5に置き換える\nvec # 3番めが2から5に置き換わる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3 5 1\n```\n:::\n\n```{.r .cell-code}\nvec[4] <- \"dog\" # インデックス4の数値を\"dog\"（文字列）に置き換える\nvec # ベクターはすべて文字列になる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"4\"   \"3\"   \"5\"   \"dog\"\n```\n:::\n:::\n\n\n#### ベクターの要素を取り除く\n\nベクターの要素を取り除くときには，**ベクターのインデックスをマイナス**で指定します．マイナスのインデックスで指定した要素は取り除かれ，ベクターの長さが短くなります．\n\n\n::: {.cell filename='ベクターの要素を取り除く'}\n\n```{.r .cell-code}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"4\"   \"3\"   \"5\"   \"dog\"\n```\n:::\n\n```{.r .cell-code}\nvec[-3] # インデックス3の要素（5）を取り除く\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"4\"   \"3\"   \"dog\"\n```\n:::\n:::\n\n\n#### ベクターの演算\n\nベクターは，そのまま演算に用いることができます．数値のベクターに数値を足せば，ベクターのすべての要素に数値が足されます．文字列のベクターにpaste関数で文字を継ぎ足せば，すべての要素に文字が継ぎ足されます．\n\n\n::: {.cell filename='ベクターを演算に用いる'}\n\n```{.r .cell-code}\nvec_n # 数値のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nvec_n + 5 # 数値のベクターに5を足すと，すべての要素に5が足される\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 7 8 9\n```\n:::\n\n```{.r .cell-code}\nvec_c # 文字のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"   \"cat\"   \"pig\"   \"horse\"\n```\n:::\n\n```{.r .cell-code}\npaste(vec_c, \"is animal.\") # 文字のベクターにpaste関数で文字をつなぎ合わせる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog is animal.\"   \"cat is animal.\"   \"pig is animal.\"   \"horse is animal.\"\n```\n:::\n:::\n\n\nベクターについては別の章でさらに詳しく説明します．\n\n### リスト（list）\n\n統計の計算をしていると，複数の計算結果をまとめて取り扱いたい，という場合があります．ベクターは1次元のオブジェクトで，かつすべての要素のデータ型が同じですので，ベクターでは型や長さの違う，様々な結果を一度に取り扱うことはできません．このような，型の違うデータを一度に取り扱うときに用いられるのが，<font color=\"red\">**リスト（list）**</font>と呼ばれるオブジェクトです．リストは，様々なオブジェクトをまとめて一つにしたようなデータ構造を持ちます．リストを作成するときには，<font color=\"red\">**list関数**</font>を用います．\n\n\n::: {.cell filename='リスト（list）の作成'}\n\n```{.r .cell-code}\nvec1 <- c(1, 2, 3, 4) # 数値のベクター\nvec2 <- c(\"dog\", \"cat\", \"pig\", \"horse\") # 文字列のベクター\nnum <- 10 # 数値\nchar_temp <- \"Hello world\" # 文字列\n\nlist_temp <- list(vec1, vec2, num, char_temp) # 色々な要素をリストにまとめる\nlist_temp # まとめたリストを表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4\n\n[[2]]\n[1] \"dog\"   \"cat\"   \"pig\"   \"horse\"\n\n[[3]]\n[1] 10\n\n[[4]]\n[1] \"Hello world\"\n```\n:::\n:::\n\n\n#### リストの要素を取り出す\n\nリストの要素を取り出す場合には，ベクターと同様にインデックスを用います．ただし，リストのインデックスは多層化，ネストされているため，呼び出しはやや複雑です．リストの要素を取り出すときには，四角カッコを2重にして用います（**\\[\\[\\]\\]**）．\\[\\[1\\]\\]で呼び出すと，リストの1番目の要素を呼び出すことになります．ベクターと同様に**\\[1\\]で呼び出すと，リストの1番目の要素を，リストとして呼び出す**ことになり，要素までたどり着けなくなります．\n\n\n::: {.cell filename='リストの要素を取り出す'}\n\n```{.r .cell-code}\nlist_temp[[1]] # リストの1番目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nlist_temp[[2]] # 2番目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"   \"cat\"   \"pig\"   \"horse\"\n```\n:::\n\n```{.r .cell-code}\nlist_temp[1] # リストの1番目の要素を，リストとして取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nlist_temp[[1]][1] # リストの1番目の要素（ベクター）の，1番目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nリストについても，別の章で詳しく説明します．\n\n### データフレーム（data.frame）\n\n<font color=\"red\">**データフレーム（data.frame）**</font>はExcelの表のように，行と列を持ち，長方形の形に整形された表型のオブジェクトです．データフレームはExcelの表のように取り扱うことができです．\n\nデータフレームは**縦方向（列）に同じデータ型**を持つ，ベクターの集合になっています．データフレームは横方向（行）には異なる型を持つことができますが，縦方向（列）は必ず同じ型を持つ必要があります．ベクターと同じように，**数値の列の1つのデータを文字列に置き換えると，その列のデータが全て文字列に変換される**という特徴があります．\n\n> データフレームは同じ長さの縦ベクターをリストにして，横に並べたものです．ですので，縦（列）はベクターとして同じ型を持ちます．データフレームはリストでもあるので，リストと同じように取り扱うこともできます．\n\nデータフレームは<font color=\"red\">**data.frame関数**</font>を用いて作ることができます．データフレームを作成するときには，**「列名」=「列の要素」**というものをカッコの中に書きます．\n\n\n::: {.cell filename='データフレームの作成'}\n\n```{.r .cell-code}\nd <- data.frame( # データフレームを作成する（各列を同じ長さにする）\n  number = c(1, 2, 3, 4), # 1列目は数値\n  animal = c(\"dog\", \"cat\", \"pig\", \"horse\"), # 2列目と3列目は動物と果物\n  fruits = c(\"apple\", \"orange\", \"banana\", \"grape\")\n)\n\nd # データフレームの表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n1      1    dog  apple\n2      2    cat orange\n3      3    pig banana\n4      4  horse  grape\n```\n:::\n:::\n\n\n#### データフレームの次元（dimension）と行数・列数\n\nデータフレームには，<font color=\"red\">**次元（dimension）**</font>という性質（アトリビュート，attribute）があります．この次元とは，行の数，列の数のことです．次元を取得する時には，<font color=\"red\">**dim関数**</font>を用います．また，行の数，列の数はそれぞれ<font color=\"red\">**nrow関数**</font>，<font color=\"red\">**ncol関数**</font>で取得することができます．\n\n\n::: {.cell filename='データフレームの次元を取得する'}\n\n```{.r .cell-code}\ndim(d) # 次元の取得（前が行の数，後ろが列の数）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3\n```\n:::\n\n```{.r .cell-code}\nnrow(d) # 行の数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nncol(d) # 列の数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n#### データフレームのインデックス\n\nデータフレームにも，インデックスで要素を取り出すことができます．データフレームのインデックスは，<font color=\"red\">**\\[行, 列\\]**</font>という形で指定します．行も列も，1行目・1列目のインデックスが1となります．\n\nデータフレームでは，行だけ，列だけをインデックスとして指定することもできます．**行だけをインデックスとして指定した時（\\[行, \\]の形で指定）には，その行がデータフレームとして取り出されます**．一方，列だけを指定した時（\\[, 列\\]の形で指定）には，その列がベクターとして取り出されます．データフレームを行と列で取り出した場合には異なるものが取り出されるので，特にデータフレームの行を取り出す際には注意が必要です．\n\n\n::: {.cell filename='データフレームの要素を取り出す'}\n\n```{.r .cell-code}\nd[2, 3] # 2行3列目のデータを取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"orange\"\n```\n:::\n\n```{.r .cell-code}\nd[2, ] # 2行目を取り出す（データフレーム）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n2      2    cat orange\n```\n:::\n\n```{.r .cell-code}\nd[, 3] # 3列目を取り出す（ベクター）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"  \"orange\" \"banana\" \"grape\" \n```\n:::\n:::\n\n\nデータフレームの列は，列の名前を用いても取り出すことができます．列を取り出すときには，**\\$（ドルマーク）に列名**を繋げて記述します．\n\n\n::: {.cell filename='列を列名で呼び出す'}\n\n```{.r .cell-code}\nd$number # 1列目の列名はnumber\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nd$animal # 2列目の列名はanimal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"   \"cat\"   \"pig\"   \"horse\"\n```\n:::\n\n```{.r .cell-code}\nd$fruits # 3列目の列名はfruits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"  \"orange\" \"banana\" \"grape\" \n```\n:::\n:::\n\n\n#### データフレームの要素の置き換え\n\nデータフレームの要素の置き換えは，ベクターと同じように，置き換えたい場所のインデックスを指定して，値を代入する形で行います．この時，その置き換える列の型と代入するデータの型が異なると，列の型がすべて置き換わることがあるので注意が必要です．\n\n\n::: {.cell filename='データフレームの要素を置き換える'}\n\n```{.r .cell-code}\nd[2, 3] <- \"peach\" # 2行3列目の要素をpeachに置き換える\nd # 2行3列目がpeachに置き換わる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n1      1    dog  apple\n2      2    cat  peach\n3      3    pig banana\n4      4  horse  grape\n```\n:::\n\n```{.r .cell-code}\nd[2, 1] <- \"tomato\" # 2行1列目をtomato（文字列）に置き換える\nd # 2行1列目がtomatoに置き換わる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n1      1    dog  apple\n2 tomato    cat  peach\n3      3    pig banana\n4      4  horse  grape\n```\n:::\n\n```{.r .cell-code}\nmode(d[, 1]) # 1列目が文字列に置き換わる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n#### データフレームの行・列の削除\n\nデータフレームの行や列を削除するには，ベクターと同じように，インデックスをマイナスで与えます．インデックスをマイナスにすることで，そのインデックスの行・列を取り除くことができます．ただし，データフレームの1つの要素だけを削除することはできません（指定した行・列がまるごと削除されます）．1つの要素だけを取り除く場合には，その要素のインデックスに対してNAを代入するとよいでしょう．\n\n\n::: {.cell filename='データフレームの行・列を削除する'}\n\n```{.r .cell-code}\nd # 元々のデータフレームは4行3列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n1      1    dog  apple\n2 tomato    cat  peach\n3      3    pig banana\n4      4  horse  grape\n```\n:::\n\n```{.r .cell-code}\nd[-1, ] # 1行目を削除\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal fruits\n2 tomato    cat  peach\n3      3    pig banana\n4      4  horse  grape\n```\n:::\n\n```{.r .cell-code}\nd[, -1] # 1列目を削除\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  animal fruits\n1    dog  apple\n2    cat  peach\n3    pig banana\n4  horse  grape\n```\n:::\n\n```{.r .cell-code}\nd[-2, -3] # 2列目と3列目を削除\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  number animal\n1      1    dog\n3      3    pig\n4      4  horse\n```\n:::\n\n```{.r .cell-code}\nd[2, 3] <- NA # 1要素だけを取り除くときは，NAを代入する\n```\n:::\n\n\n### 行列（matrix）\n\n行列（matrix）は，線形代数（高校数学での行列計算）に用いるものです．行列は基本的には一つの型の要素からなる，行と列のあるオブジェクトです．行列はデータフレームとよく似ていますが，データフレームが列方向のベクターのリストであるのに対し，行列は次元（dimension）を持つベクターに近いものとなります．\n\nRで行列を作成するときには，matrix関数を用います．matrix関数では，カッコの中に，ベクター，行数，列数を指定する数値を与えます．\n\n\n::: {.cell filename='行列を作成する'}\n\n```{.r .cell-code}\n# 2行3列の行列\nmat <- matrix(c(1,2,3,4,5,6), nrow=2, ncol=3) # nrowは行数，ncolは列数\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\n\n#### 行列の次元とインデックス\n\n行列の次元とインデックスに関しては，データフレームとほぼ同じです．行列の列にも名前をつけることができます．従って，列を取り出すときに列名を利用することもできます．取り出したものはいずれもベクターになります．要素・行・列の削除もデータフレームと同じ方法で行います．\n\n\n::: {.cell filename='行列の要素の取り出し'}\n\n```{.r .cell-code}\nmat[1, 1] # 1行1列目の要素\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmat[1, ] # 1行目の要素（ベクター）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\n```\n:::\n\n```{.r .cell-code}\nmat[, 1] # 1列目の要素（ベクター）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\ndim(mat) # matのdimensionを表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nnrow(mat) # matの行数を表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nncol(mat) # matの列数を表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n#### 行列の演算\n\nデータフレームとは異なり，数値の行列は演算に用いることができます．行列（線形代数）の計算のために，行列積，外積，クロネッカー積に対応する演算子が準備されています．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表4：Rで使える行列の演算子</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 行列の演算子 </th>\n   <th style=\"text-align:left;\"> 演算子の意味 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> %*% </td>\n   <td style=\"text-align:left;\"> 行列の積 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> %o% </td>\n   <td style=\"text-align:left;\"> 外積 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> %x% </td>\n   <td style=\"text-align:left;\"> クロネッカー積 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell filename='行列の演算'}\n\n```{.r .cell-code}\nmat2 <- matrix(c(1, 2, 3, 4, 5, 6), nrow=3, ncol=2)\n\nmat %*% mat2 # 行列の積\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   22   49\n[2,]   28   64\n```\n:::\n\n```{.r .cell-code}\nmat %o% mat2 # 外積\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1, 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2, 1\n\n     [,1] [,2] [,3]\n[1,]    2    6   10\n[2,]    4    8   12\n\n, , 3, 1\n\n     [,1] [,2] [,3]\n[1,]    3    9   15\n[2,]    6   12   18\n\n, , 1, 2\n\n     [,1] [,2] [,3]\n[1,]    4   12   20\n[2,]    8   16   24\n\n, , 2, 2\n\n     [,1] [,2] [,3]\n[1,]    5   15   25\n[2,]   10   20   30\n\n, , 3, 2\n\n     [,1] [,2] [,3]\n[1,]    6   18   30\n[2,]   12   24   36\n```\n:::\n\n```{.r .cell-code}\nmat %x% mat2 # クロネッカー積\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    4    3   12    5   20\n[2,]    2    5    6   15   10   25\n[3,]    3    6    9   18   15   30\n[4,]    2    8    4   16    6   24\n[5,]    4   10    8   20   12   30\n[6,]    6   12   12   24   18   36\n```\n:::\n:::\n\n\n#### 3次元以上のオブジェクト：array\n\n行列はベクターに次元を2つ（行と列）与えたものですが，3次元以上の次元を与えることもできます．このような3次元以上のデータを取り扱う場合には，arrayというオブジェクトを使用します．arrayはarray関数で作成することができ，各次元の数（行数，列数に当たるもの）をベクターで与えます．統計やデータ解析で3次元以上のデータを取り扱うことはまれです．\n\n\n::: {.cell filename='arrayを作成する'}\n\n```{.r .cell-code}\narray(c(1, 2, 3, 4, 5, 6, 7, 8), dim = c(2, 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n:::\n:::\n\n\n### その他のオブジェクト\n\nRに基本的に備わっているオブジェクトとして，ベクター，リスト，データフレーム，行列の他に，**時系列（time series，ts）**というオブジェクトがあります．時系列とは，例えば株価や為替相場の時間変化のような，時間とともに定期的に記録されたデータのことを指します．時系列はクラスとして設定されており，中身はベクターです．\n\n\n::: {.cell filename='時系列データ（ts）'}\n\n```{.r .cell-code}\nco2[1:10] # 1959年からのCO2濃度の推移\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 315.42 316.31 316.50 317.56 318.13 318.00 316.39 314.65 313.68 313.18\n```\n:::\n\n```{.r .cell-code}\nclass(co2) # クラスはts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ts\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(co2) # 型はdouble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n:::\n\n\n## 関数\n\nここまでに，mode関数，typeof関数，class関数，c関数，list関数など，様々な関数を用いて，オブジェクトの型やクラスを調べたり，ベクターやリストなどを作成してきました．R言語の<font color=\"red\">**関数**</font>とは，**オブジェクトに一定の演算を加えて，結果を表示するオブジェクト**のことを指します．関数のクラスはfunction（関数），型もfunctionです．\n\n\n::: {.cell filename='オブジェクトとしての関数'}\n\n```{.r .cell-code}\nclass(typeof) # 関数のクラスはfunction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nmode(typeof) # 関数の型もfunction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n\nRでの関数は，<font color=\"red\">**引数**</font>と呼ばれる，カッコの中に記載されたオブジェクトに対して，一定の演算を加えるものです．Excelの関数をイメージしていただければ理解しやすいと思います．関数のイメージを図にすると，以下のようになります．\n\n![図4：関数のイメージ図](./image/function_image.png)\n\nRには<font color=\"red\">**mean関数**</font>という，ベクターの中の数値の平均値を表示してくれる関数があります．上の図では，ベクターである，c(5, 10, 15)を引数として与えると，mean関数は引数を読み取って平均値を計算し，平均値である10を表示してくれます．この，表示される関数の計算結果のことを，<font color=\"red\">**返り値**</font>と呼びます．\n\n\n::: {.cell filename='関数，引数と返り値'}\n\n```{.r .cell-code}\nvec <- c(5, 10, 15) # 引数とするベクター\nmean(vec) # mean関数に引数vecを与えると，10が返り値として返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nRには，上記の関数以外にも，数値や文字列，データフレームを演算するための関数を数多く備えています．\n\n\n::: {.cell filename='代表的な関数と，関数としての演算子'}\n\n```{.r .cell-code}\nsd(vec) # 標準偏差を計算する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmedian(vec) # 中央値を計算する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nlog10(vec) # 常用対数を計算する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.698970 1.000000 1.176091\n```\n:::\n\n```{.r .cell-code}\nexp(vec) # ネイピア数の指数を計算する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]     148.4132   22026.4658 3269017.3725\n```\n:::\n\n```{.r .cell-code}\nmode(`+`) # 演算子の+の型はfunction（関数）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\n`+`(2, 3) # 関数なので，引数を2つ取ると足し算になる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmode(`[`) # インデックスも関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nmode(`if`) # if（条件分岐）も関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nmode(`for`) # for（繰り返し文）も関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n\n> Rでは，演算子やインデックス指定，条件分岐，繰り返し文も関数です．\n\nこのように，Rでは多くの演算を関数によって処理しています．この性質から，Rは**関数型言語**であるとされています．\n\n> 正確には，Rは厳密な意味では関数型言語ではないように思います．関数型言語には[Haskell](https://www.haskell.org/)などがありますが，関数型言語では再帰的関数（関数内で関数を呼び出す）ような処理を用いて繰り返し計算を避けるようなものが多いです．Rでも再帰的関数を用いることはできますが，頻繁には使用されません．\n\n### 関数を自作する\n\nどのようなプログラミング言語にも，関数を自作する方法が備わっています．Rでは，<font color=\"red\">**function文**</font>を用いて関数を自作することができます．関数を変数に代入して用いるのが一般的な関数の作成方法です．function文の書き方は以下の通りです．\n\n**関数名 \\<- function(引数群){引数を使った処理}**\n\n関数の返り値は，**return関数**を使って明示することもできますが，単に最後に記載したオブジェクトを返り値とすることもできます．\n\nまた，Rではfunctionと書く代わりに，\\\\（＼，バックスラッシュ）をfunctionの代わりに用いることもできます．\n\n作成した関数を用いて演算するときには，「関数名(引数)」という形で表記します．これはmode関数やclass関数の使い方と同じです．\n\n\n::: {.cell filename='関数を自作する'}\n\n```{.r .cell-code}\n# 引数をそのまま帰す関数\nreturn_selfx <- function(x){return(x)} # 返り値をreturn関数で表示\nreturn_selfy <- function(y){y} # 最後に返り値を書く\nreturn_selfz <- \\(z){z} # functionの代わりにバックスラッシュを用いる\n\n# どれも同じ演算をする関数になる\nreturn_selfx(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nreturn_selfy(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nreturn_selfz(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n実際に関数を作るときには，もう少し複雑な処理を{}（中かっこ）の中に書きます．処理は一つ一つ改行しながら書き，最後に返り値を書きます．中かっこの中で改行を行っても問題ありませんが，かっこの前側（{）は，引数のかっこ（「)」）の後に記載されている必要があります．\n\n\n::: {.cell filename='関数内の処理の書き方'}\n\n```{.r .cell-code}\n# sum2関数を作成する\nsum2 <- function(x, y, z){ # 引数はx，y，zの3つ\n  sum_of_xyz <- x + y + z # 引数を足し算する\n  sum_of_xyz # 足し算したものを返り値にする\n}\n\nsum2(x = 1, y = 2, z = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n上の例のように，引数を指定するときには，引数の種類を明示的に記載することもできます．明示的に記載する場合には，**「引数名=値」**という形で書きます．引数名を省略した場合には，記載した引数の順番に従って，引数が用いられます．\n\n関数を作成するときには，**引数のデフォルト値**を設定しておくこともできます．デフォルト値が設定されている関数では，その引数を入力しなかったときには，自動的に引数にデフォルト値が入ります．\n\n\n::: {.cell filename='引数のデフォルト値と省略'}\n\n```{.r .cell-code}\nsum3 <- function(x, y = 1){ # yのデフォルト値を1とする\n  return(x + y)\n}\n\nsum3(x = 1, y= 2) # 引数を明示的に記載\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nsum3(1, 2) # xに1，yに2が入る\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nsum3(1) # 引数yが省略されているので，デフォルト値（1）が用いられる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nsum3(y=1) # xはデフォルトが設定されていないので，省略できない\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sum3(y = 1): argument \"x\" is missing, with no default\n```\n:::\n:::\n\n\n## 型・クラスの確認と変換\n\n### 型・クラスの確認：is.関数群\n\nRでは，型やクラスを確認するための関数として，typeof関数・mode関数・class関数以外に，<font color=\"red\">**is.関数**</font>というものを備えています．is.関数を用いると，オブジェクトの型が，ある型と一致しているかどうかを確認することができます．引数が数値であるかどうかは，<font color=\"red\">**is.numeric関数，is.integer関数，is.double関数**</font>を用いて確認することができます．例えば**is.numeric(1)はTRUE**を返し，**is.numeric(\"dog\")**はFALSEを返します．このis.関数には，文字列やNA，NaN等を確認する関数もあります．is.関数を以下の表に示します．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表2：xの型の確認に用いる関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> is.関数名 </th>\n   <th style=\"text-align:left;\"> チェックする型 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> is.numeric(x) </td>\n   <td style=\"text-align:left;\"> 数値型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.integer(x) </td>\n   <td style=\"text-align:left;\"> 整数型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.double(x) </td>\n   <td style=\"text-align:left;\"> double型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.complex </td>\n   <td style=\"text-align:left;\"> 複素数型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.character(x) </td>\n   <td style=\"text-align:left;\"> 文字列型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.logical(x) </td>\n   <td style=\"text-align:left;\"> 真偽型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.factor(x) </td>\n   <td style=\"text-align:left;\"> 因子型 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.atomic(x) </td>\n   <td style=\"text-align:left;\"> ベクター </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.list(x) </td>\n   <td style=\"text-align:left;\"> リスト </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.matrix(x) </td>\n   <td style=\"text-align:left;\"> マトリックス </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.data.frame(x) </td>\n   <td style=\"text-align:left;\"> データフレーム </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.na(x) </td>\n   <td style=\"text-align:left;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.nan(x) </td>\n   <td style=\"text-align:left;\"> NaN </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.null(x) </td>\n   <td style=\"text-align:left;\"> NULL </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> is.infinite(x) </td>\n   <td style=\"text-align:left;\"> 無限大 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nis.関数の中では，<font color=\"red\">**is.na関数**</font>の使用頻度が高いです．is.na関数を用いると，ベクターやデータフレームからNAを含む要素をうまく取り除くことができます．\n\n\n::: {.cell filename='is.関数群'}\n\n```{.r .cell-code}\nc(is.numeric(1), is.numeric(\"1\")) # 文字列（\"1\"）は数値ではない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.integer(1L), is.integer(1)) # Lが付いていないとdoubleになる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.double(1), is.double(1L)) # Lが付いているとintegerになる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.complex(1+1i), is.complex(1+1)) # iがあると複素数になる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.character(\"dog\"), is.character(1)) # 数値は文字列ではない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# 0はFALSE扱いされるが，logicalではない\nc(is.logical(T), is.logical(0), is.logical(\"dog\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.factor(factor(1)), is.factor(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.atomic(1), is.atomic(list(1))) # ベクターはTRUE，リストはFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.vector(1), is.vector(list(1))) # is.vectorもあるが，リストもTRUEになる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\nc(is.list(list(1)), is.list(1))# ベクターはFALSE，リストはTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.matrix(matrix(1, ncol=1)), is.matrix(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nc(is.data.frame(data.frame(1)), is.data.frame(list(1))) # リストはFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# NAとNaNはNA扱い，NULLは無いもの扱い\nc(is.na(NA), is.na(1), is.na(NaN), is.na(Inf), is.na(NULL)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# NULLは無いもの扱い\nc(is.nan(NA), is.nan(1), is.nan(NaN), is.nan(Inf), is.nan(NULL))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# NULLを評価する\nc(is.null(NA), is.null(1), is.null(NaN), is.null(Inf), is.null(NULL)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n# NULLは無いもの扱い\nc(is.infinite(NA), is.infinite(1), is.infinite(NaN), is.infinite(Inf), is.infinite(NULL)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\n> ベクターはis.atomic関数で評価します．これは，ベクターのことをatomic vectorと呼ぶためです．atomic vectorはvectorと同じ意味を持ちます．エラーには時々このatomic vectorという表記が出てきますが，これは通常のベクターのことを述べているだけで，atomic vectorという特別なものがあるわけではありません．\n\n### 型・クラスの変換：as.関数群\n\nis.関数はデータのクラスや型をチェックし，真偽値を返す関数です．Rには，関数名がよく似た<font color=\"red\">**as.関数**</font>があります．**as.関数**は，引数の型を指定した型に変換する関数です．例えば，<font color=\"red\">**as.numeric関数**</font>は引数をnumericに変換する関数です．as.関数を以下の表に示します．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表3：xの型の変換に用いる関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> as.関数名 </th>\n   <th style=\"text-align:left;\"> 変換する型 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> as.numeric(x) </td>\n   <td style=\"text-align:left;\"> 数値型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.integer(x) </td>\n   <td style=\"text-align:left;\"> 整数型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.double(x) </td>\n   <td style=\"text-align:left;\"> double型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.complex </td>\n   <td style=\"text-align:left;\"> 複素数型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.character(x) </td>\n   <td style=\"text-align:left;\"> 文字列型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.logical(x) </td>\n   <td style=\"text-align:left;\"> 真偽型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.factor(x) </td>\n   <td style=\"text-align:left;\"> 因子型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.Date </td>\n   <td style=\"text-align:left;\"> 日時型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.POSIXct </td>\n   <td style=\"text-align:left;\"> POSIXct型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.POSIXlt </td>\n   <td style=\"text-align:left;\"> POSIXlt型に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.list(x) </td>\n   <td style=\"text-align:left;\"> リストに変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.matrix(x) </td>\n   <td style=\"text-align:left;\"> マトリックスに変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.data.frame(x) </td>\n   <td style=\"text-align:left;\"> データフレームに変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> as.null(x) </td>\n   <td style=\"text-align:left;\"> NULLに変換 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell filename='as.関数群'}\n\n```{.r .cell-code}\nas.numeric(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.integer(1.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.double(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.complex(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1+0i\n```\n:::\n\n```{.r .cell-code}\nas.character(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"\n```\n:::\n\n```{.r .cell-code}\nc(as.logical(1), as.logical(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nas.factor(c(\"dog\", \"cat\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] dog cat\nLevels: cat dog\n```\n:::\n\n```{.r .cell-code}\nas.Date(\"2022-02-22\") # わかりにくいが，日付型になっている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-02-22\"\n```\n:::\n\n```{.r .cell-code}\n# わかりにくいが，日時型になっている\nas.POSIXct(\"2022-02-22 15:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-02-22 15:00:00 JST\"\n```\n:::\n\n```{.r .cell-code}\nas.POSIXlt(\"2022-02-22 15:00:00\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-02-22 15:00:00 JST\"\n```\n:::\n\n```{.r .cell-code}\nas.list(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nas.data.frame(list(1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  X1 X1.1\n1  1    1\n```\n:::\n\n```{.r .cell-code}\nas.matrix(data.frame(x=1, y=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x y\n[1,] 1 1\n```\n:::\n\n```{.r .cell-code}\nas.null(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n> as.関数群は変換できない場合にNAを返すときがありますので，注意が必要です．as.関数はそれほど使用頻度は高くありませんが，行列をデータフレームに変換するときなどに使用することがあります．\n\n## 予約語\n\n上の例では関数や変数には名前をつけていますが，関数名や変数名の付け方にはルールがあります．\n\n-   名前の始めに数値（1，2など）をつけることはできない\n-   名前の始めにアンダーバー（\\_）を用いることはできない\n-   大文字と小文字は区別される（SUMとsumは別扱い）\n-   演算子や記号（!や?，+，-，# など）は使えない\n-   **予約語**を用いることはできない\n\n<font color=\"red\">**予約語（reserved word）**</font>とは，R言語がすでに役割を与えているために，関数名や変数名には使用できない文字列です．Rで設定されている予約語は以下の通りです．\n\n-   if\n-   else\n-   repeat\n-   while\n-   function\\\n-   for\n-   in\n-   next\n-   break\n-   TRUE\n-   FALSE\n-   NULL\n-   Inf\n-   NaN\n-   NA\n-   NA_integer\\_\n-   NA_real\\_\n-   NA_complex\\_\n-   NA_character\\_\n-   ...\n-   ..1\n-   ..2\n\n> Rでは，ピリオド（.）が予約語に含まれていないため，変数名にピリオドを利用することができます．ただし，他の言語ではこのピリオドをメソッド（method）という，関数の仲間のようなものに用いることが多く，勘違いを起こしやすい表記になります．Rでも変数名にピリオドを用いないほうがよいとされています．\n",
    "supporting": [
      "chapter3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}