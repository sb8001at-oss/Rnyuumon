{
  "hash": "e9821fa63a61d8d278dfc14bb3d1bd3b",
  "result": {
    "markdown": "# エラー処理（error handler）\n\nRでプログラミングを行うと，大体エラーが発生します．プログラミングにエラーはつきものです．プログラミングの途中でエラーが起こっても，それが本当に重大な影響を及ぼすことはほとんどありません．\n\nRは基本的にad hocな（その場一度限りの）統計処理に用いることを前提としているようなところがあるため．エラーが出たらスクリプトを書き換えて，もう一回実行すればよい，という場合が多いです．\n\nしかし，通常のプログラミング言語と同様に，エラーが出たら困る，エラーが出た場合は特殊な処理をしたい，という場合もあります．このような場合に用いられるものが，<font color=\"red\">**エラー処理（error handler）**</font>です．\n\n> Rubyなどの汎用プログラミング言語ではエラー処理は非常に重要ですが，Rではそれほど使用頻度は高くありません．エラー処理を今すぐ使いたいという方以外は，この章を飛ばしても問題ありません．\n\n## エラーの分類\n\nRではエラーとして3種類の警告が出る仕組みを持っています．3種類とは，<font color=\"red\">**message，warning，error**</font>の3つです．**message**はプログラムを実行しても特に問題はないが，特別に伝えたいことがある場合に，**warning**はプログラムを実行したときに，問題が起こっている可能性が高い場合に，**error**は実行できない場合にそれぞれ表示されます．\n\nこれらのうち，messageはプログラムの実行に影響を与えません．warningはプログラムを実行したときに問題が起こることがあります．errorが起こるとプログラムの実行が止まります．ですので，エラーとして処理が必要となるのは，主にwarningとerrorです．\n\n\n::: {.cell filename='message, warning, errorの表示'}\n\n```{.r .cell-code}\n# messageが出る場合\nreadr::read_tsv(\"iris.txt\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: 'iris.txt' does not exist in current working directory ('C:/Users/araya-t/OneDrive - 共和薬品工業株式会社/R_scripts/R入門').\n```\n:::\n\n```{.r .cell-code}\n# warning（警告）が出る場合\ntibble::as.tibble(iris[1,])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\ni Please use `as_tibble()` instead.\ni The signature and semantics have changed, see `?as_tibble`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n         <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n1          5.1         3.5          1.4         0.2 setosa \n```\n:::\n\n```{.r .cell-code}\n# error（エラー）が出る場合\n100 + dog\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'dog' not found\n```\n:::\n:::\n\n\n## エラーを表示させる\n\n自分が作ったプログラムや関数を他人が使う場合，計算に問題があるときにはエラーメッセージを出したい時があります．また，errorやwarningが起きたときには特別な処理を行いたいこともあります．このような場合のために，Rにはエラーを表示させるための関数があります．message，warning，errorを表示させるための関数は，それぞれ**message関数，warning関数，stop関数**です．stop関数はその名の通り，エラーが表示された後でプログラムの実行が止まります．エラーは**stopifnot関数**でも表示させることができます．stopifnot関数は引数に条件式を取り，**条件式がFALSEのとき**にエラーを表示します．\n\n\n::: {.cell filename='エラーを表示させる関数'}\n\n```{.r .cell-code}\nmessage(\"これはメッセージです．実行に問題はありません\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nこれはメッセージです．実行に問題はありません\n```\n:::\n\n```{.r .cell-code}\nwarning(\"これはwarning（警告）です．実行に問題があるかもしれません\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: これはwarning（警告）です．実行に問題があるかもしれません\n```\n:::\n\n```{.r .cell-code}\nstop(\"これはerrorです．実行を止めます．\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): これはerrorです．実行を止めます．\n```\n:::\n\n```{.r .cell-code}\nstopifnot(FALSE) # 条件がFALSEだとエラーが出る\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: FALSE is not TRUE\n```\n:::\n\n```{.r .cell-code}\nstopifnot(\"エラーメッセージはこのように設定する\" = FALSE) # =の後に条件式を書く\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: エラーメッセージはこのように設定する\n```\n:::\n:::\n\n\n## tryとtryCatch\n\nRでのエラー処理には，**try関数とtryCatch関数**の2つが用いられます．try関数はエラーが出る処理を行った場合に，プログラムを止めずにエラーを返す機能を持ちます．tryCatch関数はエラーが出る処理に対応して別の処理を行う際に用います．\n\n**try関数**は第一引数を評価し，エラーならエラーを表示し，続けてプログラムを実行します．下のfor文では，どちらも\"dog\"に数値を足す計算でエラーが出ます．tryがない場合にはエラーが出た時点でプログラムが停止しますが，try関数の引数にエラーが出る処理がある場合にはエラーが出た後にも計算が継続します．tryは返り値として第一引数の演算結果を返しますが，エラーが出た場合にはtry-errorクラスのオブジェクトを返します．\n\n\n::: {.cell filename='try関数とエラー'}\n\n```{.r .cell-code}\nd <- data.frame(a=1, b=2, c=\"dog\", d=4, e=5)\nd # 1行5列のデータフレーム\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b   c d e\n1 1 2 dog 4 5\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:5){ # エラーが出るので，評価が中断する\n  print(d[1,i] + 1)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 3\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in d[1, i] + 1: non-numeric argument to binary operator\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:5){ # エラーが出ても，評価は継続する\n  try(print(d[1,i] + 1))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 3\nError in d[1, i] + 1 : non-numeric argument to binary operator\n[1] 5\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nerr_ <- try(1+\"dog\") # エラーが出たとき\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in 1 + \"dog\" : non-numeric argument to binary operator\n```\n:::\n\n```{.r .cell-code}\nclass(err_) # エラーのクラス（try-error）を返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"try-error\"\n```\n:::\n\n```{.r .cell-code}\nwarning_ <- try(as.numeric(\"dog\")) # warningが出たとき\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in doTryCatch(return(expr), name, parentenv, handler): NAs introduced\nby coercion\n```\n:::\n\n```{.r .cell-code}\nclass(warning_) # 演算はできるので，演算結果（NA）が返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n> 返り値のNA（try(as.numeric(\"dog\")) の結果）のクラスがnumericになっています．NAは内部的にはNA_integer\\_（整数のNA），NA_real\\_（実数のNA），NA_complex\\_（複素数のNA），NA_character\\_（文字列のNA）の4種類として扱われており，上記の場合ではNA_real\\_，つまり実数タイプのNAが返ってきています．このようにNAには型が複数あるため，ベクター中にNAが埋め込まれていても，ベクター全体の型が変化することはありません．\n\ntry関数では，エラーが出たときにはtry-errorクラスが返ってくるので，try-errorクラスであることを利用してエラー時に行う処理を設定することができます．また，引数に「silent = TRUE」を取ると，エラーメッセージが表示されなくなります．\n\n\n::: {.cell filename='try-errorクラスを用いたエラー処理'}\n\n```{.r .cell-code}\n# tryの結果のクラスがtry-errorなら，文字列を返すif文\nif(class(try(1+\"dog\"))==\"try-error\"){\"エラーが起きています．\"}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in 1 + \"dog\" : non-numeric argument to binary operator\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"エラーが起きています．\"\n```\n:::\n\n```{.r .cell-code}\ntry(1+\"dog\", silent=T) # 何も表示されない\n```\n:::\n\n\ntry関数でもエラー処理はできますが，通常エラー処理で用いられるのは**tryCatch関数**です．tryCatch関数では，errorが起きたときの処理，warningが起きたときの処理，最終的に行う処理（finally）をそれぞれ設定できます．この時，error，warningの処理は**関数**で，finallyは**そのまま**書きます．warningやerrorに用いる関数は別途作成しておくこともできますが，下のようにtryCatch関数内で関数として定義する形でも書くこともできます．\n\n\n::: {.cell filename=''}\n\n```{.r .cell-code}\nerrorCatcher <- function(x){ # 対数計算のエラーを捉える関数\n  tryCatch(\n    log(x), # 対数計算を評価する\n    warning = \\(w){\"警告あり\"}, # warningが出たときの処理\n    error = \\(e){\"エラーあり\"}, # errorが出たときの処理\n    finally = print(\"エラーがあってもなくても表示される\") # エラーの有無に関わらず行う処理\n  )\n}\n\nerrorCatcher(0) # エラーなし\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"エラーがあってもなくても表示される\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -Inf\n```\n:::\n\n```{.r .cell-code}\nerrorCatcher(-1) # warning\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"エラーがあってもなくても表示される\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"警告あり\"\n```\n:::\n\n```{.r .cell-code}\nerrorCatcher(\"dog\") # error\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"エラーがあってもなくても表示される\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"エラーあり\"\n```\n:::\n:::\n\n\n> warningやerrorで記載している関数（\\\\(e)や\\\\(w)）は名前を決めずに用いる関数で，無名関数と呼ばれるものです．用途によってはこのような無名関数を用いて処理を書くことがあります．\n",
    "supporting": [
      "chapter7_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}