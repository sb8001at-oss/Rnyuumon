{
  "hash": "474b3491b02e1c436e29aa6405351cea",
  "result": {
    "markdown": "# tidyr・dplyr\n\nデータを取得し，そのデータをそのまま統計に用いることができることは稀です．データ解析では，データの整理整頓（data wrangling）に多くの時間が割かれています．データの整理整頓には，様々なツールが用いられます．前述のapply関数群もデータの要約等の整理整頓に用いることができます．\n\nただし，前章で説明した通り，apply関数群は関数ごとに引数の順序や引数に与えるデータ型などが異なっており，使い勝手がよいとは言えません．同様の機能を持つ[plyrパッケージ](https://cran.r-project.org/web/packages/plyr/index.html)というライブラリもありますが，やはり使い勝手が良くなかったため，それほど用いられていません．\n\n現在では，これらの関数・ライブラリに代わり，データの整理整頓には<font color=\"red\">**tidyr・dplyr**</font>を用いるのがRでは事実上のデフォルトとなっています．tidyr・dplyrの特徴は以下の通りです．\n\n- <font color=\"red\">**パイプ演算子**</font>を用いることを前提として関数が設計されている\n- 第一引数にはデータフレームを取り，データフレームを加工する\n- 出力もデータフレーム（正確にはtibble）で統一されている\n\ntidyr・dplyrを用いることで，パイプ演算子を活用し，余計な変数を作ることなく，データフレームを自由自在に取り扱うことができます．\n\n\n::: {.cell}\n\n:::\n\n\n## メソッドチェーン\n\ntidyr・dplyrについて説明する前に，R以外の言語で用いられている，**メソッドチェーン**について簡単に説明します．\n\nR以外の言語では，オブジェクトに対して演算を行う時，関数以外に**メソッド**を利用することがあります．メソッドは，オブジェクトの後にピリオドで繋いで，オブジェクトに何らかの演算を行うものです．例えばRubyでは文字列に対して，「.upcase」というメソッドが設定されています．.upcaseは文字列を大文字にするメソッドです．例えば「\"Hello world\".upcase」とすると，\"Hello world\"の小文字が大文字に変換され，\"HELLO WORLD\"が返ってきます．\n\nこのメソッドは2つ以上繋げて用いることができます．例えば，.reverseは文字列を逆順にするメソッドですが，「\"Hello world\".reverse.upcase」とすると，\"Hello world\"を逆順にし，続いて大文字に変換することができます．このように，メソッドを繋いで使用することをメソッドチェーンと呼びます．\n\n以下に，Rubyとjavascriptでのメソッドチェーンの例を示します．\n\n\n::: {.cell filename='Rubyでのメソッドチェーン'}\n\n```{.ruby .cell-code}\nstring = \"dlrow olleH\"\nstring.reverse.upcase # 文字列を逆順にし，大文字に変換する\n#>  \"HELLO WORLD\"\n```\n:::\n\n::: {.cell filename='JavaScriptでのメソッドチェーン'}\n\n```{.javascript .cell-code}\nvar firstName = \" Rajat \"; // firstNameは\" Rajat \"\nconsole.log(firstName); \n#> \"Rajat\"\nvar modifiedName = \n  firstName \n    .toUpperCase() // 大文字にして\n\t\t.trim(); // 前後のスペースを削除する\nconsole.log(modifiedName)\n#> \"RAJAT\"\n```\n:::\n\n\nメソッドチェーンのよいところは，**演算の過程を左から右へ，文章を読むように追いかけることができる**ことです．上記のメソッドチェーンと同じような演算をRで行うと，以下のようになります．\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse) # stringrを使うためtidyverseをロードする\nfirstname <- \" Rajat \"\n\n# 例1\nstr_to_upper(str_trim(firstname)) # スペースを取り除いて大文字にする\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"RAJAT\"\n```\n:::\n\n```{.r .cell-code}\n# 例2\nfirstname1 <- str_trim(firstname) # スペースを取り除く\nstr_to_upper(firstname1) # 大文字にする\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"RAJAT\"\n```\n:::\n:::\n\n\nRではメソッドチェーンは使えないので，複数の演算を行うときには，上の例1のように関数の中に関数を入れる（ネストする）か，例2のように一時的に計算結果を変数に入れておき，その一時的な変数を利用して再度演算（逐次的な演算）をする必要があります．\n\nどちらも実用上大きな問題ないのですが，プログラムとしては理解しにくく，メソッドチェーンのように簡単に複数の処理を行えるものではありません．\n\nこのような問題を解決する演算子が，<font color=\"red\">**パイプ演算子**</font>です．\n\n## パイプ演算子（pipe operator）\n\nパイプ演算子とは，**「演算子の前のオブジェクトを，演算子の後ろの関数の引数にする」**演算子です．Rのパイプ演算子には以下の2種類があります．\n\n- <font color=\"red\">**\\|\\>**</font>：Rのデフォルトのパイプ演算子\n- <font color=\"red\">**%\\>%**</font>：magrittrパッケージに登録されているパイプ演算子\n\nパイプ演算子を用いると，以下の演算は同じ意味を持ちます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1, 2, 3)\nmean(vec) # 通常の演算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nvec |> mean() # パイプ演算子\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nこれだけ見てもパイプ演算子を用いる利点はよくわかりませんが，パイプ演算子を用いることで，上記のメソッドチェーンのような機能をRに与えることができます．\n\n上のjavascriptでのメソッドチェーンと同じ演算をパイプ演算子を用いて行うと，以下のようになります．パイプ演算子を用いることで，「文字列からスペースを取り除き，大文字にする」という，文章と同じ順序でデータを処理することができます．このように順序が変わることで，一度にたくさんの演算を行っても，理解しやすいプログラムを書くことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirstname <- \" Rajat \"\nfirstname |> str_trim() |> str_to_upper() # スペースを取り除き，大文字にする\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"RAJAT\"\n```\n:::\n:::\n\n\n### デフォルトとmagrittrパッケージのパイプ演算子\n\nでは，まず2種類のパイプ演算子について見ていきましょう．Rで先に実装されたのはmagrittrで，2014年にライブラリが公開されています．Rのデフォルトのパイプ演算子はずっと後になって，2021年にR version 4.1.0で実装されました．\n\nRstudioでは，パイプ演算子を「<font color=\"red\">**Ctrl+Shift+M**</font>」のショートカットで入力することができます．RStudioはRのデフォルトのパイプ演算子が実装される前から存在するため，デフォルトのパイプ演算子はmagrittrの「%\\>%」になっています．デフォルトのパイプ演算子をRのデフォルトのもの（\\|\\>）に変更する場合には，「Tools→Global Options」から「Code」を選択し，下の図1の赤線で囲った部分にチェックを入れます．\n\n![図2：ショートカットで入力するパイプ演算子を変更する](./image/chapter16_pipe_shortcut.png)\n\n2種類のパイプ演算子は，記号が異なるだけでなく，使い方も少し異なっています．\n\n-   関数の後の()の必要性（\\|\\>は必要，%\\>%は不必要）\n-   引数の位置を指定する文字の違い（\\|\\>は「\\_」（アンダースコア），%\\>%は「.」（ピリオド））\n-   関数のreturnに使えるかどうか（\\|\\>は使えず，%\\>%は使える）\n\nまた，%\\>%を用いるのにはmagrittrパッケージ（tidyverseに含まれている）をロードする必要があるのに対し，\\|\\>はライブラリのロードを必要としません．\n\n#### 関数のカッコの有無\n\n\\|\\>では関数名の後にカッコをつけるのが必須で，カッコが無いとエラーが出ます．\n\n\n::: {.cell filename='パイプ演算子'}\n\n```{.r .cell-code}\npacman::p_load(tidyverse) # magrittrはtidyverseに含まれる\n\nfunc1 <- function(x, y = 1){x + y} # xに1を足す関数\n\nfunc1(1) # 2が帰ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n1 |> func1() # |>ではカッコが必須\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 |> func1 # カッコが無いとエラー\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: The pipe operator requires a function call as RHS (<text>:1:6)\n```\n:::\n:::\n\n\n%\\>%では，カッコがあってもなくても計算をしてくれます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 %>% func1() # %>%はカッコがあってもなくても計算できる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n1 %>% func1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n\\|\\>では，パイプ演算子の前の値を代入する位置をアンダースコア（_）で指定できます．%\\>%では，ピリオド（.）で指定します．指定しない場合には，パイプ演算子の前の値が第一引数となります．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc1(1, 2) # 引数を2個取り，足し算する関数\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n1 |> func1(y = 2) # 第一引数に1が入る（第2引数が2）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n2 |> func1(x = 1, y = _) # 引数を入る位置を「_」で指定\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n1 %>% func1(y = 2) # 第一引数に1が入る\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n2 %>% func1(x = 1, y = .) # 引数を入る位置を「.」で指定\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\\|\\>・%\\>%のどちらでも，ピリオドやアンダースコアにインデックス・列名を付け加えることで，要素を呼び出すことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n4:6 |> _[2] # インデックスで呼び出せる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n4:6 %>% .[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\niris |> _$Species |> head() # 列名で呼び出せる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] setosa setosa setosa setosa setosa setosa\nLevels: setosa versicolor virginica\n```\n:::\n\n```{.r .cell-code}\niris %>% .$Species %>% head\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] setosa setosa setosa setosa setosa setosa\nLevels: setosa versicolor virginica\n```\n:::\n:::\n\n\n\\|\\>も%\\>%も共に，演算子の後に改行を入れることができます．パイプ演算子を用いるときには，以下のような書き方をするのが一般的です．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"Hello world\" |> # 文字列を\n  str_replace(pattern = \"world\", replacement = \"R\") |> # 一部置き換え，\n  str_to_upper() # 大文字にする\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HELLO R\"\n```\n:::\n:::\n\n\n## tidy data\n\ntidyr・dplyrの説明の前に，データフレームを取り扱う上で重要な概念である，<font color=\"red\">**「tidy data（整然としたデータ）」**</font>について簡単に説明します．\n\n「[tidy data](https://r4ds.hadley.nz/data-tidy.html)」はggplot2やtidyr，dplyrを開発しているPOSIT SoftwareのチーフサイエンティストであるHadley Wickhamが2014年に示したデータ構造の考え方です．データフレームのような表形式のデータを対象としたもので，**「データの行は各観察結果，データの列は各列が一つの種類のデータであるように整理し，データの各要素には一つの値しか入力しない」**というルールに従い，データは準備されるべきであるとしています．tidyr，dplyrはこの概念を念頭に設計されています．\n\ntidyではないデータは世の中にゴロゴロ転がっています．以下の表1はファイザーの[COVID-19ワクチン（コミナティ筋注）の第3相試験に関するNew England Journal of Medicineの論文](https://www.nejm.org/doi/pdf/10.1056/NEJMoa2034577?articleTools=true)の表1の一部を加工したものです．\n\n![](./image/chapter16_nontidy.png)\n\n論文の表は人が見やすいように作成されています．ですので，この表を見て，意味が全くわからない，ということはあまりないでしょう．しかし，この表はtidyではありません．\n\nまず，1つのセル（要素）に人数とその割合（%）が記載されています．また，投薬された治験薬（BNT162b2とPlacebo）は処置（Treatment）という同じカテゴリのデータですので，列名として2つに分けていることで，同じカテゴリのデータを2列に表示していることになっています．上の2行は性別に関するデータ，下の3行は人種に関するデータですので，2つの別のデータが同じ表に乗っています．したがって，この表は人にとってはわかりやすくても，tidyなデータではありません．\n\n上の表をtidyなデータにしたものが，以下の表2です．人数のデータ，割合のデータは各1列に，治験薬はTreatmentとして1列に表記しています．性別と人種ではデータのカテゴリが異なりますので，表を2つに分けています．Ratioはそのまま変換すると足し合わせが200%となるため，2で割って調整しています．\n\nこれが完全なtidyかと言われるとやや難しいところもありますが，少なくとも上の表1よりはRで取り扱いしやすいデータとなっています．\n\n![](./image/chapter16_tidy.png)\n\nRでは，グラフ作成・統計共に，元の表より下のtidyなデータの方が取り扱いやすくなります．多くのデータは人が見やすいように収集・準備されており，tidyではありません．R上でデータをtidyに加工・整形するためのツールが，<font color=\"red\">**tidyrとdplyr**</font>です．\n\n### tidyr\n\n<font color=\"red\">**tidyr**</font>はデータを<font color=\"red\">**縦持ち・横持ち**</font>に変換するためのライブラリです．この縦持ち・横持ちというのは，以下の図のように，縦長・横長のデータのことを指します．\n\n人が見る分には，横持ちのデータはわかりやすく，理解に特に問題は感じません．しかし，Rで取り扱う場合には，圧倒的に縦持ちのデータの方が取り扱いが簡単です．ですので，人が作ったデータをRで取り扱うために縦持ちに変換する，Rで生成したデータを人が理解しやすいように横持ちに変換する時に，tidyrの関数を用いることになります．以下の表3にtidyrの関数の一覧を示します．\n\n[これ](https://rstudio.github.io/cheatsheets/tidyr.pdf)を参照\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表3：tidyrの関数群</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 適用する演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> pivot_longer </td>\n   <td style=\"text-align:left;\"> データフレームを縦持ちデータにする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> gather </td>\n   <td style=\"text-align:left;\"> データフレームを縦持ちデータにする（旧版） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> pivot_wider </td>\n   <td style=\"text-align:left;\"> データフレームを横持ちデータにする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> spread </td>\n   <td style=\"text-align:left;\"> データフレームを横持ちデータにする（旧版） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> group_by </td>\n   <td style=\"text-align:left;\"> データを列でグループ化する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> nest </td>\n   <td style=\"text-align:left;\"> データをネストする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> unnest </td>\n   <td style=\"text-align:left;\"> ネストを解除する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> drop_na </td>\n   <td style=\"text-align:left;\"> NAを含む行を取り除く（na.omitと同じ） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> expand </td>\n   <td style=\"text-align:left;\"> 各列の組み合わせを作成する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> fill </td>\n   <td style=\"text-align:left;\"> NAに上の要素を埋める </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> replace_na </td>\n   <td style=\"text-align:left;\"> NAに引数で指定した要素を埋める </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### pivot_longerとpivot_wider\n\nデータフレームを縦持ちに変換する関数が<font color=\"red\">**pivot_longer関数**</font>，横持ちに変換する関数が<font color=\"red\">**pivot_wider関数**</font>です．共に第一引数がデータフレームで，パイプ演算子を用いて演算を行うのが一般的です．\n\npivot_longer関数もpivot_wider関数も，Rでのデータ解析ではとても重要となりますが，共に変換がやや複雑で，挙動がわかりにくい関数でもあります．下の例を参考に，どのようにデータが変換されるのか，よく理解した上で用いるのがよいでしょう．\n\n#### 縦持ちへの変換：pivot_longer\n\n<font color=\"red\">**pivot_longer関数**</font>はデータフレームと列番号を引数に取り，列番号で指定した列の名前をnameという列の要素に変換し，列番号で指定した列の要素をvalueという名前の列として，1列のデータに変換します．このような変換により，データは縦長の構造を取ります．\n\n変換後の列名は引数で指定でき，列の名前に関する列名は「names_to」，列の要素に関する列名は「values_to」引数に指定します．このpivot_longer関数は特に統計・グラフ作成の際によく用います．\n\ntidyrが開発されるまでは，reshapeという関数で縦持ち変換を行うのが一般的でした．また，pivot_longer関数はtidyr開発初期にはgatherという名前で，引数の順番も少し異なっていました．今でもreshapeやgatherを用いて縦持ちへの変換を行うことはできます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n\n```{.r .cell-code}\n# pivot_longer 縦持ちデータへの変換\niris |> pivot_longer(cols = 1:4) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 600 x 3\n   Species name         value\n   <fct>   <chr>        <dbl>\n 1 setosa  Sepal.Length   5.1\n 2 setosa  Sepal.Width    3.5\n 3 setosa  Petal.Length   1.4\n 4 setosa  Petal.Width    0.2\n 5 setosa  Sepal.Length   4.9\n 6 setosa  Sepal.Width    3  \n 7 setosa  Petal.Length   1.4\n 8 setosa  Petal.Width    0.2\n 9 setosa  Sepal.Length   4.7\n10 setosa  Sepal.Width    3.2\n# i 590 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> pivot_longer(cols = 1:4, names_to = \"category\", values_to = \"value\") # 上と同じ（列名を設定）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 600 x 3\n   Species category     value\n   <fct>   <chr>        <dbl>\n 1 setosa  Sepal.Length   5.1\n 2 setosa  Sepal.Width    3.5\n 3 setosa  Petal.Length   1.4\n 4 setosa  Petal.Width    0.2\n 5 setosa  Sepal.Length   4.9\n 6 setosa  Sepal.Width    3  \n 7 setosa  Petal.Length   1.4\n 8 setosa  Petal.Width    0.2\n 9 setosa  Sepal.Length   4.7\n10 setosa  Sepal.Width    3.2\n# i 590 more rows\n```\n:::\n\n```{.r .cell-code}\n# gather\niris |> gather(category, value, 1:4) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Species     category value\n1  setosa Sepal.Length   5.1\n2  setosa Sepal.Length   4.9\n3  setosa Sepal.Length   4.7\n4  setosa Sepal.Length   4.6\n5  setosa Sepal.Length   5.0\n6  setosa Sepal.Length   5.4\n```\n:::\n\n```{.r .cell-code}\niris |> gather(category, value, -Species) |> head() # 上と同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Species     category value\n1  setosa Sepal.Length   5.1\n2  setosa Sepal.Length   4.9\n3  setosa Sepal.Length   4.7\n4  setosa Sepal.Length   4.6\n5  setosa Sepal.Length   5.0\n6  setosa Sepal.Length   5.4\n```\n:::\n:::\n\n\n#### 横持ちへの変換：pivot_wider\n\n<font color=\"red\">**pivot_wider関数**</font>は，データを横持ちに変換する関数です．pivot_wider関数は列名となる列をnames_from引数に，要素となる列をvalues_from引数に指定します．指定しなかった列はそのまま維持されます．names_fromで指定した列の要素は各列名となり，values_fromで指定した列の要素がnames_fromで新しく作られた列の値となります．この変換により，データは横長の，幅の広い構造を取ることになります．\n\n横持ちへの変換もreshapeを用いて行うことができます．また，pivot_widerは以前はspreadという名前であったため，このspread関数を用いて横持ちデータへの変換を行うこともできます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pivot_wider 横持ちデータへの変換\nus_rent_income\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 104 x 5\n   GEOID NAME       variable estimate   moe\n   <chr> <chr>      <chr>       <dbl> <dbl>\n 1 01    Alabama    income      24476   136\n 2 01    Alabama    rent          747     3\n 3 02    Alaska     income      32940   508\n 4 02    Alaska     rent         1200    13\n 5 04    Arizona    income      27517   148\n 6 04    Arizona    rent          972     4\n 7 05    Arkansas   income      23789   165\n 8 05    Arkansas   rent          709     5\n 9 06    California income      29454   109\n10 06    California rent         1358     3\n# i 94 more rows\n```\n:::\n\n```{.r .cell-code}\nus_rent_income |> pivot_wider(names_from = variable, values_from = c(estimate, moe)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 52 x 6\n   GEOID NAME                 estimate_income estimate_rent moe_income moe_rent\n   <chr> <chr>                          <dbl>         <dbl>      <dbl>    <dbl>\n 1 01    Alabama                        24476           747        136        3\n 2 02    Alaska                         32940          1200        508       13\n 3 04    Arizona                        27517           972        148        4\n 4 05    Arkansas                       23789           709        165        5\n 5 06    California                     29454          1358        109        3\n 6 08    Colorado                       32401          1125        109        5\n 7 09    Connecticut                    35326          1123        195        5\n 8 10    Delaware                       31560          1076        247       10\n 9 11    District of Columbia           43198          1424        681       17\n10 12    Florida                        25952          1077         70        3\n# i 42 more rows\n```\n:::\n\n```{.r .cell-code}\n# spread（valueは1つしか値を取れない）\nus_rent_income |> spread(variable, estimate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 104 x 5\n   GEOID NAME         moe income  rent\n   <chr> <chr>      <dbl>  <dbl> <dbl>\n 1 01    Alabama        3     NA   747\n 2 01    Alabama      136  24476    NA\n 3 02    Alaska        13     NA  1200\n 4 02    Alaska       508  32940    NA\n 5 04    Arizona        4     NA   972\n 6 04    Arizona      148  27517    NA\n 7 05    Arkansas       5     NA   709\n 8 05    Arkansas     165  23789    NA\n 9 06    California     3     NA  1358\n10 06    California   109  29454    NA\n# i 94 more rows\n```\n:::\n:::\n\n\n#### tidyrのその他の関数\n\ntidyrには，pivot_longer，pivot_wider以外にも，データの全組み合わせを作成したり，データフレーム上のNAを置き換えるような関数が備わっています．pivot_longer/pivot_widerほどには使用頻度は高くありませんが，覚えておくと役に立つ場面もあるかもしれません．\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- data.frame(x = c(1, 2, NA, 4), y = c(NA, \"b\", \"c\", \"d\"))\nd |> expand(x, y) # d |> expand.grid()と同じ（tibbleが返ってくる）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 x 2\n       x y    \n   <dbl> <chr>\n 1     1 b    \n 2     1 c    \n 3     1 d    \n 4     1 <NA> \n 5     2 b    \n 6     2 c    \n 7     2 d    \n 8     2 <NA> \n 9     4 b    \n10     4 c    \n11     4 d    \n12     4 <NA> \n13    NA b    \n14    NA c    \n15    NA d    \n16    NA <NA> \n```\n:::\n\n```{.r .cell-code}\nd |> replace_na(list(x = 1, y = \"nodata\")) # NAの置き換え\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x      y\n1 1 nodata\n2 2      b\n3 1      c\n4 4      d\n```\n:::\n\n```{.r .cell-code}\nd |> fill(x, y) # 一つ上の値でNAを埋める（1番上はNAのまま）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x    y\n1 1 <NA>\n2 2    b\n3 2    c\n4 4    d\n```\n:::\n:::\n\n\nデータのグループ化（group_by），ネスト（nest）については後ほど説明します．\n\n### dplyr\n\ntidyrによって縦持ちに変換したデータフレームを加工し，データの抽出・演算・集計等を行うためのライブラリが，<font color=\"red\">**dplyr**</font>です．dplyrの関数群も，基本的にパイプ演算子を用いて使用することが想定されています．\n\ndplyrには非常に沢山の関数が設定されていますが，特に使用頻度が高く，重要な関数は，<font color=\"red\">**filter，select，arrange，mutate，summarise**</font>の5つです．\n\n以下の表にdplyrの関数の一覧を示します．\n\n[これ](https://rstudio.github.io/cheatsheets/data-transformation.pdf)を参照\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：dplyrの関数群</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 適用する演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> filter </td>\n   <td style=\"text-align:left;\"> 条件で行を選択する（subsetと類似） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> select </td>\n   <td style=\"text-align:left;\"> 列を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> arrange </td>\n   <td style=\"text-align:left;\"> 列で並べ替える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> desc </td>\n   <td style=\"text-align:left;\"> 並べ替えを降順にする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mutate </td>\n   <td style=\"text-align:left;\"> 新しい列を追加する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> group_by </td>\n   <td style=\"text-align:left;\"> データを列でグループ化する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rowwise </td>\n   <td style=\"text-align:left;\"> 行ごとに演算できるようにする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> summarise </td>\n   <td style=\"text-align:left;\"> 列ごとに関数を適用する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> distinct </td>\n   <td style=\"text-align:left;\"> 重複した行を削除 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> slice </td>\n   <td style=\"text-align:left;\"> 一部の行を取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rename </td>\n   <td style=\"text-align:left;\"> 列名を変更する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> inner_join </td>\n   <td style=\"text-align:left;\"> データフレームを結合する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> left_join </td>\n   <td style=\"text-align:left;\"> データフレームを左から結合する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> right_join </td>\n   <td style=\"text-align:left;\"> データフレームを右から結合する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> case_when </td>\n   <td style=\"text-align:left;\"> switch文と類似した条件分岐 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> case_match </td>\n   <td style=\"text-align:left;\"> switch文と類似した条件分岐 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> if_else </td>\n   <td style=\"text-align:left;\"> ifelse文の取り扱いを良くした関数 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n#### filter関数\n\n<font color=\"red\">**filter関数**</font>は，データフレームから条件に従い行を選択するための関数です．Rにはよく似た**subset**という関数がありますが，他のtidyverseの関数と共に用いる場合はfilter関数を用いたほうが良いでしょう．\n\nfilter関数はデータフレームを第一引数，条件式を第二引数に取る関数です．第二引数に指定した条件に合致した行のみを選択することができます．下の例では，Speciesの列の要素がsetosaである行を選択肢，取得しています．\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> tibble() |> filter(Species == \"setosa\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 40 more rows\n```\n:::\n:::\n\n\n<font color=\"red\">**select関数**</font>は，データフレームから列を選択するための関数です．select関数もデータフレームを第一引数にとり，それ以降に列名を引数に取ります．select関数を用いると，引数で指定した列のみを含むデータフレームが返ってきます．また，マイナスで列名を指定すると，その列を取り除いたデータフレームが返ってきます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> tibble() |> select(Sepal.Length, Sepal.Width, Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 3\n   Sepal.Length Sepal.Width Species\n          <dbl>       <dbl> <fct>  \n 1          5.1         3.5 setosa \n 2          4.9         3   setosa \n 3          4.7         3.2 setosa \n 4          4.6         3.1 setosa \n 5          5           3.6 setosa \n 6          5.4         3.9 setosa \n 7          4.6         3.4 setosa \n 8          5           3.4 setosa \n 9          4.4         2.9 setosa \n10          4.9         3.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> tibble() |> select(-Sepal.Length, -Sepal.Width, -Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 2\n   Petal.Length Petal.Width\n          <dbl>       <dbl>\n 1          1.4         0.2\n 2          1.4         0.2\n 3          1.3         0.2\n 4          1.5         0.2\n 5          1.4         0.2\n 6          1.7         0.4\n 7          1.4         0.3\n 8          1.5         0.2\n 9          1.4         0.2\n10          1.5         0.1\n# i 140 more rows\n```\n:::\n:::\n\n\nselect関数では，列を選択する特殊な関数を引数に取ることもできます．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：selectに用いる列選択の関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 適用する演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> everything() </td>\n   <td style=\"text-align:left;\"> すべての列を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> last_col(n) </td>\n   <td style=\"text-align:left;\"> 後ろからn番目の列を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> group_cols() </td>\n   <td style=\"text-align:left;\"> グループ化に用いた列を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> starts_with(&quot;文字列&quot;) </td>\n   <td style=\"text-align:left;\"> 指定した文字列から始まる列名を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ends_with(&quot;文字列&quot;) </td>\n   <td style=\"text-align:left;\"> 指定した文字列で終わる列名を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> contains(&quot;文字列&quot;) </td>\n   <td style=\"text-align:left;\"> 指定した文字列を含む列名を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> matches(&quot;正規表現&quot;) </td>\n   <td style=\"text-align:left;\"> 正規表現に従い列名を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> num_range(&quot;文字列&quot;, n:m) </td>\n   <td style=\"text-align:left;\"> 文字列で始まる列名のn～m番目を選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> all_of(&quot;文字列&quot;) </td>\n   <td style=\"text-align:left;\"> 列名を文字列で選択する（列名がないとエラー） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> any_of(&quot;文字列&quot;) </td>\n   <td style=\"text-align:left;\"> 列名を文字列で選択する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> where(関数) </td>\n   <td style=\"text-align:left;\"> 論理型を返す関数に従い選択する </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n#### arrange関数\n\n<font color=\"red\">**arrange関数**</font>は，データフレームを指定した列に従い，昇順（小さいものが上）に並べ替える関数です．order関数を用いてもデータフレームの並べ替えはできますが，arrange関数を用いた方が簡単に列名を変更できます．\n\narrange関数のヘルパーとして，**desc関数**が設定されています．desc関数はデータフレームを降順（大きいものが上）に並べ替える場合に用います．\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> tibble() |> arrange(Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          4.3         3            1.1         0.1 setosa \n 2          4.4         2.9          1.4         0.2 setosa \n 3          4.4         3            1.3         0.2 setosa \n 4          4.4         3.2          1.3         0.2 setosa \n 5          4.5         2.3          1.3         0.3 setosa \n 6          4.6         3.1          1.5         0.2 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          4.6         3.6          1           0.2 setosa \n 9          4.6         3.2          1.4         0.2 setosa \n10          4.7         3.2          1.3         0.2 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> tibble() |> arrange(desc(Sepal.Length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  \n          <dbl>       <dbl>        <dbl>       <dbl> <fct>    \n 1          7.9         3.8          6.4         2   virginica\n 2          7.7         3.8          6.7         2.2 virginica\n 3          7.7         2.6          6.9         2.3 virginica\n 4          7.7         2.8          6.7         2   virginica\n 5          7.7         3            6.1         2.3 virginica\n 6          7.6         3            6.6         2.1 virginica\n 7          7.4         2.8          6.1         1.9 virginica\n 8          7.3         2.9          6.3         1.8 virginica\n 9          7.2         3.6          6.1         2.5 virginica\n10          7.2         3.2          6           1.8 virginica\n# i 140 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> tibble() |> mutate(Sepal.ratio = Sepal.Length / Sepal.Width)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 6\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.ratio\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>         <dbl>\n 1          5.1         3.5          1.4         0.2 setosa         1.46\n 2          4.9         3            1.4         0.2 setosa         1.63\n 3          4.7         3.2          1.3         0.2 setosa         1.47\n 4          4.6         3.1          1.5         0.2 setosa         1.48\n 5          5           3.6          1.4         0.2 setosa         1.39\n 6          5.4         3.9          1.7         0.4 setosa         1.38\n 7          4.6         3.4          1.4         0.3 setosa         1.35\n 8          5           3.4          1.5         0.2 setosa         1.47\n 9          4.4         2.9          1.4         0.2 setosa         1.52\n10          4.9         3.1          1.5         0.1 setosa         1.58\n# i 140 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> summarise(m = mean(Sepal.Length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         m\n1 5.843333\n```\n:::\n\n```{.r .cell-code}\niris |> group_by(Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n# Groups:   Species [3]\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> group_by(Species) |> ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> group_by(Species) |> summarise(m = mean(Sepal.Length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  Species        m\n  <fct>      <dbl>\n1 setosa      5.01\n2 versicolor  5.94\n3 virginica   6.59\n```\n:::\n\n```{.r .cell-code}\niris |> summarise(m = mean(Sepal.Length), .by = Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Species     m\n1     setosa 5.006\n2 versicolor 5.936\n3  virginica 6.588\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> slice(5:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.0         3.6          1.4         0.2  setosa\n2          5.4         3.9          1.7         0.4  setosa\n3          4.6         3.4          1.4         0.3  setosa\n4          5.0         3.4          1.5         0.2  setosa\n5          4.4         2.9          1.4         0.2  setosa\n6          4.9         3.1          1.5         0.1  setosa\n```\n:::\n\n```{.r .cell-code}\niris |> _[5:10, ] # エラー\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n```\n:::\n\n```{.r .cell-code}\niris %>% .[5:10, ] # こちらはOK\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n```\n:::\n\n```{.r .cell-code}\niris |> slice_head(5) # head(iris, 5)と同じ\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `slice_head()`:\n! `n` must be explicitly named.\ni Did you mean `slice_head(n = 5)`?\n```\n:::\n\n```{.r .cell-code}\niris |> slice_tail(5) # tail(iris, 5)と同じ\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `slice_tail()`:\n! `n` must be explicitly named.\ni Did you mean `slice_tail(n = 5)`?\n```\n:::\n\n```{.r .cell-code}\niris |> slice_min(Sepal.Length, n = 5) # Sepal.Lengthが小さいものから5行\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.3         3.0          1.1         0.1  setosa\n2          4.4         2.9          1.4         0.2  setosa\n3          4.4         3.0          1.3         0.2  setosa\n4          4.4         3.2          1.3         0.2  setosa\n5          4.5         2.3          1.3         0.3  setosa\n```\n:::\n\n```{.r .cell-code}\niris |> slice_max(Sepal.Length, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          7.9         3.8          6.4         2.0 virginica\n2          7.7         3.8          6.7         2.2 virginica\n3          7.7         2.6          6.9         2.3 virginica\n4          7.7         2.8          6.7         2.0 virginica\n5          7.7         3.0          6.1         2.3 virginica\n```\n:::\n\n```{.r .cell-code}\niris |> slice_sample(n = 5) # ランダムに5行抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          7.3         2.9          6.3         1.8  virginica\n2          6.2         3.4          5.4         2.3  virginica\n3          6.7         3.1          4.7         1.5 versicolor\n4          5.8         2.7          5.1         1.9  virginica\n5          6.5         2.8          4.6         1.5 versicolor\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> tibble() |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.~\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.~\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.~\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.~\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s~\n```\n:::\n\n```{.r .cell-code}\niris |> tibble() |> pull(Species) # iris$Speciesと同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] setosa     setosa     setosa     setosa     setosa     setosa    \n  [7] setosa     setosa     setosa     setosa     setosa     setosa    \n [13] setosa     setosa     setosa     setosa     setosa     setosa    \n [19] setosa     setosa     setosa     setosa     setosa     setosa    \n [25] setosa     setosa     setosa     setosa     setosa     setosa    \n [31] setosa     setosa     setosa     setosa     setosa     setosa    \n [37] setosa     setosa     setosa     setosa     setosa     setosa    \n [43] setosa     setosa     setosa     setosa     setosa     setosa    \n [49] setosa     setosa     versicolor versicolor versicolor versicolor\n [55] versicolor versicolor versicolor versicolor versicolor versicolor\n [61] versicolor versicolor versicolor versicolor versicolor versicolor\n [67] versicolor versicolor versicolor versicolor versicolor versicolor\n [73] versicolor versicolor versicolor versicolor versicolor versicolor\n [79] versicolor versicolor versicolor versicolor versicolor versicolor\n [85] versicolor versicolor versicolor versicolor versicolor versicolor\n [91] versicolor versicolor versicolor versicolor versicolor versicolor\n [97] versicolor versicolor versicolor versicolor virginica  virginica \n[103] virginica  virginica  virginica  virginica  virginica  virginica \n[109] virginica  virginica  virginica  virginica  virginica  virginica \n[115] virginica  virginica  virginica  virginica  virginica  virginica \n[121] virginica  virginica  virginica  virginica  virginica  virginica \n[127] virginica  virginica  virginica  virginica  virginica  virginica \n[133] virginica  virginica  virginica  virginica  virginica  virginica \n[139] virginica  virginica  virginica  virginica  virginica  virginica \n[145] virginica  virginica  virginica  virginica  virginica  virginica \nLevels: setosa versicolor virginica\n```\n:::\n\n```{.r .cell-code}\n# 列の並べ替え\niris |> tibble() |> relocate(Species, Petal.Width, Petal.Length, Sepal.Width, Sepal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Species Petal.Width Petal.Length Sepal.Width Sepal.Length\n   <fct>         <dbl>        <dbl>       <dbl>        <dbl>\n 1 setosa          0.2          1.4         3.5          5.1\n 2 setosa          0.2          1.4         3            4.9\n 3 setosa          0.2          1.3         3.2          4.7\n 4 setosa          0.2          1.5         3.1          4.6\n 5 setosa          0.2          1.4         3.6          5  \n 6 setosa          0.4          1.7         3.9          5.4\n 7 setosa          0.3          1.4         3.4          4.6\n 8 setosa          0.2          1.5         3.4          5  \n 9 setosa          0.2          1.4         2.9          4.4\n10 setosa          0.1          1.5         3.1          4.9\n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> tibble() |> rename(S = Species) # 列名SpeciesをSに変更\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width S     \n          <dbl>       <dbl>        <dbl>       <dbl> <fct> \n 1          5.1         3.5          1.4         0.2 setosa\n 2          4.9         3            1.4         0.2 setosa\n 3          4.7         3.2          1.3         0.2 setosa\n 4          4.6         3.1          1.5         0.2 setosa\n 5          5           3.6          1.4         0.2 setosa\n 6          5.4         3.9          1.7         0.4 setosa\n 7          4.6         3.4          1.4         0.3 setosa\n 8          5           3.4          1.5         0.2 setosa\n 9          4.4         2.9          1.4         0.2 setosa\n10          4.9         3.1          1.5         0.1 setosa\n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> count(Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Species  n\n1     setosa 50\n2 versicolor 50\n3  virginica 50\n```\n:::\n\n```{.r .cell-code}\niris |> tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    n\n1 150\n```\n:::\n\n```{.r .cell-code}\niris |> group_by(Species) |> tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  Species        n\n  <fct>      <int>\n1 setosa        50\n2 versicolor    50\n3 virginica     50\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> rowwise() # Rowwiseのラベルが付く\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n# Rowwise: \n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> rowwise() |> ungroup() # ungroupでRowwiseが消える\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> rowwise() |> mutate(minr = min(c(Sepal.Length, Sepal.Width))) # 横（行）方向への演算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 6\n# Rowwise: \n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  minr\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>   <dbl>\n 1          5.1         3.5          1.4         0.2 setosa    3.5\n 2          4.9         3            1.4         0.2 setosa    3  \n 3          4.7         3.2          1.3         0.2 setosa    3.2\n 4          4.6         3.1          1.5         0.2 setosa    3.1\n 5          5           3.6          1.4         0.2 setosa    3.6\n 6          5.4         3.9          1.7         0.4 setosa    3.9\n 7          4.6         3.4          1.4         0.3 setosa    3.4\n 8          5           3.4          1.5         0.2 setosa    3.4\n 9          4.4         2.9          1.4         0.2 setosa    2.9\n10          4.9         3.1          1.5         0.1 setosa    3.1\n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris |> tibble() |> mutate(minr = min(c(Sepal.Length, Sepal.Width))) # 縦の最小値が出てくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 6\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  minr\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>   <dbl>\n 1          5.1         3.5          1.4         0.2 setosa      2\n 2          4.9         3            1.4         0.2 setosa      2\n 3          4.7         3.2          1.3         0.2 setosa      2\n 4          4.6         3.1          1.5         0.2 setosa      2\n 5          5           3.6          1.4         0.2 setosa      2\n 6          5.4         3.9          1.7         0.4 setosa      2\n 7          4.6         3.4          1.4         0.3 setosa      2\n 8          5           3.4          1.5         0.2 setosa      2\n 9          4.4         2.9          1.4         0.2 setosa      2\n10          4.9         3.1          1.5         0.1 setosa      2\n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris$Sepal.Width |> min()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tibble(x = rep(1:3, 5), y = rep(c(\"a\", \"b\", \"c\"), rep(5, 3)), z = c(T, F, T)) # サイズが2個以上だとrecycleしない\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in `tibble()`:\n! Tibble columns must have compatible sizes.\n* Size 15: Existing data.\n* Size 3: Column `z`.\ni Only values of size one are recycled.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  name  band   \n  <chr> <chr>  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n```\n:::\n\n```{.r .cell-code}\nband_instruments\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  name  plays \n  <chr> <chr> \n1 John  guitar\n2 Paul  bass  \n3 Keith guitar\n```\n:::\n\n```{.r .cell-code}\nband_members |> inner_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(name)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n```\n:::\n\n```{.r .cell-code}\nband_members |> left_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(name)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n```\n:::\n\n```{.r .cell-code}\nband_members |> right_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(name)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n3 Keith <NA>    guitar\n```\n:::\n:::\n\n\n## tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse)\nd <- tibble(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = c(T, F, T))\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n      x y     z    \n  <int> <chr> <lgl>\n1     1 a     TRUE \n2     2 b     FALSE\n3     3 c     TRUE \n```\n:::\n\n```{.r .cell-code}\nclass(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nas_tibble(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n:::\n\n\n### ネスト（nest）したデータ\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> group_by(Species) # データのグループ化（tibbleに変換される）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n# Groups:   Species [3]\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# i 140 more rows\n```\n:::\n\n```{.r .cell-code}\niris_nested <- iris |> as_tibble() |> group_by(Species) |> nest() # ネストしたデータ\niris_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n# Groups:   Species [3]\n  Species    data             \n  <fct>      <list>           \n1 setosa     <tibble [50 x 4]>\n2 versicolor <tibble [50 x 4]>\n3 virginica  <tibble [50 x 4]>\n```\n:::\n\n```{.r .cell-code}\niris_nested[1, 2] |> unnest() # ネストを解除\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `cols` is now required when using `unnest()`.\ni Please use `cols = c(data)`.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 x 4\n   Sepal.Length Sepal.Width Petal.Length Petal.Width\n          <dbl>       <dbl>        <dbl>       <dbl>\n 1          5.1         3.5          1.4         0.2\n 2          4.9         3            1.4         0.2\n 3          4.7         3.2          1.3         0.2\n 4          4.6         3.1          1.5         0.2\n 5          5           3.6          1.4         0.2\n 6          5.4         3.9          1.7         0.4\n 7          4.6         3.4          1.4         0.3\n 8          5           3.4          1.5         0.2\n 9          4.4         2.9          1.4         0.2\n10          4.9         3.1          1.5         0.1\n# i 40 more rows\n```\n:::\n:::\n\n\n## purrrの簡単な紹介\n\nhttps://qiita.com/kilometer/items/b4977df268d2c21211fc を参照している mapはsapplyに似ているけど，tibbleのネストと合わせて超変な使い方ができる（あまり推奨しない）\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |> group_by(Species) |> nest() # nestするとdataの行が追加される\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n# Groups:   Species [3]\n  Species    data             \n  <fct>      <list>           \n1 setosa     <tibble [50 x 4]>\n2 versicolor <tibble [50 x 4]>\n3 virginica  <tibble [50 x 4]>\n```\n:::\n\n```{.r .cell-code}\n# tibbleは統計結果もnestできる\n(d <- iris |> group_by(Species) |> nest() |> mutate(lmcalc = map(data, ~lm(Sepal.Length ~ Sepal.Width, data = .))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n# Groups:   Species [3]\n  Species    data              lmcalc\n  <fct>      <list>            <list>\n1 setosa     <tibble [50 x 4]> <lm>  \n2 versicolor <tibble [50 x 4]> <lm>  \n3 virginica  <tibble [50 x 4]> <lm>  \n```\n:::\n\n```{.r .cell-code}\nd$lmcalc # 線形回帰の結果（リスト）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width, data = .)\n\nCoefficients:\n(Intercept)  Sepal.Width  \n     2.6390       0.6905  \n\n\n[[2]]\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width, data = .)\n\nCoefficients:\n(Intercept)  Sepal.Width  \n     3.5397       0.8651  \n\n\n[[3]]\n\nCall:\nlm(formula = Sepal.Length ~ Sepal.Width, data = .)\n\nCoefficients:\n(Intercept)  Sepal.Width  \n     3.9068       0.9015  \n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}