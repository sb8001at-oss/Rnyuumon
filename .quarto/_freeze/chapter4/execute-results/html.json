{
  "hash": "da3d717b91ba39101ea2955e379741ce",
  "result": {
    "engine": "knitr",
    "markdown": "# 条件判断（Control structures）\n\n\n\n\n\n## 条件判断とは？\n\nプログラミングでは、ある条件のときはこの処理、別の条件のときはこの処理...、といった具合に、条件によって行う処理を変えたいことがよくあります。例えば、じゃんけんでは出した手の条件によって勝ち・負け・引き分けという3つの処理を行うことになります。このように、条件によって処理を変えることを、**条件判断**と呼びます。\n\n## 条件と論理型（logical）\n\n条件として用いられるのは、**論理型（logical）**です。論理型は`TRUE`（真）と`FALSE`（偽）の2つの値を持ちます。論理型はそれそのものを用いる場合と、比較演算子の演算結果として得る場合があります。Rでは、**`TRUE`を`T`、`FALSE`を`F`**と表記することができます。\n\n\n::: {.cell filename='論理型'}\n\n```{.r .cell-code}\nTRUE\n## [1] TRUE\n\nFALSE\n## [1] FALSE\n\nT\n## [1] TRUE\n\nF\n## [1] FALSE\n\nc(T, F, T, F) # logicalはベクターにもできる\n## [1]  TRUE FALSE  TRUE FALSE\n\n1 < 3 # 3は1より大きいのでTRUE\n## [1] TRUE\n\n1 > 3 # 1は3より大きくないのでFALSE\n## [1] FALSE\n```\n:::\n\n\n## 数値としての論理型\n\n論理型は、Rの内部では数字として取り扱われています。Rでは**`TRUE`は`1`、`FALSE`は`0`**と同一です。ですので、ベクター中の`TRUE`の数を足し算で計算することができます。また、**`0`以外が`TRUE`、`0`が`FALSE`**として扱われる場合もあります。条件判断では`0`を`FALSE`として用いる場合もあります。\n\n\n::: {.cell filename='数値としての真偽値'}\n\n```{.r .cell-code}\nT + T + F # 足し算すると2が返ってくる\n## [1] 2\n\nvec <- c(T, T, F, T, F, T, F)\nsum(vec) # sumはベクターの要素を足し算する関数\n## [1] 4\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## 他言語でのTRUEとFALSEの数値変換\n\nRではTRUEが1、FALSEが0ですが、他の言語ではFALSEが-1のものもあります。言語によりTRUE/FALSEの仕様は異なります。\n\n:::\n\n## 論理演算子\n\n論理型は、**論理演算子**による計算に使うことができます。Rでの論理演算子は**`&`、`&&`、`|`、`||`**の4つです。このうち、`&&`と`||`は、ベクターの**始めの値だけ**を評価するという特徴を持っています（Rのバージョン4.3以降ではベクターを比較するとエラーが出ます）。`&&`と`||`を用いるとプログラムが予想外の挙動を取ることがあるので、できるだけ`&`と`|`だけを用いたほうがよいでしょう。RにはNAND（否定論理積）、NOR（否定論理和）などを表す専用の論理演算子はありませんが、XOR（排他的論理和）を表す関数（`xor`関数）はあります。XORは2つの論理型に対し、どちらかがTRUEならTRUEを、両方がFALSEならFALSEを返す演算子です。\n\n\n::: {.cell filename='論理演算子'}\n::: {.cell-output-display}\n\n\nTable: 表1：Rで使える論理演算子\n\n|論理演算子   |演算子の意味                           |\n|:------------|:--------------------------------------|\n|&            |論理積（AかつB）                       |\n|&&           |論理積（ベクターの始めの要素のみ評価） |\n|&#124;       |論理和（AまたはB）                     |\n|&#124;&#124; |論理和（ベクターの始めの要素のみ評価） |\n|!            |否定演算子（真偽を反転）               |\n|xor          |排他的論理和                           |\n|any          |いずれかが真の時に真を返す             |\n|all          |すべてが真の時に真を返す               |\n\n\n:::\n:::\n\n::: {.cell filename='論理演算子による演算'}\n\n```{.r .cell-code}\nlogic1 <- c(T, F)\nlogic2 <- c(F, F)\nlogic1 & logic2 # & は論理積（AND）\n## [1] FALSE FALSE\n\nlogic1 | logic2 # | は論理和（OR）\n## [1]  TRUE FALSE\n\nlogic1 && logic2 # 1番目の項目同士のみを比較する\n## Error in logic1 && logic2: 'length = 2' in coercion to 'logical(1)'\n\nlogic1 || logic2\n## Error in logic1 || logic2: 'length = 2' in coercion to 'logical(1)'\n\nxor(logic1, logic2) # 排他的論理和\n## [1]  TRUE FALSE\n\nany(logic1) # 片方がTRUEなのでTRUE\n## [1] TRUE\n\nall(logic1) # すべてがTRUEでは無いのでFALSE\n## [1] FALSE\n```\n:::\n\n\n論理演算子として、**`!`（エクスクラメーションマーク、否定演算子）**も用いることができます。`!`は論理型の前に置くことで、論理型を反転（`TRUE`を`FALSE`に、`FALSE`を`TRUE`に）させます。\n\n\n::: {.cell filename='!による論理値の反転'}\n\n```{.r .cell-code}\n!TRUE\n## [1] FALSE\n!FALSE\n## [1] TRUE\n\n!(1 < 3)\n## [1] FALSE\n!(1 > 3)\n## [1] TRUE\n```\n:::\n\n\n## 条件分岐の文\n\n上記のように、比較演算子や論理演算子を用いると、論理型を得ることができます。この論理型に従い、行う処理を変えるものを、**条件分岐**と呼びます。条件分岐では、条件分岐の文（Control structures）というものが用いられます。Rでは、条件分岐の文として、**if文とswitch文**の2つが設定されています。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表2：Rで使える条件分岐\n\n|条件分岐   |条件分岐の形式                                      |\n|:----------|:---------------------------------------------------|\n|if文       |if(条件式){TRUEのときの演算}else{FALSEのときの演算} |\n|ifelse関数 |ifelse(条件式, TRUEのときの演算, FALSEのときの演算) |\n|switch文   |switch(評価する値, 評価の既定値=既定値のときの演算) |\n\n\n:::\n:::\n\n\n### if文\n\n`if`文は最もシンプルな条件分岐の文です。`if`文では、**条件式**に従い、実行する処理が変わります。Rでの`if`文は、以下の形を取ります。\n\n**if(条件式){TRUEのときに実施する処理}**\n\n条件式を**`if()`**のカッコの中に書きます。`if`文は1行で書くこともできますし、複数行に渡って書くこともできます。複数行に処理を書くときには、**中括弧（`{}`）**を条件式の後に書き、中括弧の中に処理を書きます。\n\n\n::: {.cell filename='if文の使い方'}\n\n```{.r .cell-code}\nif(TRUE) \"Hello R\" # 1行で書く場合（\"Hello R\"が返ってくる）\n## [1] \"Hello R\"\n\nif(FALSE) \"Hello FALSE\" # 条件式がFALSEなので、何も返ってこない\n\nif(TRUE){ # 複数行で書く時には中括弧（{}）を用いる\n  \"Hello R\"\n}\n## [1] \"Hello R\"\n\nif(FALSE){\"Hello FALSE\"} # 1行のif文で中括弧を使ってもよい\n```\n:::\n\n\n`if`文の条件が`0`のときには、`0`が`FALSE`であると判断されて、処理が実行されません。一方で条件が`0`以外である場合には、`TRUE`であると判断されて処理が実行されます。`if(0)`とするとその処理が行われないので、**Rでは`if(0)`がコメントアウトに使われる**こともあります。\n\n\n::: {.cell filename='条件式が数値の時のif文'}\n\n```{.r .cell-code}\nif(0){\"0はFALSEなので、これは表示されません\"}\n\nif(-1){\"-1はTRUE扱いなので、表示されます\"}\n## [1] \"-1はTRUE扱いなので、表示されます\"\n\nif(-0.005){\"0以外はTRUEとして処理されます\"}\n## [1] \"0以外はTRUEとして処理されます\"\n```\n:::\n\n\n#### if else文\n\n`if`文ではさらに条件を分岐させることもできます。条件を追加する場合には、`if`文の後に、`else if()`を繋げます。`else if()`のカッコの中に2つ目の条件を書くことで、条件を分離させることができます。`else`だけを書いて、`if()`の条件式をつけない場合には、どの条件にも合わない時に実行する処理になります。ですので、`if else`文は以下の形を取ります。\n\n**if(条件式1){**\\\n**式1がTRUEのときの処理**\\\n**}else if(条件式2){**\\\n**式1がFALSE、式2がTRUEのときの処理**\\\n**}else{**\\\n**式1、2がFALSEのときの処理**\\\n**}**\n\n\n::: {.cell filename='if else文'}\n\n```{.r .cell-code}\nx <- 2 # xは2\n\n# xは2なので、2番目の処理が返ってくる\nif(x == 1){ # =が1つだと代入になるのでエラーが出る\n  \"first\"\n} else if(x == 2){\n  \"second\"\n} else {\n  \"others\"\n}\n## [1] \"second\"\n```\n:::\n\n\n#### ifelse関数\n\n条件分岐が2つしかない場合には、`ifelse`関数を用いることもできます。`ifelse`関数は3つの引数、「(条件式)、(`TRUE`のときの処理)、(`FALSE`のときの処理)」を取ります。条件が1つだけで、簡単な処理のみを行うのであれば`ifelse`関数で十分な場合もあります。\n\n\n::: {.cell filename='ifelse関数'}\n\n```{.r .cell-code}\n# TRUEなので2番目の処理が返ってくる\nifelse(1 < 3, \"One is smaller than three.\", \"One is not smaller than three.\")\n## [1] \"One is smaller than three.\"\n\n# FALSEなので3番目の処理が返ってくる\nifelse(1 > 3, \"One is larger than three.\", \"One is not larger than three.\") \n## [1] \"One is not larger than three.\"\n```\n:::\n\n\n### switch文\n\n条件式ではなく、特定の値に対応して処理を変えたい場合には、`switch`文を用います。`switch`文では、**始めの引数が条件を指定する値、それに続く引数が条件に対応した処理**となります。条件を指定する値には、数値または文字列を用いることができます。条件が数値の場合と文字列の場合では、やや使い方が異なります。\n\n\n::: {.cell filename='switch文（条件が数値のとき）'}\n\n```{.r .cell-code}\n# 条件が1のときは、2番目の引数の処理が返ってくる\nswitch(1, \"first\", \"second\", \"third\") \n## [1] \"first\"\n\n# 条件が2のときは、3番目の引数の処理が返ってくる\nswitch(2, \"first\", \"second\", \"third\") \n## [1] \"second\"\n\n# 条件が5のときは、6番目の引数の処理がないので何も返ってこない\nswitch(5, \"first\", \"second\", \"third\") \n```\n:::\n\n::: {.cell filename='switch文（条件が文字列のとき）'}\n\n```{.r .cell-code}\n# 条件式に対応したもの（=で繋いだもの）が返ってくる\nswitch(\"dog\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n## [1] \"犬\"\n\nswitch(\"monkey\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n## [1] \"猿\"\n\n# horseは引数に登録していないので、何も返ってこない\nswitch(\"horse\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## ライブラリで設定されている条件分岐\n\nインストールしたばかりのRでは、上記の`if`文、`if else`文、`ifelse`関数、`switch`文しか使えませんが、**ライブラリ**というものを用いると、他の条件分岐（`if_else`関数や`case_which`文、`case_when`文）などを用いることもできます。詳細については[16章](./chapter16.html)で説明します。\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}