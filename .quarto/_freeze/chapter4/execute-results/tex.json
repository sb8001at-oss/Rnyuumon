{
  "hash": "c770c9b2ac9940400d945a187dfa1036",
  "result": {
    "markdown": "# 条件判断（Control structures）\n\n## 条件判断とは？\n\nプログラミングでは，ある条件のときはこの処理，別の条件のときはこの処理...，といった具合に，条件によって行う処理を変えたいことがよくあります．例えばじゃんけんが典型的な例です．じゃんけんでは，出した手の条件によって，勝ちと負けという2つの処理を行うことになります．このように，条件によって処理を変えることを，<font color=\"red\">**条件判断**</font>と呼びます．\n\n## 条件と真偽値（logical）\n\n条件として用いられるのは，<font color=\"red\">**真偽値（logical）**</font>です．真偽値はTRUE（真）とFALSE（偽）の2つの値を持ちます．真偽値はそれそのものを用いる場合と，比較演算子の演算結果として得る場合があります．Rでは，<font color=\"red\">**TRUEをT，FALSEをF**</font>と表記しても，真偽値を表すことになります．\n\n\n::: {.cell filename=''}\n\n```{.r .cell-code}\nTRUE\n## [1] TRUE\nFALSE\n## [1] FALSE\nT\n## [1] TRUE\nF\n## [1] FALSE\nc(T, F, T, F) # logicalはベクターにもできる\n## [1]  TRUE FALSE  TRUE FALSE\n1 < 3 # 3は1より大きいのでTRUE\n## [1] TRUE\n1 > 3 # 1は3より大きくないのでFALSE\n## [1] FALSE\n```\n:::\n\n\n## 数値としての真偽値\n\n真偽値は，Rの内部的には数字として取り扱われています．Rでは<font color=\"red\">**TRUEは1，FALSEは0**</font>と同一です．ですので，ベクター中のTRUEの数を足し算で計算することができます．逆に，**0がFALSE，0以外がTRUE**と同一として扱われる場合もあります．条件判断では0をFALSEの代わりに用いる場合もあります．\n\n> RではTRUEが1，FALSEが0ですが，他の言語ではFALSEが-1のものもあります．言語によりTRUE/FALSEの仕様は異なります．\n\n\n::: {.cell filename='数値としての真偽値'}\n\n```{.r .cell-code}\nT + T + F # 足し算すると2が返ってくる\n## [1] 2\nvec <- c(T, T, F, T, F, T, F)\nsum(vec) # sumはベクターの要素を足し算する関数\n## [1] 4\n```\n:::\n\n\n## 論理演算子\n\n真偽値は，<font color=\"red\">**論理演算子**</font>による計算に使うことができます．Rでの論理演算子は<font color=\"red\">**&，&&，\\|，\\|\\|**</font>の4つです．このうち，&&と\\|\\|は，ベクターの<font color=\"red\">**始めの値だけ**</font>を評価するという特徴を持っています（最近のRのバージョンでは警告が出ます）．&&と\\|\\|を用いるとプログラムが予想外の挙動を取ることがあるので，できるだけ&と\\|だけを用いたほうがよいでしょう．RにはNAND，XOR，NORなどを表す専用の論理演算子はありません．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：Rで使える論理演算子</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 論理演算子 </th>\n   <th style=\"text-align:left;\"> 演算子の意味 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> &amp; </td>\n   <td style=\"text-align:left;\"> 論理積（AかつB） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> &amp;&amp; </td>\n   <td style=\"text-align:left;\"> 論理積（ベクターの始めの要素のみ評価） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> | </td>\n   <td style=\"text-align:left;\"> 論理和（AまたはB） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> || </td>\n   <td style=\"text-align:left;\"> 論理和（ベクターの始めの要素のみ評価） </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ! </td>\n   <td style=\"text-align:left;\"> 否定演算子（真偽を反転） </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell filename=''}\n\n```{.r .cell-code}\nlogic1 <- c(T, F)\nlogic2 <- c(F, F)\nlogic1 & logic2 # & は論理積（AND）\n## [1] FALSE FALSE\n\nlogic1 | logic2 # | は論理和（OR）\n## [1]  TRUE FALSE\n\nlogic1 && logic2 # 1番目の項目同士のみを比較する\n## Error in logic1 && logic2: 'length = 2' in coercion to 'logical(1)'\n\nlogic1 || logic2\n## Error in logic1 || logic2: 'length = 2' in coercion to 'logical(1)'\n```\n:::\n\n\n論理演算子として，<font color=\"red\">**!（エクスクラメーションマーク，否定演算子）**</font>も用いることができます．!は真偽値の前に置くことで，真偽値を反転（TRUEをFALSEに，FALSEをTRUEに）させます．\n\n\n::: {.cell filename='!による論理値の反転'}\n\n```{.r .cell-code}\n!TRUE\n## [1] FALSE\n!FALSE\n## [1] TRUE\n\n!(1 < 3)\n## [1] FALSE\n!(1 > 3)\n## [1] TRUE\n```\n:::\n\n\n## 条件分岐の文\n\n上記のように，比較演算子や論理演算子を用いると，真偽値を得ることができます．この真偽値に従い，行う処理を変えるものを，<font color=\"red\">**条件分岐**</font>と呼びます．条件分岐では，条件分岐の文（Control structures）というものが用いられます．Rでは，条件分岐の文として，<font color=\"red\">**if文とswitch文**</font>の2つが設定されています．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表2：Rで使える条件分岐</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 条件分岐 </th>\n   <th style=\"text-align:left;\"> 条件分岐の形式 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> if文 </td>\n   <td style=\"text-align:left;\"> if(条件式){TRUEのときの演算}else{FALSEのときの演算} </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> ifelse関数 </td>\n   <td style=\"text-align:left;\"> ifelse(条件式, TRUEのときの演算, FALSEのときの演算) </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> switch文 </td>\n   <td style=\"text-align:left;\"> switch(評価する値, 評価の既定値=既定値のときの演算) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### if文\n\nif文は最もシンプルな条件分岐の文です．if文では，**条件式**に従い，実行する処理が変わります．Rでのif文は，以下の形を取ります．\n\n**if(条件式){TRUEのときに実施する処理}**\n\n条件式を<font color=\"red\">**if()**</font>のカッコの中に書きます．if文は1行で書くこともできますし，複数行に渡って書くこともできます．複数行に処理を書くときには，<font color=\"red\">**中括弧（{}）**</font>を条件式の後に書き，中括弧の中に処理を書きます．\n\n\n::: {.cell filename='if文の使い方'}\n\n```{.r .cell-code}\nif(TRUE) \"Hello R\" # 1行で書く場合（\"Hello R\"が返ってくる）\n## [1] \"Hello R\"\nif(FALSE) \"Hello FALSE\" # 条件式がFALSEなので，何も返ってこない\n\nif(TRUE){ # 複数行で書く時には中括弧（{}）を用いる\n  \"Hello R\"\n}\n## [1] \"Hello R\"\n\nif(FALSE){\"Hello FALSE\"} # 1行のif文で中括弧を使ってもよい\n```\n:::\n\n\nif文の条件が0のときには，0がFALSEと判断されて，処理が実行されません．一方で条件が0以外である場合には，TRUEであると判断されて処理が実行されます．if(0)とするとその処理が行われないので，**Rではif(0)がコメントや処理したくない部分を指定するときに使われる**こともあります．\n\n\n::: {.cell filename='条件式が数値の時のif文'}\n\n```{.r .cell-code}\nif(0){\"0はFALSEなので，これは表示されません\"}\n\nif(-1){\"-1はTRUE扱いなので，表示されます\"}\n## [1] \"-1はTRUE扱いなので，表示されます\"\n\nif(-0.005){\"0以外はTRUEとして処理されます\"}\n## [1] \"0以外はTRUEとして処理されます\"\n```\n:::\n\n\n#### if else文\n\nif文はさらに条件を分岐させることもできます．条件を追加する場合には，if文の後に，<font color=\"red\">**else()**</font>を繋げます．**else()**のカッコの中に2つ目の条件を書くことで，条件を分離させることができます．**else**だけを書いて，elseの条件式をつけない場合には，どの条件にも合わない時に実行する処理になります．ですので，if else文は以下の形を取ります．\n\n**if(条件式1){** **式1がTRUEのときの処理**\\\n**}else if(条件式2){**\\\n**式1がFALSE，式2がTRUEのときの処理**\\\n**}else{**\\\n**式1，2がFALSEのときの処理}**\n\n\n::: {.cell filename='if else文'}\n\n```{.r .cell-code}\nx <- 2 # xは2\n\n# xは2なので，2番目の処理が返ってくる\nif(x == 1){   # =が1つだと代入になるのでエラーが出る\n  \"first\"\n} else if(x == 2){\n  \"second\"\n} else {\n  \"others\"\n}\n## [1] \"second\"\n```\n:::\n\n\n#### ifelse関数\n\n条件分岐が2つしかない場合には，<font color=\"red\">**ifelse関数**</font>を用いることもできます．ifelse関数は3つの引数，「(条件式)，(TRUEのときの処理)，(FALSEのときの処理)」を取ります．条件が1つだけで，簡単な処理のみを行うのであればifelse関数で十分な場合もあります．\n\n\n::: {.cell filename='ifelse関数'}\n\n```{.r .cell-code}\n# TRUEなので2番目の処理が返ってくる\nifelse(1 < 3, \"one smaller than three\", \"one does not smaller than three\")\n## [1] \"one smaller than three\"\n\n# FALSEなので3番目の処理が返ってくる\nifelse(1 > 3, \"one larger than three\", \"one does not larger than three\") \n## [1] \"one does not larger than three\"\n```\n:::\n\n\n### switch文\n\n条件式ではなく，特定の値に対応して処理を変えたい場合には，<font color=\"red\">**switch文**</font>を用います．switch文では，**始めの引数が条件を指定する値，それに続く引数が条件に対応した処理**となります．条件を指定する値には，数値または文字列を用いることができます．条件が数値の場合と文字列の場合では，やや使い方が異なります．\n\n\n::: {.cell filename='switch文（条件が数値のとき）'}\n\n```{.r .cell-code}\n# 条件が1のときは，2番目の引数の処理が返ってくる\nswitch(1, \"first\", \"second\", \"third\") \n## [1] \"first\"\n\n# 条件が2のときは，3番目の引数の処理が返ってくる\nswitch(2, \"first\", \"second\", \"third\") \n## [1] \"second\"\n\n# 条件が5のときは，6番目の引数の処理がないので何も返ってこない\nswitch(5, \"first\", \"second\", \"third\") \n```\n:::\n\n::: {.cell filename='switch文（条件が文字列のとき）'}\n\n```{.r .cell-code}\n# 条件式に対応したもの（=で繋いだもの）が返ってくる\nswitch(\"dog\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n## [1] \"犬\"\n\nswitch(\"monkey\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n## [1] \"猿\"\n\n# horseは引数に登録していないので，何も返ってこない\nswitch(\"horse\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n```\n:::\n\n\n> インストールしたばかりのRでは，上記のif文，if else文，ifelse関数，switch文しか使えませんが，**ライブラリ**というものを用いると，他の条件分岐（if_else関数やcase_when文）などを用いることもできます．詳細については他の章で説明します．\n",
    "supporting": [
      "chapter4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}