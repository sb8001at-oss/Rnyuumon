{
  "hash": "034da9b4bc72c613f38b29c8ad4fa163",
  "result": {
    "markdown": "# 文字列\n\n多くのプログラミング言語では，文字列（character）の取り扱いが重要視されています．住所や氏名は文字列ですし，電話番号も通常は数値というより文字列のような取り扱いを受けます．フォルダの位置（ディレクトリ）やウェブページ（html）なども文字列で構築されています．Rは統計の言語ですので，文字列には数値ほど色々な関数は実装されていませんが，Rにも基本的な文字列処理の関数は備わっています．現代では文字列を統計で取り扱う機会も増えていますので（生成AIや[Word2Vec](https://ja.wikipedia.org/wiki/Word2vec)など），文字列の取り扱いは統計において重要性を増してきています．\n\n## 文字列を取り扱う関数\n\n### 文字列の結合：pasteとpaste0関数\n\nRには文字列を取り扱う関数が一通り備わっています．まずは**paste関数**について紹介します．paste関数は引数の文字列をつないで，1つの文字列にする関数です．各引数の文字列をつなぐ部分には，sep引数で指定した文字列が入ります．paste関数では，sepのデフォルトがスペースとなっているので，sepを設定しなければスペースが自動的に文字列間に入ります．**paste0関数**ではsepが空，つまり文字列のつなぎには何も入力されない形となります．\n\n\n::: {.cell filename='文字列をつなぐ'}\n\n```{.r .cell-code}\npaste(\"A dog\", \"is running\") # 引数同士をスペースを挟んでつなぐ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is running\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"A\", \"dog\", \"is\", \"running\") # 引数は2つ以上でもよい\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is running\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"A dog\", \"is running\", sep=\"/\") # sepに指定した文字が引数の間に入る\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog/is running\"\n```\n:::\n\n```{.r .cell-code}\npaste0(\"A dog\", \"is running\") # sepに何も追加したくない場合\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dogis running\"\n```\n:::\n:::\n\n\n### 文字数をカウントする：nchar\n\n文字数をカウントする関数が**nchar関数**です．nchar関数は引数に取った文字列の文字数を返します．type引数を指定すると，文字列のバイト数や文字幅を求める事もできます．\n\n\n::: {.cell filename='文字数を数える'}\n\n```{.r .cell-code}\nnchar(\"Hello R\") # スペースを含めて7文字\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nx <- c(\"A dog is running\", \"A cat is running\")\nnchar(x) # ベクターの要素それぞれについて計算\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16 16\n```\n:::\n\n```{.r .cell-code}\nnchar(\"日本語\") # 日本語でも文字列はカウントされる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnchar(\"日本語\", type=\"bytes\") # バイト数は3倍\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nnchar(\"日本語\", type=\"width\") # 等角文字は半角文字の2倍幅\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\n### 文字列から一部抜き出す：substr\n\n文字列の一部を抜き出す関数が**substr関数**です．文字列のうち，startで指定した位置の文字からstopで指定した位置の文字までを返します．位置の指定はインデックスと同じで，1文字目が1，2文字目が2，という形を取ります．substr関数によく似た**substring関数**もほぼ同じ機能を持ちますが，引数名がfirstとlastになっており，lastのデフォルト値がとても大きく(1000000L) なっています．ですので，firstだけ指定し，それ以降の文字列を返す形で利用するものになっています．\n\n\n::: {.cell filename='文字列の抜き出し'}\n\n```{.r .cell-code}\nsubstr(x, start = 3, stop = 5) # xの3文字目から5文字目\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" \"cat\"\n```\n:::\n\n```{.r .cell-code}\nsubstring(x, 3) # 3文字目以降を取得\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog is running\" \"cat is running\"\n```\n:::\n:::\n\n\n### 文字列を分割する：strsplit\n\n**strsplit関数**は，文字列をある特定の文字で分割し，リストの要素として返す関数です．文字は1文字でも，複数の文字でも問題ありません．\n\n\n::: {.cell filename='文字列の分割'}\n\n```{.r .cell-code}\nstrsplit(x, \" \") # スペースで分離。リストが返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"A\"       \"dog\"     \"is\"      \"running\"\n\n[[2]]\n[1] \"A\"       \"cat\"     \"is\"      \"running\"\n```\n:::\n\n```{.r .cell-code}\nstrsplit(x, \"i\") # i で分離\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"A dog \" \"s runn\" \"ng\"    \n\n[[2]]\n[1] \"A cat \" \"s runn\" \"ng\"    \n```\n:::\n:::\n\n\n### パターンにあう位置を調べる：grepとmatch\n\n文字列が一定のパターン（例えば英単語など）を含むかどうかを調べるのが，**grep関数**と**match関数**です．\n\ngrep関数は文字列のベクターに適用し，パターンを含むインデックスを返します．ベクターの要素がパターンを含まない場合には，長さ0のベクター（integer(0)）が返ってきます．\n\nmatch関数は，パターンが全部一致する要素のみのインデックスを返す関数です．一部が一致する場合にはインデックスは返ってきません．どの要素にも全部一致するものがなければ，NAが返ってきます．パターンが部分一致する場合にインデックスを返すのが**pmatch関数**です．pmatch関数では，パターンが部分一致する要素が複数あるとNAが返ってきます．\n\n\n::: {.cell filename='パターンに一致するものを調べる'}\n\n```{.r .cell-code}\ngrep(pattern = \"dog\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ngrep(pattern = \"cat\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\ngrep(pattern = \"is\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\ngrep(pattern = \"rat\", x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n\n```{.r .cell-code}\nmatch(\"median\",   c(\"mean\", \"median\", \"mode\")) # 全文マッチするベクターの位置を返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nmatch(\"med\",   c(\"mean\", \"median\", \"mode\")) # 一部マッチではNA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\npmatch(\"mo\",   c(\"mean\", \"median\", \"mode\")) # 一部マッチするベクターの位置を返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\npmatch(\"me\",   c(\"mean\", \"median\", \"mode\")) # マッチするものが2つ以上あるとNA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n### 文字列の置き換え：subとgsub\n\n文字列の中で，パターンが一致したものを別のパターンに置き換えるのが，**sub関数，gsub関数**です．sub関数，gsub関数は引数として，パターン（pattern），置き換える文字列（replacement），文字列のベクターを取ります．sub関数が文字列のうち，前からサーチして一番始めのパターンのみを置き換えるのに対して，gsub関数はパターンが一致した部分をすべて置き換えるものとなっています．gsub関数と同じような働きを持つchartr関数というものもあります．\n\n\n::: {.cell filename='文字列の置き換え'}\n\n```{.r .cell-code}\nsub(pattern = \"n\", replacement = \"N\", x) # 始めの要素だけ置き換え\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is ruNning\" \"A cat is ruNning\"\n```\n:::\n\n```{.r .cell-code}\ngsub(pattern = \"n\", replacement = \"N\", x) # すべて置き換え\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is ruNNiNg\" \"A cat is ruNNiNg\"\n```\n:::\n\n```{.r .cell-code}\nchartr(\"n\", \"N\", x) # 上のgsub関数と同じ結果\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is ruNNiNg\" \"A cat is ruNNiNg\"\n```\n:::\n:::\n\n\n### 小文字，大文字に変換：tolower toupper\n\n文字列を小文字に置き換えるのが**tolower関数**，大文字に置き換えるのが**toupper関数**です．\n\n\n::: {.cell filename='小文字・大文字の変換'}\n\n```{.r .cell-code}\ntolower(\"A CAT IS RUNNING\") # 小文字に変換\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a cat is running\"\n```\n:::\n\n```{.r .cell-code}\ntoupper(x) # 大文字に変換\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A DOG IS RUNNING\" \"A CAT IS RUNNING\"\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：Rの文字列に関する関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 文字列xに適用される演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> paste(x, y, sep = z) </td>\n   <td style=\"text-align:left;\"> xとyをzを挟んで結合 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> paste0(x, y) </td>\n   <td style=\"text-align:left;\"> xとyを何も挟まず結合 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> nchar(x) </td>\n   <td style=\"text-align:left;\"> xの文字数をカウントする </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> substr(x, start, stop) </td>\n   <td style=\"text-align:left;\"> xから文字を切り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> substring(x, y) </td>\n   <td style=\"text-align:left;\"> xのy文字目以降を切り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> strsplit(x, pattern) </td>\n   <td style=\"text-align:left;\"> xをpatternで分割する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> grep(pattern, x) </td>\n   <td style=\"text-align:left;\"> patternを含むxのインデックスを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> match(pattern, x) </td>\n   <td style=\"text-align:left;\"> pattern全文を含む要素のインデックスを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> pmatch(pattern, x) </td>\n   <td style=\"text-align:left;\"> patternを一部含む要素のインデックスを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> sub(x, pattern, replacement) </td>\n   <td style=\"text-align:left;\"> 始めに一致するpatternをreplacementに置き換える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> gsub(x, pattern, replacement) </td>\n   <td style=\"text-align:left;\"> patternをreplacementにすべて置き換える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> chartr(old, new, x) </td>\n   <td style=\"text-align:left;\"> oldをnewにすべて置き換える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tolower(x) </td>\n   <td style=\"text-align:left;\"> 大文字を小文字に変換 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> toupper(x) </td>\n   <td style=\"text-align:left;\"> 小文字を大文字に変換 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## stringr\n\nRのデフォルトの文字列関連の関数だけでも色々な文字列の操作ができますが，名前に統一感がなく，返ってくるものがリストだったりするものもあり，なかなか覚えにくく，使いにくいところがあります．\n\nこの使いにくさを解消し，統一感のある関数名を付けたライブラリが<font color=\"red\">[**stringr**](https://stringr.tidyverse.org/)</font>です．stringrには文字列を操作する関数が40程度登録されており，ほぼいずれの関数も「str\\_」から名前が始まります．Rstudioでは，「str\\_」と入力すると入力候補と入力候補の説明文が示されるため，比較的簡単に関数を検索し，利用することができます．文字列を取り扱う場合にRのデフォルトの関数群を用いても特に問題はありませんが，stringrの関数群を用いると返り値の利便性や速度に利点があります．\n\nstringrは**tidyverse**に含まれるライブラリです．stringrのインストール，ロードにはpacman::p_load関数を用います．\n\n\n::: {.cell filename='stringrのインストールおよびロード'}\n\n```{.r .cell-code}\npacman::p_load(tidyverse) # あらかじめpacmanのインストールが必要\n```\n:::\n\n\n以下に，stringrの代表的な関数の使い方を示します．\n\n> stringrは[stringi](https://stringi.gagolewski.com/)というライブラリのラッパー（wrapper）です．ラッパーとは既存の関数の名前や引数の順序を統一したり，使用頻度の高い関数を選んだり，部分的に機能を追加することで利用しやすくしたものです．stringiはC言語由来の文字列処理を取り込んでいるため，Rのデフォルトの関数よりも計算が速いという特徴があります．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表2：stringrの関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 文字列xに適用される演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> str_detect(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternがあるとTRUEを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_which(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternを含むインデックスを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_locate(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternの位置を調べる </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_locate_all(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternの位置をすべて調べる </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_count(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternが含まれる数を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_length(x) </td>\n   <td style=\"text-align:left;\"> 文字数を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_trim(x) </td>\n   <td style=\"text-align:left;\"> xの前後のスペースを取り除く </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_trunc(x, width) </td>\n   <td style=\"text-align:left;\"> xをwidthの長さに省略する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_sub(x, start, end) </td>\n   <td style=\"text-align:left;\"> startからendの位置までの文字列を取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_subset(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternを含む要素を取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_extract(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternを取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_extract_all(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternをすべて取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_match(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternを行列で取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_match_all(x, pattern) </td>\n   <td style=\"text-align:left;\"> patternを行列ですべて取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_c(x, y, sep) </td>\n   <td style=\"text-align:left;\"> xとyをsepを挟んで結合する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_flatten(x, y, collapse) </td>\n   <td style=\"text-align:left;\"> xとyをcollapseを挟んで結合する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_split(x, pattern) </td>\n   <td style=\"text-align:left;\"> xをpatternで分割する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_split_fixed(x, pattern, n) </td>\n   <td style=\"text-align:left;\"> xをpatternでn個に分割する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_split_i(x, pattern, i) </td>\n   <td style=\"text-align:left;\"> xをpatternで分割し，i番目の要素を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_replace(x, pattern, replacement) </td>\n   <td style=\"text-align:left;\"> 始めに一致するpatternをreplacementに置き換える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_replace_all(x, pattern, replacement) </td>\n   <td style=\"text-align:left;\"> patternをreplacementにすべて置き換える </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_to_lower(x) </td>\n   <td style=\"text-align:left;\"> 大文字を小文字に変換する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str_to_upper(x) </td>\n   <td style=\"text-align:left;\"> 小文字を大文字に変換する </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n### stringr パターンの検出：str_detect\n\n**str_detect関数**はパターンを検索し，真偽値を返す関数です．ベクターを引数にした場合には，パターンが含まれる要素はTRUE，含まれない要素はFALSEとして返ってきます．\n\n\n::: {.cell filename='パターンの検出'}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is running\" \"A cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_detect(x, \"dog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n:::\n\n\n### stringr パターンの検出：str_which\n\n**str_which関数**は上記のgrep関数と同じく，パターンに一致するベクターのインデックスを返す関数です．複数の要素が一致する場合には，すべてのインデックスを返します．\n\n\n::: {.cell filename='パターンを検出する：str_which関数'}\n\n```{.r .cell-code}\nstr_which(x, \"dog\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nstr_which(x, \"cat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nstr_which(x, \"is\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n:::\n\n\n### stringr パターンの位置を調べる：str_locate\n\nもっと厳密に，そのパターンが存在する文字列上の位置を特定するための関数が**str_locate関数**です．str_locate関数は行列，もしくは行列のリストを返します．行列のstart列がパターンの開始位置，endが終了位置を示します．パターンが複数含まれる場合には，行列のリストが返ってきます．\n\n\n::: {.cell filename='パターンの位置を返す：str_locate関数'}\n\n```{.r .cell-code}\nstr_locate(x, \"dog\") # 1つ目の要素のみにパターンが含まれる時\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     start end\n[1,]     3   5\n[2,]    NA  NA\n```\n:::\n\n```{.r .cell-code}\nstr_locate_all(x, \"n\") # 2つの要素にパターンが複数含まれる時\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     start end\n[1,]    12  12\n[2,]    13  13\n[3,]    15  15\n\n[[2]]\n     start end\n[1,]    12  12\n[2,]    13  13\n[3,]    15  15\n```\n:::\n:::\n\n\n### stringr パターンが含まれる数を数える：str_count\n\nパターンが何回含まれるかを数える関数が**str_count関数**です．パターンが含まれていればそのパターンの個数を，含まれていれば0を返します．\n\n\n::: {.cell filename='パターンの個数を数える：str_count関数'}\n\n```{.r .cell-code}\nstr_count(x, \"dog\") # 1つ目の要素に1つだけパターンが含まれる場合\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0\n```\n:::\n\n```{.r .cell-code}\nstr_count(x, \"n\") # 2つの要素に3つずつパターンが含まれる場合\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n\n### stringr 文字数を数える：str_length\n\n**str_length関数**はnchar関数と同じく，文字数を返す関数です．どちらを使っても結果は同じですが，他の言語では文字数を数える関数に「length」関数を当てることが多いため，str_lengthの方が直感的に使い方がわかりやすい名前になっています．\n\n\n::: {.cell filename='文字数をカウントする：str_length関数'}\n\n```{.r .cell-code}\nstr_length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16 16\n```\n:::\n\n```{.r .cell-code}\nnchar(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16 16\n```\n:::\n:::\n\n\n### stringr 文字列を整える：str_trim str_trunc\n\n**str_trim関数**は文字列の前と後ろのスペースを取り除く関数です．文字列の演算では，スペースが前後に残って邪魔になることがよくあります．このような場合にはstr_trimでスペースを取り除き，形を整えることができます．\n\n**str_trunc関数**は，文字列の前や後ろを切り取り，「...」で置き換えて省略してくれる関数です．長い文字列をラベル等に用いるときに使用します．\n\n\n::: {.cell filename='文字列を整形する：str_trim, str_trunc関数'}\n\n```{.r .cell-code}\nstr_trim(\" x \") # スペースを取り除く\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x\"\n```\n:::\n\n```{.r .cell-code}\nstr_trunc(x, 12) # 後ろを切り取って...で省略\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is ...\" \"A cat is ...\"\n```\n:::\n\n```{.r .cell-code}\nstr_trunc(x, 12, side=\"left\") # 前を切り取って...で省略\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"...s running\" \"...s running\"\n```\n:::\n:::\n\n\n### stringr 文字を切り出す：str_sub str_subset\n\n**str_sub関数**はsubstr関数とほぼ同じ働きを持つ関数で，startの位置からendの位置までの文字列を抜き出します．\n\n**str_subset関数**はやや異なり，パターンを含むベクターの要素のみを取り出す関数です．\n\n\n::: {.cell filename='パターンを含む文字列を取り出す：str_sub，str_subset関数'}\n\n```{.r .cell-code}\nstr_sub(x, start=3, end=5) # 位置を特定して抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" \"cat\"\n```\n:::\n\n```{.r .cell-code}\nstr_subset(x, \"cat\") # 文字を含む要素を抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_subset(x, \"is\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is running\" \"A cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_subset(x, \"rat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n\n### stringr 文字列を抽出する：str_extract\n\n**str_extract関数**は，パターンがマッチしたときに，そのパターンを返す関数です．パターンに一致する部分がない場合には，NAを返します．str_extract関数はマッチした始めのパターンのみを返し，**str_extract_all関数**はマッチしたパターンをすべて返します．str_extract_all関数の返り値はリストになります．\n\n\n::: {.cell filename='パターンを抽出する：str_extract関数'}\n\n```{.r .cell-code}\nstr_extract(x, \"is\") # 特定の文字列を抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"is\" \"is\"\n```\n:::\n\n```{.r .cell-code}\nstr_extract(x, \"dog\") # 抽出できないとNAを返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" NA   \n```\n:::\n\n```{.r .cell-code}\nstr_extract_all(x, \"n\") # パターン一致するものをすべて抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"n\" \"n\" \"n\"\n\n[[2]]\n[1] \"n\" \"n\" \"n\"\n```\n:::\n:::\n\n\n### strngr パターンマッチング：str_match\n\n**str_match関数**も一致したパターンを返す関数です．str_match関数は始めにマッチしたパターンを行列で返し，str_match_all関数はマッチしたすべてのパターンを行列のリストで返します．\n\n\n::: {.cell filename='マッチしたパターンを返す：str_match関数'}\n\n```{.r .cell-code}\nstr_match(x, \"dog\") # パターンがあれば、そのパターンを返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] \n[1,] \"dog\"\n[2,] NA   \n```\n:::\n\n```{.r .cell-code}\nstr_match_all(x, \"n\") # パターンがあれば、それをすべて返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     [,1]\n[1,] \"n\" \n[2,] \"n\" \n[3,] \"n\" \n\n[[2]]\n     [,1]\n[1,] \"n\" \n[2,] \"n\" \n[3,] \"n\" \n```\n:::\n:::\n\n\n### 文字列をつなぐ：str_c str_flatten\n\n**str_c関数**と**str_flatten関数**はいずれも文字列をつなぐ関数です．ともにpaste関数とpaste0関数とほぼ同じですが，NAの取り扱いが少しだけ異なります．\n\n\n::: {.cell filename='文字列をつなぐ：str_c関数'}\n\n```{.r .cell-code}\nstr_c(x[1], x[2]) # paste0と同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is runningA cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(x[1], x[2], sep=\" \") # pasteと同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is running A cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_flatten(c(\"a\", \"dog\", \"is\", \"running\")) # paste0と同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"adogisrunning\"\n```\n:::\n\n```{.r .cell-code}\nstr_flatten(c(\"a\", \"dog\", \"is\", \"running\"), collapse= \" \") # pasteと同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a dog is running\"\n```\n:::\n:::\n\n\n### stringr 文字列を分割する：str_split str_split_fixed str_split_i\n\n**str_split関数**はパターンで文字列を分割する関数で，strsplit関数とほぼ同じ機能を持ちます．\n\n**str_split_fixed**はパターンで分割するときに，分割後の要素の数を指定することができる関数です．\n\n**str_split_i関数**は，パターンで分割した後に，数値で指定したインデックスの要素のみを取り出す関数です．\n\n\n::: {.cell filename='文字列を分割する：str_split関数'}\n\n```{.r .cell-code}\nstr_split(x, \" \") # パターンで分割\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"A\"       \"dog\"     \"is\"      \"running\"\n\n[[2]]\n[1] \"A\"       \"cat\"     \"is\"      \"running\"\n```\n:::\n\n```{.r .cell-code}\nstr_split_fixed(x, \" \", 2) # 始めのパターンで2つに分割\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]            \n[1,] \"A\"  \"dog is running\"\n[2,] \"A\"  \"cat is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_split_i(x, \" \", 2) # パターンで分割し、2つ目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" \"cat\"\n```\n:::\n:::\n\n\n### stringr 文字列を置き換える：str_replace str_replace_all\n\nstr_replace関数は文字列のパターンを別の文字列に置き換える関数です．sub関数とほぼ同等の機能を持ちます．str_replace_all関数はgsub関数とほぼ同じで，str_replace関数が始めにマッチしたパターンのみを置き換えるのに対し，str_replace_all関数はマッチしたパターンをすべて置き換えます．\n\n\n::: {.cell filename='文字列を置き換える：str_replace関数'}\n\n```{.r .cell-code}\nstr_replace(x, \"running\", \"walking\") # 前のパターンを後ろの文字列に置き換える\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A dog is walking\" \"A cat is walking\"\n```\n:::\n\n```{.r .cell-code}\nstr_replace_all(x, \" \", \",\") # 前のパターンをすべて、後ろの文字列に置き換える\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A,dog,is,running\" \"A,cat,is,running\"\n```\n:::\n:::\n\n\n### str_to_lower str_to_upper\n\n**str_to_lower関数**は大文字を小文字に，**str_to_upper関数**は小文字を大文字に変換する関数です．どちらもtolower関数，toupper関数とほぼ同等の機能を持ちます．str_to_lower，str_to_upper関数は言語による小文字・大文字の違いによる変換に対応していますが，日本人がこの機能を使うことはほぼ無いでしょう．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_lower(\"A DOG IS RUNNING\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a dog is running\"\n```\n:::\n\n```{.r .cell-code}\nstr_to_upper(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A DOG IS RUNNING\" \"A CAT IS RUNNING\"\n```\n:::\n:::\n\n\n## 正規表現\n",
    "supporting": [
      "chapter9_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}