{
  "hash": "9cceb432f49eb26cf98c8c8a81b76696",
  "result": {
    "engine": "knitr",
    "markdown": "# 分類\n\nデータがどのような群に分類されるのか評価・予測する**分類**は、検定・回帰と並ぶ統計・機械学習の重要な手法の一つです。分類は**教師あり学習**、**教師なし学習**に大きく二分することができます。\n\n**教師あり学習**とは、今までに取得されたデータ（**訓練データ**）を用いて分類を行うアルゴリズム（**分類器（classifier）**）を作成し、このアルゴリズムを利用して新たに取得されたデータの分類を行う方法を指します。回帰によるデータ予測も、訓練データの回帰による予測を行うことから、教師あり学習に該当します。一般的に機械学習において分類とされるのは、この教師あり学習の分類です。教師あり学習の分類についてこの章で説明していきます。\n\n**教師なし学習**とは、これまでに取れたデータをすべて用いて、似ているデータごとに群として分けるような手法です。教師なし学習では、訓練データと予測を行うデータを明確に分けることはありません。教師なし学習による群分けには、**次元圧縮**と**クラスタリング**があります。教師なし学習については[次の章](./chapter28.html)で詳しく解説します。\n\n![](./image/classification_category1.png)\n\n\n\n\n\n## サポートベクターマシン\n\n**サポートベクターマシン（support vector machine、SVM）**はデータの境界線をうまく回帰し、その線を分類に用いる手法です。SVMでは、データの境界線に平行で、かつ2つの群のデータに接する平行線を引き（下図左の赤線）、この平行線の幅（下図右の青線の長さ）が最大となるような境界線を求めます。\n\nただし、実際のデータでは群のデータが混じっていて、線形で分離できないようなこともあるため、ペナルティ等をもう少し複雑な形で与えて境界線を計算することになります。\n\n![図2：SVMのイメージ（左：点と接する平行線（赤線）、右：平行線の幅（青線））](./image/image_svm.png)\n\nRでは、サポートベクターマシンを含めた色々な機械学習の手法が[e1071](https://cran.r-project.org/web/packages/e1071/index.html)パッケージ [@e1071_bib]により提供されています。\n\n\n::: {.cell filename='SVM：e1071ライブラリの読み込み'}\n\n```{.r .cell-code}\npacman::p_load(e1071)\n```\n:::\n\n\n### 訓練データとテストデータ\n\n教師あり学習の機械学習を用いる場合には、まずデータを**訓練データ**と**テストデータ**に分けるのが一般的です。これは[前章](./chapter26.html)の部分的最小二乗回帰（PLS）の項で説明したものと同じです。\n\n訓練データとテストデータを分ける場合には、`sample`関数を利用してランダムにデータの行を選ぶのが一般的です。\n\n\n::: {.cell filename='訓練データとテストデータに分ける'}\n\n```{.r .cell-code}\nset.seed(0)\ntest_v <- sample(nrow(iris), 25, replace=F) # ランダムに行を選ぶ \ntest_v <- test_v[order(test_v)]\ntest_v # テストデータにする行\n##  [1]   7  14  21  33  34  35  37  43  51  68  70  73  74  79  84  85  89 105 106\n## [20] 110 126 129 141 142 150\n\ntrain.iris <- iris[-test_v, -3:-4] # 訓練データ（125行）\ntest.iris <- iris[test_v, -3:-4] # テストデータ（25行）\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## tidymodelsパッケージでのデータ準備\n\n機械学習のデータを取り扱いやすくするためのパッケージである[tidymodels](https://www.tidymodels.org/)  [@tidymodels_bib]には、データを訓練データとテストデータに分ける専用の関数が準備されています。`tidymodels`の使い方にはやや癖があり、学習コストが高めですが、覚えれば様々な機械学習をより簡単に実装できるようになります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidymodels)\n\niris_split <- initial_split(iris, prop = 125/150) # 分け方を指定\ntrain.iris2 <- training(iris_split) # 訓練データ（125行）\ntest.iris2 <- testing(iris_split) # テストデータ（25行）\n\ndim(train.iris2) # 125行のデータフレーム\n## [1] 125   5\n\ndim(test.iris2) # 25行のデータフレーム\n## [1] 25  5\n```\n:::\n\n\n:::\n\nRでサボートベクターマシンを実行する場合には、`e1071`パッケージの`svm`関数を用います。`svm`関数の使い方は`lm`とよく似ていて、目的とする分類（因子）を目的変数とした`formula`と、データフレーム（`data`）の2つを引数に取ります。以下の例では、`iris`データを用いて、アヤメの種（`Species`）を予測する分類モデルを訓練データを用いてサポートベクターマシンで作成しています。\n\n\n::: {.cell filename='svm関数で分類器を準備する'}\n\n```{.r .cell-code}\n# 訓練データでサポートベクターマシンを計算（.は目的変数以外の変数すべてを指す）\nmodel.g <- svm(Species ~ ., data = train.iris) # デフォルトはガウスカーネル\n```\n:::\n\n\nサポートベクターマシンは予測を行うための分類器ですので、計算結果をそのまま用いてもあまり意味がありません。`svm`関数の返り値を用いて、テストデータの分類を予測する場合には、`predict`関数を用います。\n\n以下のように、テストデータと、テストデータから`predict`関数で予測した値を比較すると、少し間違いはありますが、概ね正しい`Species`が予測されていることがわかります。予測には`iris`の1行目と2行目しか用いていないため精度が低めですが、もっと多くの説明変数を用いれば分類の精度をもう少し上げることもできます。\n\n\n::: {.cell filename='SVMでテストデータを用いて予測する'}\n\n```{.r .cell-code}\n# predict関数で予測結果を求める\npred_svm <- predict(model.g, test.iris)\n\n# 実際の種と予測した種を比較する（上が実際のデータ、下が予測）\ndata.frame(test.iris$Species, pred_svm) |> t()\n##                   7        14       21       33       34       35      \n## test.iris.Species \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n## pred_svm          \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n##                   37       43       51           68           70          \n## test.iris.Species \"setosa\" \"setosa\" \"versicolor\" \"versicolor\" \"versicolor\"\n## pred_svm          \"setosa\" \"setosa\" \"virginica\"  \"versicolor\" \"versicolor\"\n##                   73           74           79           84          \n## test.iris.Species \"versicolor\" \"versicolor\" \"versicolor\" \"versicolor\"\n## pred_svm          \"virginica\"  \"versicolor\" \"versicolor\" \"versicolor\"\n##                   85           89           105         106         110        \n## test.iris.Species \"versicolor\" \"versicolor\" \"virginica\" \"virginica\" \"virginica\"\n## pred_svm          \"versicolor\" \"versicolor\" \"virginica\" \"virginica\" \"virginica\"\n##                   126         129         141         142         150         \n## test.iris.Species \"virginica\" \"virginica\" \"virginica\" \"virginica\" \"virginica\" \n## pred_svm          \"virginica\" \"virginica\" \"virginica\" \"virginica\" \"versicolor\"\n```\n:::\n\n\n### カーネル変換サポートベクターマシン\n\nサポートベクターマシンの基本は図2に示したように、直線で群を分ける方法です。しかし、データによっては群を直線では分けられない場合もあります。このような場合に、SVMでは**カーネル変換**というものを利用して、群を曲線的に分けることができるようにしています。\n\nRの`svm`関数では、このカーネル変換の手法として、ガウスカーネル（`kernel=\"radial\"`、デフォルトのカーネル）、直線（`kernel=\"linear\"`）、多項式カーネル（`kernel=\"polynomial\"`）、シグモイドカーネル（`kernel=\"sigmoid\"`）の4種類を用いることができます。カーネルの種類は`kernel`引数で指定します。\n\nカーネルの選び方によってSVMの予測精度が変化します。`train.iris`を用いた下記の例では直線カーネルでの精度が高くなっていることがわかります。\n\n\n::: {.cell filename='カーネル変換SVM'}\n\n```{.r .cell-code}\n# カーネルごとの違いを調べる\nmodel.l <- svm(Species ~ ., data = train.iris, kernel = \"linear\") # 直線\nmodel.p <- svm(Species ~ ., data = train.iris, kernel = \"polynomial\") # 多項式\nmodel.s <- svm(Species ~ ., data = train.iris, kernel = \"sigmoid\") # シグモイド\n\n# 正答率\nd.test <- data.frame(\n  type = c(\"ガウス\", \"直線\", \"多項式\", \"シグモイド\"),\n  accuracy = c(\n    sum(predict(model.g, test.iris) == test.iris$Species) / 25,\n    sum(predict(model.l, test.iris) == test.iris$Species) / 25,\n    sum(predict(model.p, test.iris) == test.iris$Species) / 25,\n    sum(predict(model.s, test.iris) == test.iris$Species) / 25\n  )\n)\n\nknitr::kable(d.test)\n```\n\n::: {.cell-output-display}\n\n\n|type       | accuracy|\n|:----------|--------:|\n|ガウス     |     0.88|\n|直線       |     0.92|\n|多項式     |     0.76|\n|シグモイド |     0.88|\n\n\n:::\n:::\n\n\n各カーネルでの分類の境界線を示したものが、以下のグラフとなります。直線カーネルのみ分類の境界が直線で、その他のカーネル（ガウス、多項式、シグモイド）では分類の境界が曲線となっていることがわかります。\n\n:::{.callout-tip collapse=\"true\"}\n\n## 作図のスクリプト\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 分類の境界線を表示\nd.mat <- expand.grid(\n  Sepal.Length = seq(min(iris$Sepal.Length), max(iris$Sepal.Length), by = 0.01), \n  Sepal.Width = seq(min(iris$Sepal.Width), max(iris$Sepal.Width), by = 0.01))\n\nd.mat.g <- cbind(d.mat, Species = predict(model.g, d.mat))\nd.mat.l <- cbind(d.mat, Species = predict(model.l, d.mat))\nd.mat.p <- cbind(d.mat, Species = predict(model.p, d.mat))\nd.mat.s <- cbind(d.mat, Species = predict(model.s, d.mat))\n\npg <- ggplot() +\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(\n    data = d.mat.g,\n    aes(x = Sepal.Length, y = Sepal.Width, fill = Species),\n    alpha = 0.2\n  ) +\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"ガウスカーネル\")\npl <- ggplot() +\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(\n    data = d.mat.l,\n    aes(x = Sepal.Length, y = Sepal.Width, fill = Species),\n    alpha = 0.2\n  ) +\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"直線カーネル\")\npp <- ggplot() +\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(\n    data = d.mat.p,\n    aes(x = Sepal.Length, y = Sepal.Width, fill = Species),\n    alpha = 0.2\n  ) +\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"多項式カーネル\")\nps <- ggplot() +\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(\n    data = d.mat.s,\n    aes(x = Sepal.Length, y = Sepal.Width, fill = Species),\n    alpha = 0.2\n  ) +\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"シグモイドカーネル\")\n\ngrid.arrange(pg, pl, pp, ps)\n```\n:::\n\n\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## カーネル変換\n\nカーネル変換とは、データの写像というものを利用し、元来直線的には分類できないようなデータを写像上で直線的に分類できるようにする手法のことです。写像のイメージとしては、2次元のデータに1次元足して3次元にしているようなものだと思って頂ければよいかと思います。2次元で分離できないものも、1次元追加することで直線（面）で分類できるようになります。この写像の計算の仕方が`kernel`引数で指定しているものとなります。\n\n:::\n\n## ナイーブベイズ\n\n**ナイーブベイズ**は、古くからMicrosoftのメーラーであるOutlookなどで迷惑メール（Spam）を通常のメール（Ham）と分類するのに用いられてきた分類器です。ナイーブベイズでは、メール文に含まれる文字列（単語など）に対して、学習から得られた各単語がSpamに含まれる確率とHamに含まれる確率を掛け算して、そのメール文がSpamである確率とHamである確率を計算します。Spamである確率がHamである確率より高ければSpam、そうでなければHamと判断します。\n\nナイーブベイズでは上記の通り、単語がSpamに含まれる確率とHamに含まれる確率をあらかじめ学習する必要があります。ですので、Ham/Spamであることが判別しているメール文が学習データとして必要となります。\n\nRでナイーブベイズを用いる場合には、`e1071`パッケージの`naiveBayes`関数を用います。\n\n以下にRでSpamとHamを見分ける場合のナイーブベイズのスクリプトを記載します。メールのデータには、[Githubで提供されているHam/Spamメールのデータセット](https://github.com/stedy/Machine-Learning-with-R-datasets/blob/master/sms_spam.csv)を用いています。\n\n:::{.callout-tip collapse=\"true\"}\n\n## 文字列を処理する\n\nナイーブベイズに限らず、文字列を訓練データとした機械学習は増えています。ChatGPTなどのAIも、入力した文書を分類器などのアルゴリズムに代入し、予測値として回答を返す形となっていると思われます。ただし、文字列には余計な文字（例えばスペースや記号、日本語のような粘着語では助詞など）がたくさん含まれており、そのまま分類器に与えることはできません。\n\nですので、文字列を用いた機械学習を行う際には、文字列を取り扱うための専用のライブラリやソフトウェアを用いて文字列の前処理を行う必要があります。\n\n今回の例のように英語であれば、Rのパッケージ（以下に示す[tm](https://cran.r-project.org/web/packages/tm/index.html) [@tm_bib]や[SnowballC](https://cran.r-project.org/web/packages/SnowballC/index.html) [@SnowballC_bib]など）を用いて文字列をコーパス（単語のまとまり）にまとめたり、そのコーパスの数を数えたりすることができます。日本語であれば、[MeCab](https://taku910.github.io/mecab/)（形態素分析という、単語で区切って品詞のラベルをつけるためのツール、Rからは[RMeCab](http://rmecab.jp/wiki/index.php?RMeCab)パッケージ[@RMeCab_bib]を用いて使用できる）などを用いた前処理を必要とします。\n\n前処理を行った文字列のデータと、Ham/Spamのラベルを組み合わせて分類器の学習を行います。新規のメールの分類では、やはり文字列を同様に前処理した上で分類器に与え、Ham/Spamの判定を行うことになります。\n\n以下に、前処理のコードを示します。かなり複雑ですが、この流れでナイーブベイズの訓練データ・テストデータを作成することができます。\n\n\n::: {.cell filename='ナイーブベイズ：文字列の前処理'}\n\n```{.r .cell-code}\n# 文字列の操作を行うためのライブラリ\npacman::p_load(tm, SnowballC)\n\n# SMS Spam Collection Datasetをロード（kaggleから拾ってくる）\nsns <- read.csv(\"./data/spam.csv\", stringsAsFactors = F, encoding = 'UTF-8')\nsns <- sns[,1:2]\ncolnames(sns) <- c(\"type\", \"text\")\n\n# 文字列をコーパスに変換\ndata_corpus <- VCorpus(VectorSource(sns$text))\n\n# データのクリーニング\nclean_corpus <- tm_map(data_corpus, removeWords,stopwords(kind = \"english\")) # 英語以外の文字を取り除く\nclean_corpus <- tm_map(clean_corpus, stripWhitespace) # 複数のスペースを1つに変換\nclean_corpus <- tm_map(clean_corpus, content_transformer(tolower)) # 大文字を小文字に変換\nclean_corpus <- tm_map(clean_corpus, removePunctuation) # 句読点を取り除く\nclean_corpus <- tm_map(clean_corpus, removeNumbers) # 数字を取り除く\nclean_corpus <- tm_map(clean_corpus, stemDocument) # stem化をする（pay, paid, payingなどをpayに統一）\n\ndados_dtm <- DocumentTermMatrix(clean_corpus) # termと文章を行列にする\n# dados_dtmの中身、行はsnsのテキスト、列は単語、数字が入っていると単語が含まれる\ninspect(dados_dtm[1:5, 1:8]) \n## <<DocumentTermMatrix (documents: 5, terms: 8)>>\n## Non-/sparse entries: 0/40\n## Sparsity           : 100%\n## Maximal term length: 11\n## Weighting          : term frequency (tf)\n## Sample             :\n##     Terms\n## Docs ��� aah aaniy aaooooright aathi aathilov abbey abdomen\n##    1   0   0     0           0     0        0     0       0\n##    2   0   0     0           0     0        0     0       0\n##    3   0   0     0           0     0        0     0       0\n##    4   0   0     0           0     0        0     0       0\n##    5   0   0     0           0     0        0     0       0\n\n# 訓練データとテストデータに分ける\ndata_dtm_train <- dados_dtm[1:4169, ]\ndata_dtm_test <- dados_dtm[4170:5559, ]\n\n# ラベルは別途分ける\ndata_train_labels <- sns[1:4169, ]$type\ndata_test_labels <- sns[4170:5559, ]$type\n\n# スパム/ハムの割合を表示（大体87%ハムで同じ）\nprop.table(table(data_train_labels))\n## data_train_labels\n##       ham      spam \n## 0.8644759 0.1355241\nprop.table(table(data_test_labels))\n## data_test_labels\n##       ham      spam \n## 0.8705036 0.1294964\n\n# 5回以上見つかったWordのみ拾う\nsms_freq_words <- findFreqTerms(data_dtm_train, 5)\n\n# 5文字以上見つかったWordだけを学習・テストデータに使う\nsms_dtm_freq_train <- data_dtm_train[ , sms_freq_words]\nsms_dtm_freq_test <- data_dtm_test[ , sms_freq_words]\n\n# 文字があるかないかの2値に変換する関数\nconvert_counts <- function(x){\n  x <- ifelse(x > 0, \"Yes\", \"No\")\n}\n\n# 数値データをYes/Noのデータに変換\nsms_train <- apply(sms_dtm_freq_train, MARGIN = 2, convert_counts)\nsms_test <- apply(sms_dtm_freq_test, MARGIN = 2, convert_counts)\n```\n:::\n\n\n:::\n\nナイーブベイズの分類器を作成するための関数である`naiveBayes`は、訓練データとラベルのベクターを引数に取ります（`formula`で訓練データとラベルを与えることもできます）。分類器からの予測には、`predict`関数を用います。十分な学習データがあれば、かなり高い精度でHam/Spamを分類することができます。\n\n\n::: {.cell filename='ナイーブベイズでの学習と予測'}\n\n```{.r .cell-code}\n# ナイーブベイズで学習\nnb_classifier <- naiveBayes(sms_train, data_train_labels)\n\n# テストデータで予測\nsms_test_pred <- predict(nb_classifier, sms_test)\n\n# 検証したデータで、スパム/ハムが見分けられている\ndata_test_labels[21:30]\n##  [1] \"ham\"  \"ham\"  \"ham\"  \"ham\"  \"ham\"  \"spam\" \"ham\"  \"spam\" \"spam\" \"spam\"\nsms_test_pred[21:30] %>% as.character()\n##  [1] \"ham\"  \"ham\"  \"ham\"  \"ham\"  \"ham\"  \"spam\" \"ham\"  \"spam\" \"spam\" \"spam\"\n\n# 正答率は97.8%ぐらい\nsum(sms_test_pred == data_test_labels)/1390\n## [1] 0.9776978\n```\n:::\n\n\n## 決定木\n\n**決定木（decision tree）**は弱分類器と呼ばれる、非常に単純な線形分類器（例えば、x＞0のときはA、x<=0のときはBなど）を組み合わせて、複雑な分類を行う手法（アンサンブル学習）です。\n\n![図3：決定木のイメージ](./image/decision_tree.png)\n\n決定木は、弱分類器の組み合わせの選び方のアルゴリズムによって、**バギング**と**ブースティング**と呼ばれる2つの手法に大別されています。これらのうち、バギングと呼ばれるものの一種が**ランダムフォレスト（Random Forest）**と呼ばれる手法です。ランダムフォレストは21世紀初頭から用いられており、優秀な分類器として長く使われています。もう一つのブースティングについては2015年頃から良いアルゴリズムがいくつか開発されており、分類性能の非常に高い分類器として用いられています。\n\n### ランダムフォレスト\n\n**ランダムフォレスト**は、ランダムに決定木による分類器をたくさん生成し、その平均や多数決の結果を最終的な分類器とする方法です。Rでランダムフォレストを利用する場合には、[randomForest](https://cran.r-project.org/web/packages/randomForest/index.html)パッケージ[@randomForest_bib]の`randomForest`関数を用います。`randomForest`関数の使い方は`lm`関数や`svm`関数とほぼ同じで、第一引数に`formula`を取ります。予測に`predict`関数を用いるところも`svm`と同じです。\n\nランダムフォレストによる分類では、分類の境界は基本的に縦横に配置されます。これは、上記のようにランダムフォレストが決定木の組み合わせからなる分類器であるためです。\n\n\n::: {.cell filename='ランダムフォレストによる分類'}\n\n```{.r .cell-code}\n## ランダムフォレスト\npacman::p_load(randomForest)\nrf.iris <- randomForest(Species ~ ., data = train.iris)\npredict(rf.iris, test.iris)\n##          7         14         21         33         34         35         37 \n##     setosa     setosa     setosa     setosa     setosa     setosa     setosa \n##         43         51         68         70         73         74         79 \n##     setosa  virginica  virginica versicolor  virginica versicolor versicolor \n##         84         85         89        105        106        110        126 \n##  virginica     setosa versicolor  virginica  virginica  virginica  virginica \n##        129        141        142        150 \n##  virginica versicolor versicolor versicolor \n## Levels: setosa versicolor virginica\n\n# 正答率\nsum(predict(rf.iris, test.iris) == test.iris$Species) / 25\n## [1] 0.68\n\n# 分類の境界線を記述\nd.mat.rf <- cbind(d.mat, Species = predict(rf.iris, d.mat))\nggplot()+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(data = d.mat.rf, aes(x = Sepal.Length, y = Sepal.Width, fill = Species), alpha = 0.2) +\n  theme_light() + theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### ブースティング\n\n**ブースティング**も決定木の一種ですが、分類器をランダムに生成するのではなく、決定木を少しずつ変化させ最適化するような手法です。ブースティングは以前はそれほど用いられてはいませんでしたが、勾配ブースティングと呼ばれる改良化されたアルゴリズムが開発されてから非常に分類精度の高い手法としてよく用いられています。\n\nブースティングのアルゴリズムには、昔からある[Adaboost](https://www.sciencedirect.com/science/article/pii/S002200009791504X)や、2015年以降に開発された[XGBoost](https://xgboost.readthedocs.io/en/stable/#)、[LightGBM](https://lightgbm.readthedocs.io/en/stable/)、[CatBoost](https://catboost.ai/)等があります。特に2015年以降に開発された後者の分類性能は高いとされています。\n\nRではAdaboostは[JOUSBoost](https://cran.r-project.org/web/packages/JOUSBoost/index.html)パッケージ [@JOUSBoost_bib]、XGBoostは[xgboost](https://cran.r-project.org/web/packages/xgboost/index.html)パッケージ [@xgboost_bib]、LightGBMは[lightgbm](https://cran.r-project.org/web/packages/lightgbm/index.html)パッケージ [@lightgbm_bib]、CatBoostは[catboost](https://catboost.ai/en/docs/installation/r-installation-github-installation)パッケージ [@catboost_bib]を用いることで利用できます。ただし、`catboost`にはPythonのライブラリが必要となるので、Rでは使用の難易度が高めです。\n\n以下に、XGBoostを利用した分類の例を示します。説明変数となるデータが少なく、モデルの最適化も行っていないため、上記のランダムフォレストと同程度の精度（0.64）となっています。\n\n\n::: {.cell filename='XGBoostでの分類器の生成'}\n\n```{.r .cell-code}\n## ブースティング（XGboost）\npacman::p_load(xgboost)\n\n# xgboostパッケージでは、テストデータをdgCMatrixというクラスに変換する必要がある\nxg.train.iris <- Matrix::sparse.model.matrix(Species ~ . + 0, data = train.iris)\nxg.test.iris <- Matrix::sparse.model.matrix(Species ~ . + 0, data = test.iris)\n\n# ラベルは数値しか受け付けない\nlabel <- train.iris$Species %>% as.numeric - 1\n\n# 全然最適化されていない訓練\nxg.iris <- xgboost(\n  data = xg.train.iris, \n  label = label,\n  nround = 5, # 計算の繰り返し回数\n  num_class = 3, # 分類するクラスの数\n  objective = \"multi:softmax\") # 3値分類以上だとこの形にする。2値なら\"binary:logistic\"を指定\n## [1]\ttrain-mlogloss:0.856284 \n## [2]\ttrain-mlogloss:0.704538 \n## [3]\ttrain-mlogloss:0.598684 \n## [4]\ttrain-mlogloss:0.518844 \n## [5]\ttrain-mlogloss:0.456383\n```\n:::\n\n::: {.cell filename='XGBoostで生成した分類器での予測'}\n\n```{.r .cell-code}\n# 予測結果と正答率\nsp <- c(\"setosa\", \"versicolor\", \"virginica\")\nsum(sp[predict(xg.iris, xg.test.iris) + 1] == test.iris$Species)/25\n## [1] 0.64\n```\n:::\n\n::: {.cell filename='XGBoostでの予測の境界線'}\n\n```{.r .cell-code}\n# 分類の境界線を記述\nxg.d.mat <- Matrix::sparse.model.matrix(Species ~ . + 0, data = cbind(Species = 0, d.mat))\nd.mat.xg <- cbind(d.mat, Species = sp[predict(xg.iris, xg.d.mat) + 1])\nggplot()+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +\n  geom_raster(data = d.mat.xg, aes(x = Sepal.Length, y = Sepal.Width, fill = Species), alpha = 0.2) +\n  theme_light() + theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## ニューラルネットワーク\n\n[前の章](./chapter26.html)でも紹介した**ニューラルネットワーク**は、分類でも用いられる機械学習の手法です。目的変数にカテゴリカルデータを用いる点が回帰とは異なります。\n\nRでは、回帰と同様に`neuralnet`パッケージの`neuralnet`関数を用いてニューラルネットワークでの分類器を作成することができます。`neuralnet`関数で分類を行う際にはformulaの目的変数の設定が特殊で、`(列名=='ラベル')`の形で分類するカテゴリを示し、各カテゴリを`+`でつなぎます。具体的には以下の`formula`のように指定します。\n\n\n\n::: {.cell filename='neuralnet：分類を行う際のformulaの設定'}\n\n```{.r .cell-code}\nformula_iris <- \n  as.formula(\n    # 上の行がラベル、下の行が説明変数\n    \"(Species == 'setosa') + (Species == 'versicolor') +  (Species == 'virginica') ~ \n      Sepal.Length + Sepal.Width\"\n  )\n```\n:::\n\n\n`neuralnet`関数の使い方は回帰の際と同じです。引数として、`formula`、`data`、`hidden`（隠れ層、中間層）、`act.fct`（活性化関数）を指定します。\n\n`hidden`の指定では、3個のパーセプトロンを2層の場合には`hidden=c(3,3)`、2個のパーセプトロンを3層の場合には`hidden=c(2,2,2)`とベクターを用いて示します。活性化関数には`\"logistic\"`（ソフトマックス関数）か`\"tanh\"`（Hyperbolic tangent）のどちらかを指定します。\n\n計算した分類器を`plot`関数の引数に取ることで、重みとバイアスをグラフで表示することができます。\n\n\n::: {.cell filename='neuralnet：分類を行う際のformulaの設定'}\n\n```{.r .cell-code}\npacman::p_load(neuralnet)\n\nset.seed(2)\n\nnn.iris <- neuralnet(\n  formula = formula_iris,\n  data = train.iris,\n  hidden = c(3, 2),\n  act.fct = \"logistic\"\n)\nplot(nn.iris, rep = \"best\")\n```\n\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n`neuralnet`での予測にも、`predict`関数を用います。引数が`neuralnet`関数の返り値とテストデータのデータフレームである点も、回帰と同じです。ただし、分類の予測は確率として表示されます。各行のうち最も値が高い、つまり確率が高いものが分類結果となります。以下の例では、1列目がsetosa、2列目がversicolor、3列目がvirginicaである確率となります。\n\n\n::: {.cell filename='neuralnet：予測'}\n\n```{.r .cell-code}\n# 予測は確率で出てくる\npred.test <- predict(nn.iris, test.iris)\npred.test |> head()\n##         [,1]          [,2]          [,3]\n## 7  1.0007861 -0.0001940386 -0.0005022254\n## 14 1.0007861 -0.0001940386 -0.0005022254\n## 21 0.9880775 -0.0067728564  0.0187861514\n## 33 1.0007861 -0.0001940386 -0.0005022254\n## 34 1.0007861 -0.0001940386 -0.0005022254\n## 35 1.0007861 -0.0001940386 -0.0005022254\n```\n:::\n\n\n結果を種名に変更し、正答率を計算したのが以下のスクリプトです。88%とそこそこの正答率となっています。また、分類の境界線はやや不自然ですが、基本的に直線的な部分が多い曲線で構成されています。ただしニューラルネットワークの境界部分での確率はなだらかに変化しています。例えば、青と緑の境界では、青の確率50％ぐらい、緑の確率50％ぐらいとなっています。\n\n\n::: {.cell filename='neuralnet：確率を種に変換'}\n\n```{.r .cell-code}\npred.sp <- numeric(nrow(pred.test))\nfor(i in 1:nrow(pred.test)){\n  pred.sp[i] <- (pred.test[i,] %>% max == pred.test[i,]) %>% sp[.]\n}\nsum(pred.sp == test.iris$Species)/25\n## [1] 0.88\n```\n:::\n\n::: {.cell filename='neuralnet：分類の境界線'}\n\n```{.r .cell-code}\npred.mat <- predict(nn.iris, d.mat)\npred.mat2 <- numeric(nrow(pred.mat))\nfor(i in 1:nrow(pred.mat)){\n  pred.mat2[i] <- (pred.mat[i,] %>% max == pred.mat[i,]) %>% sp[.]\n}\n\nd.mat.nn <- cbind(d.mat, Species = pred.mat2)\nggplot()+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species))+\n  geom_raster(data = d.mat.nn, aes(x = Sepal.Length, y = Sepal.Width, fill = Species), alpha = 0.2)+\n  theme_light() + theme(legend.position = \"none\") \n```\n\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell filename='neuralnet：分類の境界線/計算結果をそのまま表示'}\n\n```{.r .cell-code}\npred.mat <- predict(nn.iris, d.mat) |> scale()\ncolnames(pred.mat) <- c(\"setosa\", \"versicolor\", \"virginica\")\n\nd.mat.nn <- cbind(d.mat, pred.mat)\n\npacman::p_load(patchwork)\n\np1 <- ggplot()+\n  geom_raster(data = d.mat.nn, aes(x = Sepal.Length, y = Sepal.Width, fill = -setosa), alpha = 0.5)+ \n  scale_fill_distiller(palette = \"Reds\")+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species))+\n  theme_light()+\n  theme(legend.position = \"none\") + \n  labs(title = \"setosa\")\n\np2 <- ggplot()+\n  geom_raster(data = d.mat.nn, aes(x = Sepal.Length, y = Sepal.Width, fill = -versicolor), alpha = 0.5)+\n  scale_fill_distiller(palette = \"Greens\")+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species))+\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"versicolor\")\n  \np3 <- ggplot()+\n  geom_raster(data = d.mat.nn, aes(x = Sepal.Length, y = Sepal.Width, fill = -virginica), alpha = 0.5)+\n  scale_fill_distiller(palette = \"Blues\")+\n  geom_point(data = iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species))+\n  theme_light() + theme(legend.position = \"none\") + labs(title = \"virginica\")\n\np1 + p2 + p3\n```\n\n::: {.cell-output-display}\n![](chapter27_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "chapter27_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}