{
  "hash": "13db0b4eab4d2bfe8cc6e32e500f377b",
  "result": {
    "markdown": "# ベクター\n\n<font color = \"red\">**ベクター（vector）**</font>はRのクラスのうち，最も基本的なものです．R以外の言語では，要素が1つのクラスと，複数の要素を持つクラスは明確に区別されますが，Rでは，**要素が1つでも複数でも全てベクター**として取り扱います．ベクターでは繰り返し処理を用いることなく，すべての要素に対して演算を行うことができます．\n\nベクターには，\n\n-   <font color = \"red\">**データ型が1つ**</font>だけ\n-   データ型が異なる要素が入ると，<font color = \"red\">**ベクター全体の型が変化**</font>する\n-   演算には<font color = \"red\">**反復（recycling）**</font>が用いられる\n\nという特徴があります．\n\n## ベクターの作成と結合：cとappend\n\n要素が一つのベクターは関数などを特に用いることなく作成することができます．要素が複数のベクターは<font color = \"red\">**c関数**</font>（cはconbineの略）で作成することができます．c関数はベクター同士をつなぐのにも使えます．\n\n**append関数**もベクター同士を結合するのに使います．append関数では，ベクターを追加する位置をafter引数で指定することができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 # 一つの数値はベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n\"moji\" # 一つの文字列もベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"moji\"\n```\n:::\n\n```{.r .cell-code}\nx <- c(1, 2, 3) # c関数で複数の要素のベクターを作る\nc(x, 4) # c関数はベクター同士をつなぐのにも使える\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nappend(x, 4) # append関数もベクターをつなぐのに使える\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\n# append関数では，ベクターの挿入場所を指定できる\nappend(c(1, 2, 3), \"added\", after=1) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"     \"added\" \"2\"     \"3\"    \n```\n:::\n:::\n\n\n## 連続する数値のベクターを作成する：コロン（:）、sep、seq\n\n連続する整数や、一定間隔の数列、繰り返しのあるベクターを作成する場合には、<font color = \"red\">**:（コロン）、seq関数、rep関数**</font>を用います。\n\n<font color = \"red\">**:（コロン）**</font>は連続する整数のベクターを作成する演算子で、コロンの前に置いた整数から、後に置いた整数まで連続する整数のベクターを作成します。コロンの前後には、マイナスの数値を設定することもできます（例えば、-1:-3とすると、-1, -2, -3のベクターとなります）。この**コロンの演算は、他の演算子より前に実行**されます。\n\n<font color = \"red\">**seq関数**</font>は、第一引数（from）から第二引数（to）まで、by引数で指定した間隔で連続する関数です。また、by引数の代わりに、length.out引数を設定すると、fromからtoまで、length.outで指定した長さのベクターを作成することができます。\n\n<font color = \"red\">**rep関数**</font>は、第一引数にベクターを取り、第二引数に繰り返しの回数を取る関数です。rep関数の出力は、第一引数のベクターを第二引数の回数だけ繰り返したものになります。第二引数にはベクターを取ることもでき、ベクターで指定した回数だけ、要素を繰り返したベクターを作成することができます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:3 # 1から3までの整数のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\n-5:5 # -5から5までの整数のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n```\n:::\n\n```{.r .cell-code}\n-1:-10 # -1から-10までの整数のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10\n```\n:::\n\n```{.r .cell-code}\n-1:-10 * 5 # コロンの演算は掛け算より先に行われる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  -5 -10 -15 -20 -25 -30 -35 -40 -45 -50\n```\n:::\n\n```{.r .cell-code}\nseq(1, 5, by=0.5) # 1から5まで、0.5間隔のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n:::\n\n```{.r .cell-code}\nseq(1, 5, length.out=11) # 1から5まで、等間隔の長さ11のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.0 1.4 1.8 2.2 2.6 3.0 3.4 3.8 4.2 4.6 5.0\n```\n:::\n\n```{.r .cell-code}\nrep(x, 5) # xを5回繰り返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n```\n:::\n\n```{.r .cell-code}\nrep(x, c(1, 2, 3)) # xの要素を1、2、3回繰り返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 2 3 3 3\n```\n:::\n:::\n\n\n## ベクターの型\n\nベクターの型は，ベクターに含まれる要素によって変化します．数値のベクターはnumeric，文字列が含まれるベクターはcharacter，因子であればfactor（factorはクラスで，型はnumeric），真偽値であればlogicalとなります．ベクターは1つの型からなる要素の集合ですので，別の型の要素が付け加えられると，元のベクター，もしくは付け加えられた要素の型が変化します．型の優先順位は**character \\> numeric \\> logical = factor**という順で，型が混じったベクターはより優先される型に自動的に変換されます．\n\nベクターは**atomic vector**と呼ばれることもあります．ベクターであることの確認には，<font color = \"red\">**is.atomic関数**</font>を用います．この関数は，引数がベクターであればTRUE，ベクター以外であればFALSEを返します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(x, 4)) # 数値ベクター（numeric）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(x, \"added\")) # 文字列ベクター（character）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(factor(x)) # 因子ベクター（factor）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(T, F, T)) # 論理型ベクター（logical）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(T, 1)) # logicalとnumericのベクターはnumeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(factor(\"dog\"), 1)) # factorとnumericのベクターはnumeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(T, factor(\"dog\"))) # logicalとfactorのベクターはnumeric（integer）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nclass(c(1, \"dog\")) # numericとcharacterのベクターはcharacter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nmode(c(x, 4)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nmode(c(x, \"added\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nmode(factor(x)) # 因子はクラスで，型は数値型\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nmode(c(T, F, T))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nis.atomic(1) # 長さ1のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.atomic(c(1, 2)) # 長さ2以上のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.atomic(list(1)) # リストはベクターではない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n## 演算と反復（recycling）\n\nRのベクターでは，for文などの繰り返し文を用いることなく，すべての要素に対して演算を行うことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nx + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n\n```{.r .cell-code}\nx - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 2\n```\n:::\n\n```{.r .cell-code}\nx * 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 6 9\n```\n:::\n\n```{.r .cell-code}\nx / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5 1.0 1.5\n```\n:::\n\n```{.r .cell-code}\nx %% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 0\n```\n:::\n:::\n\n\nベクターの演算時には，<font color = \"red\">**反復（recycling）**</font>のルールが適用されます．recyclingについて調べるために，長いベクターと短いベクターの演算を見てみましょう．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(2, 3, 4) # 長さ3のベクター\nx # 長さ3のベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n\n```{.r .cell-code}\nx + y \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 7\n```\n:::\n\n```{.r .cell-code}\nx - y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 -1 -1\n```\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  6 12\n```\n:::\n\n```{.r .cell-code}\nx / y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5000000 0.6666667 0.7500000\n```\n:::\n\n```{.r .cell-code}\nz <- c(2, 2, 2, 2, 2, 2) # 長さ6のベクター\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 2 2 2 2 2\n```\n:::\n\n```{.r .cell-code}\nx + z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5 3 4 5\n```\n:::\n\n```{.r .cell-code}\nx - z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  0  1 -1  0  1\n```\n:::\n\n```{.r .cell-code}\nx * z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 2 4 6\n```\n:::\n\n```{.r .cell-code}\nx / z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5 1.0 1.5 0.5 1.0 1.5\n```\n:::\n:::\n\n\n長さが同じベクターでは，ベクターのインデックスが一致するもの同士が演算されていることがわかります．例えば，x（c(1, 2, 3)）とy（c(2, 3, 4)）の足し算は，1+2，2+3，3+4の結果となります．\n\n一方で，長さが違うベクターを演算した場合には，短いベクターが**反復（recycling）**されます．x（c(1, 2, 3)）とz（c(2, 2, 2, 2, 2, 2)）の足し算では，前の3つのインデックスだけでなく，後ろの3つにもxの要素が足し算された結果が返ってきます（1+2, 2+2, 3+2, 1+2, 2+2, 3+2の結果が出力）．このように，短いベクターを繰り返して，長いベクターと同じ長さとし，結果を返すのが**反復（recycling）**のルールです．ベクターに数値を足し算するような場合にも，この反復と同じルールが適用されています．数値は長さ1のベクターですので，この長さ1のベクターを反復し，長さをあわせて計算した結果が返ってきていることになります．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) + 1 # このような書き方は\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n\n```{.r .cell-code}\nc(1, 2, 3) + c(1, 1, 1) # 自動的にこのような計算とされる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4\n```\n:::\n:::\n\n\nこのルールでは，<font color = \"red\">**短いベクターの長さがもう一方のベクターの長さの約数でない場合，中途半端に反復される**</font>ことになります．下の場合では，c(1, 2)が反復されて，c(1, 2, 1)として取り扱われています．このような場合には，Rは警告（warning）を出します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2) + c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(1, 2) + c(1, 2, 3): longer object length is not a multiple of\nshorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 4\n```\n:::\n:::\n\n\n## インデックス\n\nベクターの要素はインデックスを用いて取り出すことができます。インデックスはベクターの1つ目の要素が1、2つ目の要素が2、という形で設定されており、\\[\\]（各カッコ）の中にインデックスを指定することで要素を取り出すことができます。\n\nインデックスは整数のベクターの形でも指定できます。連続したインデックスを指定する際には、コロン（:）を用いて指定します。\n\nインデックスをマイナスで指定すると、そのインデックスが指定する要素を削除することができます。インデックスをマイナスのベクターで指定すると、そのマイナスで指定した位置の要素が削除されます。\n\nインデックスは数値だけでなく、論理型（TRUEとFALSE）で指定することもできます。\\[\\]の中に、TRUE（T）とFALSE（F）のベクターを与えると、TRUEのインデックスにある要素だけを取り出すことができます。この指定では、反復（recycling）が適用されるので、ベクターの長さより論理型ベクターの長さが短ければ、論理型ベクターが反復されて使用されます。論理型ベクターの方が長い場合には反復は行われず、論理型ベクターが余分に長い分だけNAが返ってきます。\n\nインデックスを論理型ベクターで指定できるため、比較演算子を用いてベクターの要素を取り出すこともできます。例えば、x\\[x \\> 5\\]という形で比較演算子を用いてインデックスを指定すると、xのベクターのうち、5より大きい要素のみを取り出すことができます。\n\nベクターの一部を確認したいときには、head関数とtail関数を用います。head関数はベクターの始めから6つ目までを、tail関数はベクターの後ろから6つ目までを表示する関数です。どちらも第二引数に数値を入れると、その長さのベクターを取り出すことができます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2:11\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  2  3  4  5  6  7  8  9 10 11\n```\n:::\n\n```{.r .cell-code}\nx[3] # 3つ目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nx[12]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nx[c(10, 5, 2)] # 10番目、5番目、2番目の要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11  6  3\n```\n:::\n\n```{.r .cell-code}\nx[4:6] # 4番目から6番目までの要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 6 7\n```\n:::\n\n```{.r .cell-code}\nx[-4] # 4番目の要素を削除する\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  6  7  8  9 10 11\n```\n:::\n\n```{.r .cell-code}\nx[-(5:8)] # 5番目から8番目までの要素を削除する\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  5 10 11\n```\n:::\n\n```{.r .cell-code}\nx[-5:-8] # 上と同じ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  5 10 11\n```\n:::\n\n```{.r .cell-code}\nx[c(T, T, T, T, F, T, T, T, T, F)] # インデックスは真偽値でもよい\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  5  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nx[c(T, F)] # 反復（recycling）が適用され、2つ置きに要素を取り出すことになる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n\n```{.r .cell-code}\nx[c(T, T, T, T, F, T, T, T, T, F, T)] # 論理型の方が長いと、NAが返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  3  4  5  7  8  9 10 NA\n```\n:::\n\n```{.r .cell-code}\nx == 5 # 真偽値を比較演算子で作る\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nx[x == 5] # 比較演算子を含む演算もインデックスに取れる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nx[x > 5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  7  8  9 10 11\n```\n:::\n\n```{.r .cell-code}\nx[x > 3 & x < 6] # 3より大きく、かつ6より小さいものを選ぶ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5\n```\n:::\n\n```{.r .cell-code}\nx %in% c(2, 7) # %in%は後ろの要素と一致する場合にTRUEを返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nx[x %in% c(2, 7)] # 2と7である要素を取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 7\n```\n:::\n\n```{.r .cell-code}\nhead(x) # 始めの6つを表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6 7\n```\n:::\n\n```{.r .cell-code}\ntail(x) # 最後の6つを表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  7  8  9 10 11\n```\n:::\n:::\n\n\n## ベクターの要素に名前を付ける\n\nベクターには<font color = \"red\">**名前（names）**</font>というアトリビュートがあります．このnamesはベクターの要素ごとに名前をつけるものです．namesの要素が重複していても問題はないのですが，後に述べる呼び出しの際に間違いの原因となるため，あまりオススメはできません．\n\nベクターの要素は上記の通り，**インデックス**を用いて呼び出すことができます．しかし，<font color = \"red\">**ベクターの要素はその名前からでも呼び出す**</font>ことができます．呼び出すときには，角カッコ（\\[\\]）の中に，文字列で名前を示します．インデックスの代わりに名前の文字列を用いることで，名前に対応した要素を取り出すことができます．\n\nベクターの名前は，c関数を用いてベクターを作成するときに設定することができます．ベクターがすでに変数として準備されている場合には，<font color = \"red\">**names関数**</font>を用いて名前を設定することができます．このnames関数の引数にベクターを取り，**names関数に名前を記載したベクターを代入する**形で名前を設定することができます．ベクターの名前もnames関数で確認することができます．ベクターでは，ドルマーク（\\$）を用いて名前から要素を取り出すことはできません．\n\nベクターの複数の要素に同じ名前を付けた場合には，インデックスが最も前の要素だけを名前で呼び出すことができます．同じ名前を付けた2つ目，3つ目の要素を名前を用いて呼び出すことはできません．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(dog = 1, cat = 2, pig = 3) # 名前付きべクターをc関数で作る\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndog cat pig \n  1   2   3 \n```\n:::\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\nnames(x) <- c(\"dog\", \"cat\", \"pig\") # ベクターに名前を設定する\nnames(x) # 名前が返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\" \"cat\" \"pig\"\n```\n:::\n\n```{.r .cell-code}\nx[\"cat\"] # 名前の文字列をインデックスにすることができる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncat \n  2 \n```\n:::\n\n```{.r .cell-code}\nx$cat # 呼び出せない\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x$cat: $ operator is invalid for atomic vectors\n```\n:::\n:::\n\n\n> プログラミング言語には，**連想配列**（ハッシュやディクショナリなどとも呼ばれる）というデータ型を持つものがあります．この連想配列は，文字列（記号）と数値などを結びつけておき，文字列をインデックスとして数値等を呼び出すことができるものです（例えば，banana=1，apple=2としておいて，bananaで呼び出すと1が返ってくる）．Rでは，ベクターにnamesが設定でき，名前を用いて要素を呼び出すことができるため，ベクターが連想配列の役割をこなすことができます．\n\n## ベクターの長さを調べる\n\nベクターは，名前以外に，<font color = \"red\">**長さ（length）**</font>を特性として持っています．ベクターの長さは，そのベクターの要素の数のことです．ベクターの長さは<font color = \"red\">**length関数**</font>で調べることができます．ベクターは1次元の構造を持つデータですので，dimension（次元）を持ちません．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(x) # 要素が3つなので長さは3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ndim(x) # ベクターは次元（dimension）を持たない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n#### アトリビュート（attribute）を付ける\n\nRでは，ベクターに名前以外のアトリビュートをつけることもできます．アトリビュートをつけるとき，アトリビュートを呼び出すときにはattr関数を用います．ただし，names以外のアトリビュートをベクターの要素の呼び出しに用いることはできません．\n\nベクターのアトリビュートを調べるときには，<font color = \"red\">**str関数**</font>を用いることもできます．strは「structure」の略で，様々なオブジェクトの構造を調べることができる便利な関数です．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(x, \"hoge\") <- c(\"rat\", \"hat\", \"mat\")\nx$hoge # 呼び出せない\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x$hoge: $ operator is invalid for atomic vectors\n```\n:::\n\n```{.r .cell-code}\nattr(x, \"hoge\") # 呼び出せる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"rat\" \"hat\" \"mat\"\n```\n:::\n\n```{.r .cell-code}\nstr(x) # アトリビュートはnameとhogeになっている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Named num [1:3] 1 2 3\n - attr(*, \"names\")= chr [1:3] \"dog\" \"cat\" \"pig\"\n - attr(*, \"hoge\")= chr [1:3] \"rat\" \"hat\" \"mat\"\n```\n:::\n:::\n\n\n> ベクターにnames以外のattributeを設定しても特に利点はないため，統計の計算などでこのアトリビュートの設定を行うことはほぼありません．\n\n## ランダムサンプリング\n\nRは統計の言語です．統計と確率は密接に関係しているため，統計の取り扱いにおいては，時に確率論的な現象を再現したい，という場合があります．確率論的な現象はランダムなものを取り扱うため，Rではベクターからランダムに要素を取り出す関数，<font color = \"red\">**sample関数**</font>が備わっています．このsample関数では，第一引数にベクター，第二引数にベクターから要素を取り出す回数を指定します．このランダムな取り出しには，**復元抽出**（1つの要素を何度も取り出すことができる）と**非復元抽出**（1つの要素を一度取り出すと，再度取り出されることがない）があります．復元抽出と非復元抽出の指定には，sample関数のreplace引数を用います．replace引数のデフォルトはFALSEで，repaceを指定しない場合には非復元抽出が行われます．復元抽出を行う場合には，replaceにTRUEを指定します．\n\n\n::: {.cell filename='sample関数と復元・非復元抽出'}\n\n```{.r .cell-code}\nsample(1:10, 5) # 1~10の整数から5つをランダムに取り出す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  7 10  9  5\n```\n:::\n\n```{.r .cell-code}\nsample(1:10, 5) # ランダムに取り出すので，上とは異なる結果となる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8  1  4  6 10\n```\n:::\n\n```{.r .cell-code}\nsample(1:10, 5, replace=FALSE) # 非復元抽出\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9 4 8 6 7\n```\n:::\n\n```{.r .cell-code}\nsample(1:10, 15, replace=FALSE) # エラー（1つのものは1度しか取り出せない）\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n```\n:::\n\n```{.r .cell-code}\nsample(1:10, 15, replace=TRUE) # 復元抽出ではエラーとならない\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 5 1 2 6 7 6 9 9 9 5 3 1 7 5 4\n```\n:::\n:::\n\n\n## ベクターを切り分ける：split\n\nベクターを同じ長さの因子で切り分けるのが，**split関数**です．split関数は2つの引数を取り，第一引数にはベクター，第二引数にはベクターと同じ長さの因子を取ります．因子のlevelsに従い，第一引数で指定したベクターを2つ以上のグループに切り分けます．split関数では，グループで切り分けたベクターがリストで返ってきます．\n\n\n::: {.cell filename='split関数'}\n\n```{.r .cell-code}\nx <- rep(1:5, 5) # xは1~5を5回繰り返すベクター\ny <- factor(c(rep(1, 10), rep(2, 15))) # xを切り分けるための因子\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\nLevels: 1 2\n```\n:::\n\n```{.r .cell-code}\nsplit(x, y) # リストが返ってくる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n [1] 1 2 3 4 5 1 2 3 4 5\n\n$`2`\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表1：ベクターに関する関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> ベクターに適用される演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> head(x) </td>\n   <td style=\"text-align:left;\"> 始めの6つの要素を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> tail(x) </td>\n   <td style=\"text-align:left;\"> 最後の6つの要素を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> names(x) </td>\n   <td style=\"text-align:left;\"> 名前を表示する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> names(x) &lt;- y </td>\n   <td style=\"text-align:left;\"> yを名前に設定する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> length(x) </td>\n   <td style=\"text-align:left;\"> 要素の数を返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> attr(x, which) </td>\n   <td style=\"text-align:left;\"> whichのattributeを返す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> attr(x, which) &lt;- y </td>\n   <td style=\"text-align:left;\"> whichのattributeをyに設定する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> str(x) </td>\n   <td style=\"text-align:left;\"> 詳細な情報（構造，structure）を表示する </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> sample(x, size, replace) </td>\n   <td style=\"text-align:left;\"> xからsizeの個数の要素をランダムに取り出す </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> split(x, f) </td>\n   <td style=\"text-align:left;\"> 因子fに従ってベクターを分割する </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## 集合としてのベクター\n\n統計では，集合を取り扱う場合があります．集合としてベクターを取り扱い，積集合や和集合を取り扱う関数がRには備わっています．\n\nベクターの要素のうち，重複したものを取り除く関数が<font color = \"red\">**unique関数**</font>です．unique関数はベクターを引数に取り，引数に含まれる重複した要素を1つだけ残して取り除きます．\n\n和集合と積集合を求める関数が<font color = \"red\">**union関数とintersect関数**</font>です．union関数もintersect関数も共に2つのベクターを引数に取り，union関数は和集合（ベクターがxとyの時，x \\cup y），intersect関数は積集合（ベクターがxとyの時，x \\cap y）を返します．\n\n集合の差を示す関数が<font color = \"red\">**setdiff関数**</font>です．setdiff関数も2つのベクターを引数に取り，第一引数にあって第二引数に無い要素を返します．\n\n集合が同一とみなせるかどうか判断する関数がsetequal関数です．2つのベクターを引数に取り，2つのベクターの要素が同一であればTRUE，異なっていればFALSEを返します．\n\n最後に，集合に関与する演算子である，%in%について説明します．%in%は前と後ろにベクターを取る演算子で，前のベクターにも後ろのベクターにもある要素（積集合の要素）にはTRUE，前のベクターにはあり，後ろのベクターには無い要素にはFALSEを返す関数です．\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table>\n<caption>表2：集合に関する関数</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> 関数名 </th>\n   <th style=\"text-align:left;\"> 集合に適用する演算 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> union(x, y) </td>\n   <td style=\"text-align:left;\"> xとyの和集合 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> intersect(x, y) </td>\n   <td style=\"text-align:left;\"> xとyの積集合 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> setdiff(x, y) </td>\n   <td style=\"text-align:left;\"> xにあってyに無い集合 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> setequal(x, y) </td>\n   <td style=\"text-align:left;\"> xとyが同一かどうかを評価 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> x %in% y </td>\n   <td style=\"text-align:left;\"> xのうち，yにある要素はTRUEを返す </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(1:5, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nunique(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nx <- 1:10\ny <- 7:16\n\nunion(x, y) # xとyの和集合\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16\n```\n:::\n\n```{.r .cell-code}\nintersect(x, y) # xとyの積集合\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nsetdiff(x, y) # xにあってyに無いもの\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nsetdiff(y, x) # yにあってxに無いもの\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 12 13 14 15 16\n```\n:::\n\n```{.r .cell-code}\nsetequal(x, y) # xとyが同一かどうかを評価\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nsetequal(x, 10:1) # 要素が同一なのでTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nx %in% y # xのうち，yにあるものはTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n:::\n",
    "supporting": [
      "chapter11_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}