{
  "hash": "6b030040ac524a29a4dcb62a243836e0",
  "result": {
    "engine": "knitr",
    "markdown": "# 日時データの取り扱い\n\n\n\n\n\n時間とともに変化する値を記録したデータである**時系列データ**は、統計で取り扱う代表的なデータの一つです。時系列データの代表的な例として、為替や株価、温度や湿度、ネットワークへのアクセス数などが挙げられます。これらのデータを取り扱うためには、**日時データ**を適切に取り扱う必要があります。\n\n日時データは通常文字列として記録されるため、Rでデータを読み込んだ際には、文字列のデータを日時データとして取り扱えるように変換する必要があります。この変換に関する関数をRは多数取り揃えています。\n\n## 日時データのクラス：Date・POSIXct・POSIXlt・POSIXt\n\nRでは、日時データのクラスとして、**Date・POSIXct・POSIXlt・POSIXt**の4種類が設定されています。これらのうち、**Date型は日付**のみを取り扱う型、**POSIXct・POSIXlt・POSIXt型は日時（日付＋時間）**を取り扱う型です。これらの型は、それぞれ取り扱い方が少しずつ異なります。\n\nRには、表1に示す日時データ取り扱いのための関数が備わっています。以下にそれぞれの関数・データ型の取り扱いについて説明します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表1：R標準の日時関連関数群\n\n|関数名                        |適用する演算                                    |\n|:-----------------------------|:-----------------------------------------------|\n|Sys.Date()                    |現在の日付を返す(Date)                          |\n|Sys.Time()                    |現在の日時を返す(POSIXct)                       |\n|Sys.timezone()                |現在のタイムゾーンを返す                        |\n|as.POSIXlt(x)                 |xをPOSIXltに変換する                            |\n|weekdays(x)                   |xの曜日を返す                                   |\n|months(x)                     |xの月名を返す                                   |\n|quarters(x)                   |xの四半期を返す                                 |\n|ISOdatetime(y, m, d, h, m, s) |POSIXctオブジェクトを作成                       |\n|seq(x, by, length.out)        |xからbyの間隔でlength.outの長さのベクターを作成 |\n|cut.POSIXt(x, breaks)         |xをbreaksで丸めた因子を作成                     |\n|min(x)                        |xの最小値を返す                                 |\n|max(x)                        |xの最大値を返す                                 |\n|mean(x)                       |xの平均値を返す                                 |\n|range(x)                      |xの範囲を返す                                   |\n|difftime(x, y)                |xとyの時間差を返す                              |\n|round(x, unit)                |xをunitにまるめて返す                           |\n|Sys.sleep(sec)                |演算をsec秒停止する                             |\n|tic()                         |時間計測を開始（tictocパッケージ）              |\n|toc()                         |時間計測を終了（tictocパッケージ）              |\n\n\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## POSIXtクラス\n\nPOSIXtクラスはPOSIXctとPOSIXltの親クラスです。Rの日時に関する関数の多くはPOSIXtクラスを引数に取るよう設定されているため、POSIXctもPOSIXltもほぼ同じように取り扱うことができます。\n\n:::\n\n## 現在の日時を取得する\n\n`Sys.Date`関数と`Sys.time`関数は、現在の日付・日時をそれぞれ取得するための関数です。`Sys.Date`関数は現在の日付をDateクラスで、`Sys.time`関数は現在の時刻をPOSIXctクラスで返します。同様の関数として`date`関数もありますが、この関数の返り値は文字列です。\n\n`Sys.timezone`関数は、Rが演算に用いるタイムゾーンを返す関数です。日本で使用しているPCでは、通常Asia/Tokyo（GMT+9）をタイムゾーンとしています。\n\n\n::: {.cell filename='Sys.DateとSys.time関数'}\n\n```{.r .cell-code}\nSys.Date() # 現在の日付（Date）\n## [1] \"2025-03-29\"\n\nSys.time() # 現在の日時（POSIXct）\n## [1] \"2025-03-29 08:11:38 +09\"\n\ndate() # 現在の日時（文字列）\n## [1] \"Sat Mar 29 08:11:38 2025\"\n\nSys.timezone() # システムのタイムゾーン\n## [1] \"Etc/GMT-9\"\n\n\nSys.Date() |> class() # Sys.Dateの返り値はDate\n## [1] \"Date\"\n\nSys.time() |> class() # Sys.timeの返り値はPOSIXct（POSIXt）\n## [1] \"POSIXct\" \"POSIXt\"\n\ndate() |> class() # dateの返り値は文字列（character）\n## [1] \"character\"\n```\n:::\n\n\nDateクラスのデータ型は数値で、`as.numeric`関数で数値に変換すると1970年1月1日からの日数を返します。\n\n\n::: {.cell filename='Dateクラス'}\n\n```{.r .cell-code}\nSys.Date() |> mode() # Dateクラスは数値型\n## [1] \"numeric\"\n\nSys.Date() |> as.numeric() # 1970/1/1からの日数\n## [1] 20176\n```\n:::\n\n\n同様に、POSIXctもデータ型は数値で、数値変換すると1970年1月1日0時0分0秒からの秒数を返します。\n\n\n::: {.cell filename='POSIXctクラス'}\n\n```{.r .cell-code}\nSys.time() |> mode() # POSIXctクラスは数値型\n## [1] \"numeric\"\n\nSys.time() |> as.numeric() # 1970/1/1からの時間（秒）\n## [1] 1743203499\n```\n:::\n\n\n## POSIXctクラスとPOSIXltクラス\n\nPOSIXctクラスのオブジェクトは、`as.POSIXlt`関数でPOSIXltクラスに変換することができます。また、`as.POSIXct`関数を用いてPOSIXltクラスのオブジェクトをPOSIXctクラスに変換することもできます。\n\nPOSIXctクラスとPOSIXltクラスの違いは、POSIXctが数値なのに対し、POSIXltにはクラスだけでなく、名前（`names`）とタイムゾーン（`tzone`）がアトリビュートとして設定されているリストである点です。POSIXltは名前付きリストですので、設定されている名前（`sec`、`min`、`hour`、`mday`など）を用いて、秒、分、時、日などの日時の部分データを呼び出すことができます。\n\n\n::: {.cell filename='POSIXltクラス'}\n\n```{.r .cell-code}\nSys.time() |> as.POSIXct() # POSIXctに変換\n## [1] \"2025-03-29 08:11:38 +09\"\n\nSys.time() |> as.POSIXlt() # POSIXltに変換\n## [1] \"2025-03-29 08:11:38 +09\"\n\n\nt <- Sys.time() # tはPOSIXct\nt$year # POSIXctには名前が無いため、エラー\n## Error in t$year: $ operator is invalid for atomic vectors\n\nattributes(t) # class以外は設定されていない\n## $class\n## [1] \"POSIXct\" \"POSIXt\"\n\n\nt1 <- as.POSIXlt(t) # t1はPOSIXlt\nattributes(t1) # 名前とタイムゾーンが設定されている\n## $names\n##  [1] \"sec\"    \"min\"    \"hour\"   \"mday\"   \"mon\"    \"year\"   \"wday\"   \"yday\"  \n##  [9] \"isdst\"  \"zone\"   \"gmtoff\"\n## \n## $class\n## [1] \"POSIXlt\" \"POSIXt\" \n## \n## $tzone\n## [1] \"\"    \"+09\" \"   \"\n## \n## $balanced\n## [1] TRUE\n\nas.numeric(t1) # POSIXltも数値に置き換えできる\n## [1] 1743203499\n\nmode(t1) # POSIXltはリスト\n## [1] \"list\"\n\nt1$mday # POSIXltは$で名前から呼び出し可能\n## [1] 29\n\nt1$hour\n## [1] 8\n\nt1$wday # 曜日は月曜日が1\n## [1] 6\n\nt1$zone # タイムゾーン\n## [1] \"+09\"\n```\n:::\n\n\nPOSIXltにはタイムゾーンがアトリビュートとして設定されており、POSIXctには設定されていませんが、いずれも`as.POSIXlt`、`as.POSIXct`関数の`tz`引数を設定することで、タイムゾーンを変更することができます。\n\n\n::: {.cell filename='タイムゾーンの設定'}\n\n```{.r .cell-code}\nas.POSIXct(Sys.time(), tz = \"GMT\") # POSIXct型のSys.time()をUTCに変換\n## [1] \"2025-03-28 23:11:38 GMT\"\n\nas.POSIXct(Sys.time(), tz = \"EST\") # アメリカ東時間に変換\n## [1] \"2025-03-28 18:11:38 EST\"\n\nas.POSIXlt(t1, tz = \"GMT\") # POSIXlt型をUTCに変換\n## [1] \"2025-03-29 08:11:38 +09\"\n\nas.POSIXlt(t1, tz = \"EST\") # アメリカ東時間に変換\n## [1] \"2025-03-29 08:11:38 +09\"\n```\n:::\n\n\nPOSIXct、POSIXltクラスのオブジェクトは、共にRの日時データに関する関数の引数として設定し、演算を行うことができます。\n\n代表的な日時データに関する関数は、`weekdays`関数や`months`関数、`quarters`関数などです。いずれも日時データのベクターを引数に取り、曜日・月・四半期などの値を返します。\n\n\n::: {.cell filename='日時データに関する関数'}\n\n```{.r .cell-code}\nweekdays(t)\n## [1] \"土曜日\"\n\nweekdays(t, abbreviate = T) # 省略形\n## [1] \"土\"\n\nweekdays(as.POSIXlt(t, tz=\"EST\")) # US時間に変更しても、日本語で出てくる\n## [1] \"金曜日\"\n\n\nt2 <- c(as.POSIXct(\"2023-10-10 11:11:11\"), as.POSIXct(\"2024-1-11 11:11:11\"))\nweekdays(t2) # ベクターでも処理可能\n## [1] \"火曜日\" \"木曜日\"\n\nmonths(t2) # 月を返す関数\n## [1] \"10月\" \"1月\"\n\nquarters(t2) # 四半期を返す関数\n## [1] \"Q4\" \"Q1\"\n```\n:::\n\n\n## 文字列を日時データに変換する\n\nExcelやテキストファイルなどでは、日時データは文字列や数値で保存されています。Rでは文字列や数値をそのまま日時データとして取り扱うことはできないため、日時データに変換する必要があります。日時データへの変換にも、`as.POSIXct`関数や`as.POSIXlt`関数を用います。\n\n文字列は、日本人が通常使うような日時の表現（`\"2022/2/22 11:11:11\"`や`\"2022-2-22 11:11:11\"`など）であれば、その文字列のみを引数に取り、`as.POSIXct`関数や`as.POSIXlt`関数で日時クラスに変換できます。\n\nただし、単に日時の数値を並べた文字列や、年月日等の日本語が混じった文字列では、どのような日時データなのかRが読み解くことができないため、`as.POSIXct`関数や`as.POSIXlt`関数で直接日時データに変換することはできません。\n\nこのように、文字列を日時データに変換する場合には、変換のルールである**フォーマット**を指定する必要があります。フォーマットとは、%（パーセント）に特定のアルファベットを付けて、年や月、分などを指定するものです。例えば、年であれば`%Y`や`%y`、月であれば`%m`が対応するフォーマットとなります。フォーマットの一覧を以下の表2に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表2：日時formatの記載一覧\n\n|記号 |意味                                            |\n|:----|:-----------------------------------------------|\n|%a   |省略した曜日名（Mon, Tueなど）                  |\n|%A   |省略しない曜日名（Mondayなど）                  |\n|%b   |省略した月名（Jan，Febなど）                    |\n|%B   |省略しない月名（Januaryなど）                   |\n|%c   |日時（通常表示はこれ，%Y-%m-%d %H:%M:%Sと同じ） |\n|%C   |世紀                                            |\n|%d   |日（01-30日）                                   |\n|%D   |日付（%Y-%m-%dと同じ）                          |\n|%e   |日（1-30日，ゼロがないもの）                    |\n|%F   |%Y-%m-%dと同じ                                  |\n|%g   |week-based-yearの最後2桁（1-99）                |\n|%G   |week-based-year（01-99）                        |\n|%h   |%bと同じ                                        |\n|%H   |時間（00-23）                                   |\n|%I   |時間（00-12）                                   |\n|%j   |年基準の日数（001-366）                         |\n|%m   |月（01-12）                                     |\n|%M   |分（00-59）                                     |\n|%n   |新しい行（出力），スペース（入力）              |\n|%p   |AM・PMの表記                                    |\n|%r   |%I:%M:%S %pと同じ                               |\n|%R   |%H:%Mと同じ                                     |\n|%S   |秒（00-61）                                     |\n|%t   |タブ切り（出力），スペース（入力）              |\n|%T   |%H:%M:%Sと同じ                                  |\n|%u   |週の日数（1-7，1は月曜）                        |\n|%U   |日曜日を始めとするweek of the year（00-53）     |\n|%V   |ISO8601に従ったweek of the year（01-53）        |\n|%w   |週の日数（0-6，0は日曜）                        |\n|%W   |月曜日を始めとするweek of the year（00-53）     |\n|%x   |%y/%m/%dと同じ                                  |\n|%X   |%H:%M:%Sと同じ                                  |\n|%y   |世紀表現なしの年（00-99）                       |\n|%Y   |正規表現込みの年（2023など）                    |\n|%z   |UTCからの時間差表現（-0800など）                |\n|%Z   |タイムゾーンの出力                              |\n\n\n:::\n:::\n\n\nフォーマットを利用することで、日本語の混じった文字列や、単に数値だけの文字列であっても、日時データに変換することができます。\n\n\n::: {.cell filename='フォーマットを用いた日時データへの変換'}\n\n```{.r .cell-code}\nas.POSIXlt(\"2022-2-22 11:11:11\")\n## [1] \"2022-02-22 11:11:11 +09\"\n\nas.POSIXlt(\"2022/2/22 11:11:11\")\n## [1] \"2022-02-22 11:11:11 +09\"\n\nas.Date(\"2022/10/22\")\n## [1] \"2022-10-22\"\n\n\nas.POSIXct(\"20221022 111111\") # エラー\n## Error in as.POSIXlt.character(x, tz, ...): character string is not in a standard unambiguous format\n\nas.POSIXct(\"20221022 111111\", format = \"%Y%m%d %H%M%S\") # フォーマットを設定\n## [1] \"2022-10-22 11:11:11 +09\"\n\nas.Date(\"20221022\", format = \"%Y%m%d\")\n## [1] \"2022-10-22\"\n\n # 漢字が混じっていても、フォーマットを設定すると日時データに変換できる\nas.POSIXct(\"2022年10月22日 11時11分11秒\", format = \"%Y年%m月%d日 %H時%M分%S秒\")\n## [1] \"2022-10-22 11:11:11 +09\"\n```\n:::\n\n\n## 数値を日時データに変換する\n\n`as.Date`や`as.POSIXct`の引数に数値を指定すると、1970年1月1日からの日数・秒数に従い日時データに変換されてしまいます。したがって、数値を日時データに変換する場合には、まず文字列に変換しておく必要があります。\n\n\n::: {.cell filename='数値から日時データへの変換'}\n\n```{.r .cell-code}\nas.Date(20221022, format = \"%Y%m%d\") # 数値はうまく変換できない\n## [1] \"57333-04-12\"\n\n20221022 |> as.character() |> as.Date(format = \"%Y%m%d\") # 文字列に変換する\n## [1] \"2022-10-22\"\n```\n:::\n\n\n### ISOdatetime関数で日時データを作成する\n\n`ISOdatetime`関数を用いて日時データを作成することもできます。`ISOdatetime`関数は引数に年、月、日、時、分、秒の数値を取り、引数に応じた日時データをPOSIXctクラスで返します。\n\n\n::: {.cell filename='ISOdatetime関数'}\n\n```{.r .cell-code}\nISOdatetime(2022, 2, 22, 2, 22, 22) # POSIXct型の2022/2/22 2:22:22を作成\n## [1] \"2022-02-22 02:22:22 +09\"\n```\n:::\n\n\n## 連続した日時データの作成\n\nココまでは、1つの日時データの作成について見てきました。しかし、統計では日時データとして一定間隔で数時間～数年などの連続した時間を取り扱う場合が多いです。このような一定間隔での日時データの作成には、`seq`関数を用います。\n\n数値ベクターでの`seq`関数と同じく、第一引数に始めの日時、第二引数に終わりの日時、`by`引数に時間間隔を入力すると、始めの日時から終わりの日時まで、`by`引数で指定した間隔での連続した日時データを作成することができます。\n\n`seq`関数の引数には`Date`クラスも`POSIXt`クラスも利用することができますが、`Date`クラスと`POSIXt`クラスを同時に用いることはできません。\n\n\n::: {.cell filename='seq関数で連続する日時データを作成する'}\n\n```{.r .cell-code}\nday1 <- as.POSIXlt(\"2022-2-22\")\nday2 <- as.POSIXlt(\"2022-2-26\")\n\n# day1からday2まで、1日置きのベクター\nseq(day1, day2, by=\"day\")\n## [1] \"2022-02-22 +09\" \"2022-02-23 +09\" \"2022-02-24 +09\" \"2022-02-25 +09\"\n## [5] \"2022-02-26 +09\"\n\n# 1日間隔で、5日間のベクター\nseq(day1, by=\"day\", length.out=5)\n## [1] \"2022-02-22 +09\" \"2022-02-23 +09\" \"2022-02-24 +09\" \"2022-02-25 +09\"\n## [5] \"2022-02-26 +09\"\n\n# 1週間間隔で、5週間のベクター\nseq(day1, by=\"week\", length.out=5)\n## [1] \"2022-02-22 +09\" \"2022-03-01 +09\" \"2022-03-08 +09\" \"2022-03-15 +09\"\n## [5] \"2022-03-22 +09\"\n\n# 2週間間隔で、10週間のベクター\nseq(day1, by=\"2 week\", length.out=5)\n## [1] \"2022-02-22 +09\" \"2022-03-08 +09\" \"2022-03-22 +09\" \"2022-04-05 +09\"\n## [5] \"2022-04-19 +09\"\n\nday3 <- as.Date(\"2022-2-22\") # Dateクラスでも同じ演算が使える\nseq(day3, by=\"1 week\", length.out=5)\n## [1] \"2022-02-22\" \"2022-03-01\" \"2022-03-08\" \"2022-03-15\" \"2022-03-22\"\n\nseq(day1, day3, by=\"day\") # POSIXtとDateを同時に使うとエラー\n## Error in seq.POSIXt(day1, day3, by = \"day\"): 'to' must be a \"POSIXt\" object\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## seq関数で連続した日時データを作成する\n\n`seq`関数はジェネリック関数の一つで、引数が数値の場合には`seq.default`関数、整数の場合には`seq.int`関数、引数がPOSIXtの場合には`seq.POSIXt`関数、引数がDateの場合は`seq.Date`関数がそれぞれ実行されます。`seq`関数の第一引数と第二引数のクラスは同じである必要があります。引数にDateとPOSIXtを指定すると、第一引数に従い用いる関数が変化するため（第一引数がDateなら`seq.Date`、POSIXtなら`seq.POSIXt`が呼び出される）、第一引数と第二引数のデータ型が異なるとエラーとなります。\n\n:::\n\n## cut関数\n\n`cut`関数は、第一引数に日時データのベクター、第二引数`by`に時間間隔（`\"weeks\"`、`\"months\"`など）を取り、時間間隔で指定した範囲の日時データを同一の値に変換する関数です。返り値は因子になるため、週や月、年の集計データを収集したい場合などに利用できます。\n\n\n::: {.cell filename='cut関数'}\n\n```{.r .cell-code}\nhdays <- seq(day1, by=\"day\", length.out = 25) # 2022-2-22から25日間のデータ\ncutdays <- cut(hdays, \"weeks\") # hdaysを週ごとに分けて、因子にする\ncutdays[1:14] # 同一週の日時は同じ因子のレベルが振り当てられる\n##  [1] 2022-02-21 2022-02-21 2022-02-21 2022-02-21 2022-02-21 2022-02-21\n##  [7] 2022-02-28 2022-02-28 2022-02-28 2022-02-28 2022-02-28 2022-02-28\n## [13] 2022-02-28 2022-03-07\n## Levels: 2022-02-21 2022-02-28 2022-03-07 2022-03-14\n\nclass(cutdays) # cut関数の返り値は因子\n## [1] \"factor\"\n\nlevels(cutdays) # 週ごとにレベルが設定される\n## [1] \"2022-02-21\" \"2022-02-28\" \"2022-03-07\" \"2022-03-14\"\n```\n:::\n\n\n## 日時データを引数に取る関数\n\n上記の`cut`関数以外にも、Rには日時データを引数に取る関数が多数設定されています。例えば最初の日時、最後の日時を返す`min`・`max`関数、平均の日時を返す`mean`関数、最初と最後の日時を返す`range`関数などが代表例です。日時の差は`difftime`関数で計算することができますが、単に日時データを引き算することでも計算できます。また、特定の単位（年、月、日など）で丸める場合には、`round`関数を用いることができます。\n\n\n::: {.cell filename='日時データの関数演算'}\n\n```{.r .cell-code}\nmin(hdays)\n## [1] \"2022-02-22 +09\"\n\nmax(hdays)\n## [1] \"2022-03-18 +09\"\n\nmean(hdays)\n## [1] \"2022-03-06 +09\"\n\nrange(hdays)\n## [1] \"2022-02-22 +09\" \"2022-03-18 +09\"\n\ndifftime(max(hdays), min(hdays))\n## Time difference of 24 days\n\nmax(hdays) - min(hdays)\n## Time difference of 24 days\n\nround(t, unit=\"year\")\n## [1] \"2025-01-01 +09\"\n```\n:::\n\n\n## 演算を一時停止する：Sys.sleep関数\n\n`Sys.sleep`関数はRの演算の途中で、演算を指定した時間だけ一時停止するための関数です。一時停止する時間（秒）を数値で引数に取ります。\n\n\n::: {.cell filename='Sys.sleep関数'}\n\n```{.r .cell-code}\nSys.sleep(5) # 5秒待つ\n```\n:::\n\n\n## 演算時間の計測\n\n`Sys.time`関数を用いると、演算にかかる時間を計測することができます。繰り返し計算などで、とても時間がかかる演算を含む場合には、あらかじめ演算時間を計測しておくと、繰り返し計算全体でどの程度時間がかかるのか把握しやすくなります。\n\nまず、`Sys.time`関数の返り値である、現在の時刻を変数`t`に代入します。その後何らかの演算を行い（下の例では`Sys.sleep`関数で3秒停止）、その後、演算後の現在時刻から`t`を引くと、`Sys.sleep`関数による演算の時間を計測することができます。`Sys.sleep`関数による3秒の停止以外にも、代入等でわずかに時間がかかるため、3秒よりほんの少し時間がかかっていることが計測できます。\n\n同様の時間計測は、`system.time`関数を用いても行うことができます。`system.time`関数は演算全体を引数に取り、その演算にかかる時間を計測します。\n\n\n::: {.cell filename='プログラムの演算時間を計測する'}\n\n```{.r .cell-code}\nt <- Sys.time() # 現在時刻を記録\nSys.sleep(3) # 3秒スリープ\nSys.time() - t # 現在時刻と記録した時刻の差を計算\n## Time difference of 3.073357 secs\n\n# system.time関数でも演算時間を計測できる\nsystem.time(for(i in 1:1000000){i^2})\n##    user  system elapsed \n##    0.00    0.00    0.01\n```\n:::\n\n\n### tictocパッケージ\n\nもう少しスマートに演算時間を計測する方法を[`tictoc`](https://cran.r-project.org/web/packages/tictoc/index.html)パッケージ [@tictoc_bib]が提供しています。`tictoc`パッケージには`tic`関数と`toc`関数が設定されており、`tic`関数で計測を開始し、`toc`関数で計測を終了、演算時間を返します。\n\n`tic`関数は引数に文字列を取ることができ、`toc`関数で計測時間が返ってくる時に、この`tic`関数の引数を同時に返してくれます。`tic`関数、`toc`関数による時間計測は、**後入れ先出し（Last In, First Out, LIFO）**のルールに従い時間を計測します。ですので、後から`tic`関数で計測をスタートした演算時間は、先の`toc`関数で返ってくる仕組みになっています。\n\n\n::: {.cell filename='tictocパッケージで演算時間を計測'}\n\n```{.r .cell-code}\npacman::p_load(tictoc)\ntic()\nSys.sleep(3)\ntoc()\n## 3.08 sec elapsed\n\ntic(\"first\")\ntic(\"second\")\ntic(\"third\")\ntoc() # 後のtic（third）からの時間がまず返ってくる\n## third: 0 sec elapsed\n\ntoc()\n## second: 0 sec elapsed\n\ntoc() # 先のtic（first）が最後に返ってくる\n## first: 0 sec elapsed\n```\n:::\n\n\n## 時系列データ：tsクラス\n\n**時系列データ（time series data）**は、日時データとセットになった測定値です。例えば、[14章](./chapter14.html)で説明した`Nile`のデータセットは時系列データの代表的な例です。`Nile`は1871年から1970年のナイル川の流量を年ごとに測定したデータです。\n\n\n::: {.cell filename='Nileデータセット'}\n\n```{.r .cell-code}\nNile # 時系列データの代表例：ナイル川の流量\n## Time Series:\n## Start = 1871 \n## End = 1970 \n## Frequency = 1 \n##   [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020\n##  [16]  960 1180  799  958 1140 1100 1210 1150 1250 1260 1220 1030 1100  774  840\n##  [31]  874  694  940  833  701  916  692 1020 1050  969  831  726  456  824  702\n##  [46] 1120 1100  832  764  821  768  845  864  862  698  845  744  796 1040  759\n##  [61]  781  865  845  944  984  897  822 1010  771  676  649  846  812  742  801\n##  [76] 1040  860  874  848  890  744  749  838 1050  918  986  797  923  975  815\n##  [91] 1020  906  901 1170  912  746  919  718  714  740\n```\n:::\n\n\nこのような時系列データをRで取り扱うために準備されているクラスが、**tsクラス**です。tsクラスには計測されたデータと共に、日時に関する情報が付属しています。\n\n\n::: {.cell filename='tsクラスのattribute'}\n\n```{.r .cell-code}\nattributes(Nile) # 日時に関するattribute（tsp）が記録されている\n## $tsp\n## [1] 1871 1970    1\n## \n## $class\n## [1] \"ts\"\n```\n:::\n\n\ntsクラスを引数とする関数が、Rには複数備わっています。tsクラスを引数とする関数の一覧を以下の表3に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表3：tsクラスを引数とする関数群\n\n|関数名                  |適用する演算                                             |\n|:-----------------------|:--------------------------------------------------------|\n|ts(x, frequency, start) |frequency周期で，startから始まるtsオブジェクトを作成する |\n|as.ts(x)                |tsに変換する                                             |\n|is.ts(x)                |tかどうか確認する                                        |\n|tsp(x)                  |tsオブジェクトを変換する                                 |\n|cycle(x)                |frequencyの周期の位置を返す                              |\n|frequency(x)            |frequencyを返す                                          |\n|deltat(x)               |データの時間間隔を返す                                   |\n|window(x, start, end)   |startからendまでのデータを返す                           |\n|time(x)                 |時間に変換する                                           |\n|start(x)                |開始日時を返す                                           |\n|end(x)                  |終了日時を返す                                           |\n\n\n:::\n:::\n\n::: {.cell filename='tsクラスの作成と演算'}\n\n```{.r .cell-code}\nvalue <- rep(1:3, 8) # 時系列の元になる値\n# tsクラスの変数を作成\ntsobj <- ts(value, frequency = 1, start=c(2023)) \ntsobj # 2023年から2046年までのtsクラスのデータ\n## Time Series:\n## Start = 2023 \n## End = 2046 \n## Frequency = 1 \n##  [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\nas.ts(1:12) # tsに変換\n## Time Series:\n## Start = 1 \n## End = 12 \n## Frequency = 1 \n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\ntsobj |> is.ts() # tsオブジェクトであることを確認\n## [1] TRUE\n\nts(value, frequency = 4, start=c(2023)) # 4半期ごとのデータ\n##      Qtr1 Qtr2 Qtr3 Qtr4\n## 2023    1    2    3    1\n## 2024    2    3    1    2\n## 2025    3    1    2    3\n## 2026    1    2    3    1\n## 2027    2    3    1    2\n## 2028    3    1    2    3\n\nts(value, frequency = 12, start=c(2023)) # 月次のデータ\n##      Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n## 2023   1   2   3   1   2   3   1   2   3   1   2   3\n## 2024   1   2   3   1   2   3   1   2   3   1   2   3\n\ntsobj2 <- ts(value, frequency = 4, start=c(2023))\ntsobj2 |> tsp() # 2023年から2028年4Qまで四半期置きのデータ\n## [1] 2023.00 2028.75    4.00\n\ntsobj2 |> cycle() # 四半期（cycle）についてのラベル\n##      Qtr1 Qtr2 Qtr3 Qtr4\n## 2023    1    2    3    4\n## 2024    1    2    3    4\n## 2025    1    2    3    4\n## 2026    1    2    3    4\n## 2027    1    2    3    4\n## 2028    1    2    3    4\n\ntsobj2 |> frequency() # frequencyは4\n## [1] 4\n\ntsobj2 |> deltat() # データの間隔は1/4年\n## [1] 0.25\n\n# 2025年1Qから2026年4Qまでのデータを返す\ntsobj2 |> window(c(2025, 1), c(2026, 4)) \n##      Qtr1 Qtr2 Qtr3 Qtr4\n## 2025    3    1    2    3\n## 2026    1    2    3    1\n\ntsobj2 |> time() # 各データの時点に変換\n##         Qtr1    Qtr2    Qtr3    Qtr4\n## 2023 2023.00 2023.25 2023.50 2023.75\n## 2024 2024.00 2024.25 2024.50 2024.75\n## 2025 2025.00 2025.25 2025.50 2025.75\n## 2026 2026.00 2026.25 2026.50 2026.75\n## 2027 2027.00 2027.25 2027.50 2027.75\n## 2028 2028.00 2028.25 2028.50 2028.75\n\ntsobj2 |> start() # 2023年1Qからのデータ\n## [1] 2023    1\n\ntsobj2 |> end() # 2028年4Qまでのデータ\n## [1] 2028    4\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## tsクラスの利用\n\n時系列データを取り扱う場合に、必ずしもtsクラスのオブジェクトを用いないといけない、というわけではありません。日時データと値の2つのベクターを用いても、時系列の解析を行うことはできます。\n\n時系列データの解析には、[Stan](https://mc-stan.org/) [@carpenter2017stan]などの外部ツールを用いる場合もあるため、場合によってはtsクラスではないデータの方が取り扱いやすい場合もあります。\n\n:::\n\n## lubridateパッケージ\n\n上記のように、Rには時間を取り扱うクラスとして、Date、POSIXct、POSIXlt、tsなどを備えています。ただし、フォーマットの設定や関数に見られるように、必ずしもすべてのクラスが時系列データの解析において使いやすい、というわけではありません。\n\nRでの日時データの取り扱いを簡単にするためのライブラリが、[`lubridate`](https://lubridate.tidyverse.org/)パッケージ [@lubridate_bib]です。`lubridate`パッケージは日時データを取り扱うための関数のセットを提供しており、様々なフォーマットの文字列を簡単に日時データに変換し、演算に用いることができます。\n\n`lubridate`パッケージが提供する関数群を以下の表4に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表4：lubridateパッケージの関数群\n\n|関数名                    |適用する演算                                           |\n|:-------------------------|:------------------------------------------------------|\n|ymd(x), mdy(x), dmy(x)    |xを日付に変換                                          |\n|ymd_hms(x), ymd_hm(x)     |xを日時に変換                                          |\n|hms(x)                    |xを時間に変換                                          |\n|parse_date_time(x, order) |xをorderに従い日時に変換                               |\n|year(x)                   |xの年を返す                                            |\n|year(x)<-                 |xの年を代入値に変換する                                |\n|month(x)                  |xの月を返す                                            |\n|day(x)                    |xの日を返す                                            |\n|hour(x)                   |xの時間を返す                                          |\n|minute(x)                 |xの分を返す                                            |\n|second(x)                 |xの秒を返す                                            |\n|tz(x)                     |タイムゾーンを返す                                     |\n|now()                     |現在の日時を返す                                       |\n|today()                   |現在の日付を返す                                       |\n|stamp(char)(x)            |xをcharの文字列に合わせて返す                          |\n|duration(x, units)        |単位がunits，値がxの時間差（period）オブジェクトを作成 |\n|years(n)                  |n年のperiodオブジェクトを作成                          |\n|months(n)                 |n月のperiodオブジェクトを作成                          |\n|days(n)                   |n日のperiodオブジェクトを作成                          |\n|hours(n)                  |n時間のperiodオブジェクトを作成                        |\n|minutes(n)                |n分のperiodオブジェクトを作成                          |\n|seconds(n)                |n秒のperiodオブジェクトを作成                          |\n|am(x)                     |xが午前中ならTRUEを返す                                |\n|pm(x)                     |xが午後ならTRUEを返す                                  |\n|interval(x, y)            |xとyのintervalオブジェクトを作成                       |\n|int_length(x)             |xの期間の長さを返す                                    |\n|int_overlaps(x, y)        |xとyに時間の重なりがあればTRUEを返す                   |\n\n\n:::\n:::\n\n\n### 日付データへの変換：ymd関数\n\n文字列を日時データに変換する場合、`as.POSIXlt`関数や`as.Date`関数で、フォーマットを指定するのがRのデフォルトの手法です。この手順を簡単に行うことができる関数が、`ymd`関数を含む関数群です。`ymd`は、「year, month, day」の略で、この年月日の順で数値が記載された文字列や数値であれば、かなり適当に記載した文字列・数値であっても、正確に日時データに変換してくれます。\n\n日本では年月日の順で日付を書くのが一般的ですが、アメリカでは月日年、ヨーロッパでは日月年の順で日付を書くことになっています。このように、年月日の順番が異なる場合には、`ymd`関数ではなく、`mdy`関数や`dmy`関数を用いることで、日時データに簡単に変換することができます。\n\n\n::: {.cell filename='ymd・mdy・dmy関数でDateに変換'}\n\n```{.r .cell-code}\npacman::p_load(lubridate)\n\n# どんな書き方でも変換してくれる\nymd(\"20231020\")\n## [1] \"2023-10-20\"\n\nymd(\"2023/10/20\")\n## [1] \"2023-10-20\"\n\nymd(\"2023-10-20\")\n## [1] \"2023-10-20\"\n\nymd(\"23 10 20\")\n## [1] \"2023-10-20\"\n\nymd(\"2023年10月20日\") # 漢字が入っていても変換可能\n## [1] \"2023-10-20\"\n\nymd(20231020) # 数値でも変換可能\n## [1] \"2023-10-20\"\n\nymd(231020)\n## [1] \"2023-10-20\"\n\nmdy(\"10/20/2023\") # USでは月/日/年\n## [1] \"2023-10-20\"\n\ndmy(\"20/10/2023\") # ヨーロッパでは日/月/年\n## [1] \"2023-10-20\"\n\nym(\"2023/10\") # yearとmonthだけのデータも対応できる\n## [1] \"2023-10-01\"\n```\n:::\n\n\n### 日時データの変換：ymd_hms関数\n\n時間を含むデータの場合には、`ymd_hms`関数などの関数群を用います。こちらも、かなりいい加減な記載の日時データでも、簡単にPOSIXctクラスに変換してくれます（デフォルトのタイムゾーンはUTC、グリニッジ標準時）。タイムゾーンはtz引数に文字列で指定（[TZ identifier](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)で指定）することで変更できます。\n\n\n::: {.cell filename='ymd_hms関数でPOSIXctに変換'}\n\n```{.r .cell-code}\nymd_hms(\"2023/10/20 22:22:22\") # POSIXctに変換\n## [1] \"2023-10-20 22:22:22 UTC\"\n\nymd_hms(\"2023年10月20日 22時22分22秒\") # POSIXctに変換\n## [1] \"2023-10-20 22:22:22 UTC\"\n\nymd_hms(231020222222) # 数値も変換できる\n## [1] \"2023-10-20 22:22:22 UTC\"\n\nymd_hms(\"2023年10月20日 22時22分22秒\", tz=\"Asia/Tokyo\") # JSTに変換\n## [1] \"2023-10-20 22:22:22 JST\"\n```\n:::\n\n\n`ymd`関数群や`ymd_hms`関数群などの機能を1つの関数に落とし込んだものが、`parse_date_time`関数です。この`parse_date_time`関数では、関数名で年月日の順番を指定するのではなく、`orders`という引数で年月日、時間の順番を指定します。\n\n\n::: {.cell filename='parse_date_timeで日時データに変換'}\n\n```{.r .cell-code}\nparse_date_time(\"2023/12/21\", \"ymd\")\n## [1] \"2023-12-21 UTC\"\n\nparse_date_time(\"2023/12/21 12:25:30\", \"ymdHMS\")\n## [1] \"2023-12-21 12:25:30 UTC\"\n```\n:::\n\n\n`lubridate`には、日時データから年や月などの一部を取り出す関数群として、`year`、`month`、`week`、`day`、`hour`、`minute`、`second`が設定されています。日時データを引数に取り、関数に数値を代入することで、特定の値を変更することもできます。\n\nまた、日時データのタイムゾーンを`tz`関数で取得することができ、日時データを引数に取った`tz`関数にタイムゾーンを代入することで、タイムゾーンを変更することもできます。\n\n\n::: {.cell filename='lubridateの日時データ演算に関する関数'}\n\n```{.r .cell-code}\nt <- ymd(\"2023/10/20\") # Dateクラスの変数を作成\nyear(t)\n## [1] 2023\n\nyear(t) <- 2024 # 代入で変更できる\nt\n## [1] \"2024-10-20\"\n\ntz(t) # タイムゾーンを返す関数\n## [1] \"UTC\"\n\ntz(t) <- \"Asia/Tokyo\" # 代入でタイムゾーンも変更可能\ntz(t)\n## [1] \"Asia/Tokyo\"\n```\n:::\n\n\n### 現在時刻の取得：today関数とnow関数\n\n`Sys.Date`関数や`Sys.time`関数と同じような関数として、`lubridate`には`today`関数と`now`関数が設定されています。\n\n\n::: {.cell filename='today・now関数'}\n\n```{.r .cell-code}\ntoday() # 今日の日付\n## [1] \"2025-03-29\"\n\nnow() # 今の日時\n## [1] \"2025-03-29 08:11:45 +09\"\n```\n:::\n\n\n### 時刻を整形した文字列に変換：stamp関数\n\n`stamp`関数は日時データを整形し、文字列として返すための関数です。`stamp`関数の引数は日時を表記するための文字列で、日時自体はどのような時間でも問題ありません。`stamp`関数の後にカッコを付けて、カッコ内に文字列に変換したい日時データを与えます。この関数を実行すると、カッコ内の日時データを、`stamp`関数の引数の形に従って整形した文字列に変換して返してくれます。\n\n文字列が日付のみで、日時データがPOSIXctなどの時間を含むデータだと、正しく変更できない場合もあります。\n\n\n::: {.cell filename='stamp関数で文字列に変換する'}\n\n```{.r .cell-code}\nstamp(\"1970/1/1 12:00:00\")(now())\n## Multiple formats matched: \"%Y/%Om/%d %H:%M:%S\"(1), \"%Y/%d/%Om %H:%M:%S\"(1), \"%Y/%m/%d %H:%M:%S\"(1), \"%Y/%d/%m %H:%M:%S\"(1)\n## Using: \"%Y/%Om/%d %H:%M:%S\"\n## [1] \"2025/03/29 08:11:45\"\n\nstamp(\"1970/1/1 12:00:00に作成されたデータ\")(now())\n## Multiple formats matched: \"%Y/%Om/%d %H:%M:%Sに作成されたデータ\"(1), \"%Y/%d/%Om %H:%M:%Sに作成されたデータ\"(1), \"%Y/%m/%d %H:%M:%Sに作成されたデータ\"(1), \"%Y/%d/%m %H:%M:%Sに作成されたデータ\"(1)\n## Using: \"%Y/%Om/%d %H:%M:%Sに作成されたデータ\"\n## [1] \"2025/03/29 08:11:45に作成されたデータ\"\n\n# うまくいかないときもある（月と日を曜日に変換している）。\nstamp_date(\"1970年01月01日\")(now()) \n## Multiple formats matched: \"%Y年%Om%a%d%a\"(1), \"%Y年%d%a%Om%a\"(1), \"%Y年%m%a%d%a\"(1), \"%Y年%d%a%m%a\"(1), \"%Y年%Om月%d日\"(1), \"%Y年%d月%Om日\"(1), \"%Y年%m月%d日\"(1), \"%Y年%d月%m日\"(1)\n## Using: \"%Y年%Om%a%d%a\"\n## [1] \"2025年03土29土\"\n```\n:::\n\n\n## periodクラス\n\nココまではDateクラス、POSIXct・POSIXlt型に関する`lubridate`の関数について示してきました。`lubridate`には、Date・POSIXct・POSIXlt以外に、時間の間隔を取り扱うクラスとして、**periodクラス**が備わっています。\n\nDateクラスやPOSIXctクラスは基本的に数値型ですので、足し算や引き算で日時を変更することができます。ただし、例えばPOSIXct型で1年3ヶ月と10日後の、3時間前といった変更をしたい場合には、すべて秒として換算し直して演算を行う必要があります。これはあまり直感的ではありませんし、月ごとに日数が異なっているため、正確に演算することも困難です。\n\n\n::: {.cell filename='periodでの演算'}\n\n```{.r .cell-code}\ntoday()\n## [1] \"2025-03-29\"\n\ntoday() + 10 # 10日後\n## [1] \"2025-04-08\"\n\nnow()\n## [1] \"2025-03-29 08:11:45 +09\"\n\nnow() + 60 # 1分後\n## [1] \"2025-03-29 08:12:45 +09\"\n\ntoday() + 365 * 1 + 3 * 30 + 10 # 1年3ヶ月と10日後\n## [1] \"2026-07-07\"\n```\n:::\n\n\nこのような複雑な日時データの演算に対応するため、`lubridate`ではperiodクラスのオブジェクトを作成し、このオブジェクトを演算に用いることができるようになっています。\n\nperiodクラスのオブジェクトを作成するには、`duration`関数を用いる、または、`years`、`months`、`days`、`hours`、`minutes`、`seconds`の、「時間の単位+s」の名前が付いた関数を用います。\n\n`duration`関数は引数に数値と時間の単位を取り、引数の時間単位で数値の値を持つオブジェクトを作成する関数です（クラスはDuration）。このオブジェクトはDateクラスやPOSIXctクラスとの演算に用いることができます。\n\n例えば、Periodクラスのオブジェクトである`months(20)`を用いて、「`now() + months(20)`」とすると、現在時刻から20ヶ月後を演算することができます。「1年3ヶ月と10日後の、3時間前」といった複雑な計算も、このperiodクラスを用いれば簡単に行うことができます。\n\n\n::: {.cell filename='periodクラスを作成する関数群'}\n\n```{.r .cell-code}\nduration(90, \"seconds\") # 90秒のperiod\n## [1] \"90s (~1.5 minutes)\"\n\nnow() + duration(10, \"years\") # 10年後\n## [1] \"2035-03-29 20:11:45 +09\"\n\nnow() + years(10) # 上と同じ\n## [1] \"2035-03-29 08:11:45 +09\"\n\nnow() + months(20) # 20ヶ月後\n## [1] \"2026-11-29 08:11:45 +09\"\n\nnow() + days(30)\n## [1] \"2025-04-28 08:11:45 +09\"\n\nnow() + hours(40)\n## [1] \"2025-03-31 00:11:45 +09\"\n\nnow() + minutes(50)\n## [1] \"2025-03-29 09:01:45 +09\"\n\nnow() + seconds(60)\n## [1] \"2025-03-29 08:12:45 +09\"\n```\n:::\n\n\n### hms関数\n\n時間に関するperiodクラスのオブジェクトを作成する場合には、`ymd`関数のように、文字列を自動的にperiodクラスのオブジェクトに変換してくれる関数である、`hms`関数を用いることができます。`hms`関数は文字列を時・分・秒を持つperiodクラスのオブジェクトに変換し、返してくれます。`ymd`とは異なり、`hms`関数は数値をperiodに変換することはできません。\n\n\n::: {.cell filename='hms関数でperiodクラスオブジェクトを作成'}\n\n```{.r .cell-code}\nhms(\"2:22:22\")\n## [1] \"2H 22M 22S\"\n\nhms(22222) # エラー\n## Warning in .parse_hms(..., order = \"HMS\", quiet = quiet): Some strings failed\n## to parse\n## [1] NA\n```\n:::\n\n\n### 時間の切り上げ・切り下げ\n\n日時データを四捨五入する際には、Rの`round`関数を用いることができます。ただし、切り下げ（`floor`）や切り上げ（`ceiling`）の関数は、DateクラスやPOSIXtクラスには対応していません。\n\n日時の四捨五入・切り下げ・切り上げには、`round_date`、`floor_date`、`ceiling_date`関数を用いることができます。切り上げ等の単位は、`unit`引数に指定します。\n\n\n::: {.cell filename='日時の四捨五入'}\n\n```{.r .cell-code}\nnow() |> round_date(unit=\"month\") # 月で四捨五入\n## [1] \"2025-04-01 +09\"\n\nnow() |> floor_date(unit=\"hour\") # 時間で切り下げ\n## [1] \"2025-03-29 08:00:00 +09\"\n\nnow() |> ceiling_date(unit=\"hour\") # 時間で切り上げ\n## [1] \"2025-03-29 09:00:00 +09\"\n```\n:::\n\n\n### am・pm関数\n\n日時データが午前か午後かを判別する関数が、`am`関数と`pm`関数です。共に論理型（`TRUE`・`FALSE`）を返す関数で、引数が午前なら`am`関数は`TRUE`、`pm`関数は`FALSE`を返します。\n\n\n::: {.cell filename='am・pm関数'}\n\n```{.r .cell-code}\nnow() |> am()\n## [1] TRUE\n\nnow() |> pm()\n## [1] FALSE\n```\n:::\n\n\n### interval\n\n`lubridate`には、ある期間（interval）を評価するためのクラスとして、Intervalクラスが設定されています。このIntervalクラスのオブジェクトは`interval`関数に始めと最後の日時を与えることで作成できます。Intervalの期間の長さは`int_length`関数で、2つのIntervalクラスオブジェクトに重複があるかどうかは`int_overlaps`関数を用いて判別できます。\n\n\n::: {.cell filename='Intervalの取り扱い'}\n\n```{.r .cell-code}\nintr1 <-  interval(ymd(\"2023-10-20\"), ymd(\"2023-10-30\"))\nintr2 <-  interval(ymd(\"2023-10-25\"), ymd(\"2023-11-5\"))\n\nintr1 # 始めと最後の日が記録されている\n## [1] 2023-10-20 UTC--2023-10-30 UTC\n\nintr1 |> class() # データ型はInterval\n## [1] \"Interval\"\n## attr(,\"package\")\n## [1] \"lubridate\"\n\nint_length(intr1) # 期間の長さの単位は秒\n## [1] 864000\n\nint_overlaps(intr1, intr2) # 重複があればTRUEが返ってくる\n## [1] TRUE\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}