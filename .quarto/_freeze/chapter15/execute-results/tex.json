{
  "hash": "f28c4a75358314ae776a5c8af8e760d8",
  "result": {
    "markdown": "# apply関数群\n\nRを代表する便利な関数やライブラリは何か？、と聞かれると、2010年ごろまでは<font color=\"red\">**apply関数群**</font>を挙げるのが一般的でした。apply関数群を用いれば、他の言語では繰り返し計算で数行プログラムを書かないといけないような状況でも、たった1つの関数で高速に計算ができます。当時、Rでは繰り返し計算を使わず、apply関数群を使うのが標準的な方法でした。現在では、2010年以降に開発された<font color=\"red\">**dplyr・tidyrパッケージ**</font>を用いて計算を行うのが一般的となり、apply関数群は使われなくなってきていますが、ちょっとした機会に使うと便利な関数群です。\n\nこの章では、まず繰り返し計算によるベクター・データフレームの計算について解説し、次に繰り返しを用いず計算を行うapply関数群について説明していきます。\n\n\n## 繰り返し計算\n\nベクターのような，多数の要素を含むオブジェクトを用いて演算を行う場合，R以外の言語では通常**繰り返し計算**を用います．繰り返し計算は5章で説明した通り，for文やwhile文，repeat文などです．プログラミング言語によって繰り返し計算の形は異なりますが，たくさんの要素を持つオブジェクトの演算では，繰り返し計算は有効な計算方法の一つです．\n\n## 繰り返し計算とベクター\n\nでは，Rでの繰り返し計算を見てみましょう．下の例では，ベクターの要素に演算を行い，結果をベクターで返す繰り返し計算を行っています．\n\nRでfor文を用いてベクターの要素に演算を行う場合には，\n\n-   NULLを代入しただけの空っぽの変数を作る\n-   繰り返し回数を演算に用いるベクターの長さで指定する\n-   ベクターの要素をインデックスで取り出し，演算する\n-   空っぽの変数に，c関数で演算結果を付け足す\n\nといった計算を行うことがあります．\n\n下の例では，変数vは1～10の連続する長さ10の整数ベクター，v_newはNULL（空）のオブジェクトです．\n\nfor文では，iに1:length(v)の要素が繰り返し計算ごとに代入されます．つまり1回目の繰り返し計算ではiは1，2回目ではiは2...となり，iにlength(v)，つまり10が代入された計算が終わると，繰り返し計算が終了します．\n\nさらに，for文中では，v\\[i\\]，つまりiをインデックスにしてvの要素を取り出しています．1回目の繰り返し計算ではiが1ですので，v\\[i\\]はvの1つ目の要素，2回目の繰り返し計算ではv\\[i\\]はvの2つ目の要素となります．v\\[i\\]を3倍して5を足した結果を一時的にtempという変数に代入しています．\n\nfor文の中では，**「v_new \\<- c(v_new, temp)」**という形で，空の変数であるv_newに，計算結果をc関数で繋いだものを，v_newに代入する，という変な演算を行っています．この演算では，1週目ではc(NULL, temp)をv_newに代入することで，v_newはtempを1つだけ持つベクターに変化しています．2週目以降は，v_newのベクターの要素の後に新しく計算したtempが付け加えられます．これを繰り返すことで，v_newにはtempの計算結果がベクターとして記録されていきます．\n\n最終的に，v_newはvの各要素を3倍して5を足したベクターとして演算が終了します．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- 1:10 # vは1~10の整数ベクター\n\nv_new <- NULL # 計算結果を代入するNULLが入った変数\n\nfor(i in 1:length(v)){ # vの長さ分計算する\n  temp <- v[i] * 3 + 5\n  v_new <- c(v_new, temp) # v_newにv[i]を演算した結果をつなげる\n}\n\nv_new # 演算結果\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  8 11 14 17 20 23 26 29 32 35\n```\n:::\n:::\n\n\n上記のようなfor文の演算は，Rでは非常によろしくない，典型的なバッドノウハウであるとされています．そもそもRでのベクターの演算に繰り返し文を使う必要がないので，上記のfor文は下のように書き換えることができます．**ベクターの演算の方が，for文を用いた演算よりずっと速い**ため，Rでベクターの要素を演算に用いる場合には，繰り返し計算ではなく，ベクターの演算を用いることが推奨されています．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv * 3 + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  8 11 14 17 20 23 26 29 32 35\n```\n:::\n:::\n\n\n上のfor文にはもう一点問題があります．v_newというベクターに対して，数値を付け足すという演算を繰り返しています．このような場合，v_newの長さが伸びていくため，Rの内部では，**要素が付け加えられる度にv_newというベクターを新しく作り直し，古いものは削除する**という演算が行われることになります．この**「作り直し」て「削除する」**という演算に時間がかかるため，上記のような書き方では演算速度に問題が生じます．\n\nこのような「作り直し」て「削除する」プロセスを省くためには，インデックスに代入する方法を用います．あらかじめ結果と同じ長さのベクターを準備しておき，このベクターの要素に演算結果を代入します．このような形にすると，v_new自体を作り直すプロセスがなくなり，演算速度が速くなるとされています．\n\nこの，結果と同じ長さのベクターを準備するときには，<font color=\"red\">**numeric関数**</font>を用います．numeric関数は数値を1つ引数に取り，数値に応じた長さの，要素が0だけのベクターを作成する関数です．このnumeric関数を用いて演算結果と同じ長さのベクターを作成しておくことで，そのインデックスに演算結果を代入していくことができます．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeric(5) # 0が5つ入ったベクター\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\nv_new <- numeric(length(v)) # v_newは0がvと同じ長さだけ並んだベクター\n\nfor(i in 1:length(v)){ # vの長さ分計算する\n  v_new[i] <- v[i] * 3 + 5 # v_new[i]にv[i]を演算した結果を代入\n}\n\nv_new # 演算結果\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  8 11 14 17 20 23 26 29 32 35\n```\n:::\n:::\n\n\n## 繰り返し計算とデータフレーム\n\nデータフレームの要素に対して繰り返し計算をする場合にも、上のベクターでの繰り返し計算と同様の手法が使えます。下の計算では、iris_editedという変数にNULLを代入し、この空のiris_editedにベクターをrbind関数で結合したものをiris_editedに代入するという計算をしています。rbind関数は行を追加する関数ですので、計算結果を含むベクターはiris_editedの一番下の行に追加されます。\n\nこのような繰り返し計算を行うと、iris_editedは自動的にNULLから<font color=\"red\">**行列**</font>に変換されます。また、計算途中でiris$Species（因子）を文字列に変換し、文字列と数値の計算結果をベクターにまとめているため、数値計算結果は自動的に文字列に変換されています。その結果、繰り返し計算後に得られるiris_editedは**文字列の行列**になっています。\n\n行列は、as.data.frame関数でデータフレームに変換できます。ただし、文字列の行列の要素は文字列型のまま変換されるため、結果が数値に見えても文字列になっている場合があります．\n\nこのように、データフレームを直接繰り返し計算に用いると、データ型の変換が頻繁に起こり、計算結果を予測するのが難しくなります。繰り返し計算時には、取り扱っている変数の型がどのように変化しているのか、常に注意が必要です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n\n```{.r .cell-code}\niris_edited <- NULL\n\nfor(i in 1:nrow(iris)){\n  # iris$Speciesは因子で、そのままだと数値に変換されるため、文字列に変換しておく\n  species <- as.character(iris$Species[i]) \n  \n  # Sepal.LengthとSepal.Widthの積を計算\n  Sepal_multiple <- iris$Sepal.Length[i] * iris$Sepal.Width[i]\n  \n  # species（文字列）と計算結果をベクターにまとめる（文字列のベクターに変換）\n  temp_vec <- c(species, Sepal_multiple)\n  \n  # ベクターをiris_editedの行として追加（iris_editedは行列になる）\n  iris_edited <- rbind(iris_edited, temp_vec)\n}\n\ndim(iris_edited) # iris_editedは150行2列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 150   2\n```\n:::\n\n```{.r .cell-code}\nclass(iris_edited) # iris_editedは行列（matrix）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nhead(iris_edited) # 文字列の行列になっている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]   \ntemp_vec \"setosa\" \"17.85\"\ntemp_vec \"setosa\" \"14.7\" \ntemp_vec \"setosa\" \"15.04\"\ntemp_vec \"setosa\" \"14.26\"\ntemp_vec \"setosa\" \"18\"   \ntemp_vec \"setosa\" \"21.06\"\n```\n:::\n:::\n\n\nベクターの繰り返し計算で述べたように、変数に要素を追加して，サイズが変化すると、変数を「作り直し」て「削除する」プロセスが繰り返され、計算のコストが大きくなります。計算のコストが大きくなると演算に時間がかかるため、このようなNULLに要素を追加するのは避けた方がよいとされています。ですので、上のような計算では、あらかじめ結果と同じサイズの行列を準備し、その行列の要素に計算結果を追加していくのが良いとされています。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n:::\n\n```{.r .cell-code}\niris_edited <- matrix(0, nrow=150, ncol=2)\n\nfor(i in 1:nrow(iris)){\n  species <- as.character(iris$Species[i])\n  Sepal_multiple <- iris$Sepal.Length[i] * iris$Sepal.Width[i]\n  temp_vec <- c(species, Sepal_multiple)\n  iris_edited[i, ] <- temp_vec\n}\n\ndim(iris_edited) # iris_editedは150行2列\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 150   2\n```\n:::\n\n```{.r .cell-code}\nclass(iris_edited) # iris_editedは行列（matrix）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nhead(iris_edited) # 文字列の行列になっている\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]     [,2]   \n[1,] \"setosa\" \"17.85\"\n[2,] \"setosa\" \"14.7\" \n[3,] \"setosa\" \"15.04\"\n[4,] \"setosa\" \"14.26\"\n[5,] \"setosa\" \"18\"   \n[6,] \"setosa\" \"21.06\"\n```\n:::\n:::\n\n\n上記のように、Rでは繰り返し計算で変数の「作り直し」が起きたり、データ型がころころ変わったりするため、繰り返し計算でベクターやデータフレームの要素を取り扱うのは推奨されていません。ただし、繰り返し計算は演算の過程が捉えやすく、後から読んで理解しやすい構造をしています．NULLオブジェクトにデータを追加していくと、結果として得られるオブジェクトのサイズがわかっていなくても演算できるという利点があります。\n\n2000年頃のPCは性能が低く、計算コストに気を払う必要がありましたが、現在では繰り返し計算を回しても大して時間がかからなくなりました。よほど大きいデータフレーム（数万～数十万行）を取り扱う場合を除けば、繰り返し計算が問題となることは少なくなったと感じます。データの取り扱いが一度きり（ad hoc）の場合には以下のapplyを使っても、繰り返し計算を使っても大差ないため、好みの、わかりやすい方法を用いればよいでしょう。\n\n## apply関数群\n\nRでのデータフレーム演算の「お作法」では、繰り返し計算ではなく、apply関数群を用いることとされています。apply関数群にはapply, mapply, lapply, sapply, tapply, aggregate, byなど、かなりたくさんの関数があり、それぞれ少し癖のある使い方が求められます。以下の表1にapply関数群についてまとめます。\n\n\n::: {.cell}\n::: {.cell-output-display}\nTable: 表1 apply関数群（funは関数，factは因子，marginは方向を指す）\n\n|x                            |\n|:----------------------------|\n|apply(x, margin, fun)        |\n|mapply(fun, 引数1, 引数2...) |\n|lapply(list, fun)            |\n|sapply(list, fun)            |\n|vapply(x, fun, fun.value)    |\n|replicate(n, calc)           |\n|tapply(x, fact, fun)         |\n|sweep(x, margin, y)          |\n|aggregate(x, by, fun)        |\n|aggregate(formula, data)     |\n|by(x, by, fun)               |\n:::\n:::\n\n\n### apply関数\n\napply関数群の中で最も基本的なものが、<font color=\"red\">**apply関数**</font>です。apply関数は第一引数にデータフレーム（もしくは行列）を取り、第二引数にMARGIN、第三引数に関数を取ります。第二引数のMARGINは1か2を取り、1を取ると行（横）方向、2を取ると列（縦）方向のベクターを計算対象とします。apply関数はデータフレームの要素に、MARGINで指定した方向に、第三引数で指定した関数を適用します。第三引数に指定する関数には，Rに備わっている関数，自作した関数の両方を用いることができます．\n\napply関数の演算では、（特に行方向、MARGIN = 1の時には）データ型が一致していることが必要となります。apply関数の使い方を以下の図1に示します。\n\n![図1：apply関数の使い方](./image/chapter15_apply.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(iris[, 1:4], 1, sum) # 行方向に和を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 10.2  9.5  9.4  9.4 10.2 11.4  9.7 10.1  8.9  9.6 10.8 10.0  9.3  8.5 11.2\n [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7  9.4 10.6 10.3  9.8 10.4 10.4 10.2  9.7\n [31]  9.7 10.7 10.9 11.3  9.7  9.6 10.5 10.0  8.9 10.2 10.1  8.4  9.1 10.7 11.2\n [46]  9.5 10.7  9.4 10.7  9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2\n [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9\n [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3\n [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5\n[106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7\n[121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7\n[136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8\n```\n:::\n\n```{.r .cell-code}\napply(iris[, 1:4], 2, sum) # 列方向に和を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       876.5        458.6        563.7        179.9 \n```\n:::\n\n```{.r .cell-code}\n# 自作の関数\nfunc1 <- function(x){sum(sqrt(x) * log(x))}\n\napply(iris[, 1:4], 2, func1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n   638.50578    292.37383    373.96812     32.26917 \n```\n:::\n\n```{.r .cell-code}\n# apply(iris[, 1:4], 2, \\(x){x + 1}) # 無名関数も利用できる\n```\n:::\n\n\n#### 3次元以上のarrayにapplyを適用する \n\napply関数は3次元以上のarrayを引数に取ることもできます。3次元以上のarrayを引数に取る場合には、MARGINの設定がやや複雑になります。MARGINに1つの値を入れた場合には、その次元を残す形で関数を適用します。MARGINに2つの値を入れた場合には、その2つの次元を残して関数を適用します。MARGINに2つ以上の値を指定する際には、ベクターを用います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUCBAdmissions # 3次元アレイ\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , Dept = A\n\n          Gender\nAdmit      Male Female\n  Admitted  512     89\n  Rejected  313     19\n\n, , Dept = B\n\n          Gender\nAdmit      Male Female\n  Admitted  353     17\n  Rejected  207      8\n\n, , Dept = C\n\n          Gender\nAdmit      Male Female\n  Admitted  120    202\n  Rejected  205    391\n\n, , Dept = D\n\n          Gender\nAdmit      Male Female\n  Admitted  138    131\n  Rejected  279    244\n\n, , Dept = E\n\n          Gender\nAdmit      Male Female\n  Admitted   53     94\n  Rejected  138    299\n\n, , Dept = F\n\n          Gender\nAdmit      Male Female\n  Admitted   22     24\n  Rejected  351    317\n```\n:::\n\n```{.r .cell-code}\ndimnames(UCBAdmissions) # 次元の順番はAdmit, Gender, Deptの順\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Admit\n[1] \"Admitted\" \"Rejected\"\n\n$Gender\n[1] \"Male\"   \"Female\"\n\n$Dept\n[1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, 1, mean) # 1次元目（Admit）の平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdmitted Rejected \n146.2500 230.9167 \n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, 2, mean) # 2次元目（Gender）の平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Male   Female \n224.2500 152.9167 \n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, 3, mean) # 3次元目（Dept）の平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     A      B      C      D      E      F \n233.25 146.25 229.50 198.00 146.00 178.50 \n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, 1:2, mean) # 3次元目（Dept）方向に平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Gender\nAdmit          Male    Female\n  Admitted 199.6667  92.83333\n  Rejected 248.8333 213.00000\n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, c(1, 3), mean) # 2次元目（Gender）方向に平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Dept\nAdmit          A     B   C     D     E   F\n  Admitted 300.5 185.0 161 134.5  73.5  23\n  Rejected 166.0 107.5 298 261.5 218.5 334\n```\n:::\n\n```{.r .cell-code}\napply(UCBAdmissions, 2:3, mean) # 1次元目（Admit）方向に平均を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Dept\nGender       A     B     C     D     E     F\n  Male   412.5 280.0 162.5 208.5  95.5 186.5\n  Female  54.0  12.5 296.5 187.5 196.5 170.5\n```\n:::\n:::\n\n\n### mapply関数\n\n**mapply関数**は、関数が2種類以上の引数を取る場合に用います。mapply関数はapply関数とは引数の順番が異なり、適用する関数が第一引数になります。続いて適用する関数の引数をベクターで取ります。mapply関数の返り値は適用する関数により異なり、関数の返り値が1つならmapply関数の返り値はベクター、返り値が2つ以上ならmapply関数の返り値はリストになります。\n\n![図2：mapply関数の使い方](./image/chapter15_mapply.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapply(mean, 1:4, 2:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nlst <- mapply(rep, times = 1:4, x = 4:1) # 関数の引数を指定して、ベクターで与える 複数の引数を取れる\nlst\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 4\n\n[[2]]\n[1] 3 3\n\n[[3]]\n[1] 2 2 2\n\n[[4]]\n[1] 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\n# 無名関数も使える\nmapply(\\(x, y){x / y}, x = 1:5, y = 5:1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2 0.5 1.0 2.0 5.0\n```\n:::\n:::\n\n\n### lapply関数/sapply関数\n\n**lapply関数**はリストを引数に取る関数です。lapply関数は第一引数にリスト、第二引数に関数を取り、リストの各要素に関数を適用します。lapply関数は返り値にリストを取ります。データフレームはリストですので、lapply関数はapply(x, 2, FUN)、つまり列方向に関数を適用するのと同じ計算を行うことができます。\n\n**sapply関数**は返り値がベクターになったlapply関数です。関数の返り値が2つの値であれば、sapply関数は行列を返します。\n\n![図3：lapply/sapply関数の使い方](./image/chapter15_lapply.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(lst, sum) # リストの各要素に関数を適用する（返り値はリスト）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 4\n\n[[2]]\n[1] 6\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nlapply(iris[, 1:4], sum) # データフレームは列方向のリストなので、適用可能\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Sepal.Length\n[1] 876.5\n\n$Sepal.Width\n[1] 458.6\n\n$Petal.Length\n[1] 563.7\n\n$Petal.Width\n[1] 179.9\n```\n:::\n\n```{.r .cell-code}\nlapply(lst, summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      4       4       4       4       4       4 \n\n[[2]]\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      3       3       3       3       3       3 \n\n[[3]]\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      2       2       2       2       2       2 \n\n[[4]]\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      1       1       1       1       1       1 \n```\n:::\n\n```{.r .cell-code}\nsapply(lst, sum) # 返り値がベクターのlapply\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6 6 4\n```\n:::\n\n```{.r .cell-code}\nsapply(iris[, 1:4], sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       876.5        458.6        563.7        179.9 \n```\n:::\n:::\n\n\n### vapply関数\n\n**vapply関数**は関数が複数の返り値を持つときに用いる関数です。vapply関数の第一引数はベクターやリスト、第二引数は複数の返り値を取る関数です。vapply関数はこの返り値を行列に変換するのですが、この変換時の行名をFUN.VALUEという第三引数で設定します。FUN.VALUEの設定は名前付きベクターで、値は0とします。かなり癖が強いので、使われているところをほとんど見たことがない関数です。\n\n![図3：vapply関数の使い方](./image/chapter15_vapply.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfivenum(1:10) # データを5つに集約する関数（最小値、第一四分位、中央値、第三四分位、最大値）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1.0  3.0  5.5  8.0 10.0\n```\n:::\n\n```{.r .cell-code}\nvapply(iris[, 1:4], fivenum, c(Min. = 0, \"1st Qu\" = 0, Median = 0, \"3rd Qu\" = 0, Max. = 0)) # 集約値をそれぞれ表示\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Sepal.Length Sepal.Width Petal.Length Petal.Width\nMin.            4.3         2.0         1.00         0.1\n1st Qu          5.1         2.8         1.60         0.3\nMedian          5.8         3.0         4.35         1.3\n3rd Qu          6.4         3.3         5.10         1.8\nMax.            7.9         4.4         6.90         2.5\n```\n:::\n:::\n\n\n### replicate関数\n\n**replicate関数**は、第一引数に繰り返し計算の回数、第二引数に関数を取ります。replicate関数は関数の計算を繰り返し計算の回数だけ繰り返し、結果をベクターで返します。引数内の関数の引数を変えることはできないので、一見あまり意味がなさそうに見えます。しかし、Rでは乱数（ランダムな数値）を用いた計算を行うことが多く、乱数計算を繰り返すと同じ関数の返り値でも変化することがあります。したがって、replicate関数は乱数を使った計算で利用すると生きる関数となっています。\n\n![図5：replicate関数の使い方](./image/chapter15_replicate.png)\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:6, 10, replace=T) # サイコロを10回ふる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 6 1 4 1 2 5 3 6 2 3\n```\n:::\n\n```{.r .cell-code}\nsum(sample(1:6, 10, replace=T)) # サイコロを10回ふり，合計値を求める\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 36\n```\n:::\n\n```{.r .cell-code}\nreplicate(20, sum(sample(1:6, 10, replace=T))) # 上の試行を20回繰り返す\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 34 36 31 44 36 41 34 30 35 36 41 33 28 26 30 34 37 34 32 49\n```\n:::\n:::\n\n\n### tapply関数\n\n**tapply関数**はベクターと因子を引数に取り、因子のグループごとに関数をベクターに適用します。ベクターに測定値、因子にカテゴリ（たとえば男性・女性など）を取っておけば、カテゴリごとの集計値を計算するのに使えます。\n\n![図6：tsapply関数の使い方](./image/chapter15_tapply.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- 1:10\ncutv <- factor(c(1, 1, 1, 1, 2, 2, 2, 3, 3, 4))\ntapply(v, cutv, sum) # ベクターを因子で切り分け、関数を適用する\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 1  2  3  4 \n10 18 17 10 \n```\n:::\n:::\n\n\n### sweep関数\n\nsweep関数は、apply関数に似ていますが、第三引数が関数ではなく、ベクターであるところが異なります。MARGINは1が行方向、2が列方向であるのはapply関数と同じですが、第三引数が引き算に使われるのが特徴です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:15, nrow=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n```\n:::\n\n```{.r .cell-code}\nsweep(matrix(1:15, nrow=3), 1, 1:3) # 行方向に1, 2, 3を引く\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    3    6    9   12\n[2,]    0    3    6    9   12\n[3,]    0    3    6    9   12\n```\n:::\n\n```{.r .cell-code}\nsweep(matrix(1:15, nrow=3), 2, 1:5) # 列方向に1, 2, 3, 4, 5を引く\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    2    4    6    8\n[2,]    1    3    5    7    9\n[3,]    2    4    6    8   10\n```\n:::\n:::\n\n\n### aggregate関数\n\n<font color=\"red\">**aggregate関数**</font>は、dplyrが出てくるまではデータフレームの結果を集計するのによく用いられてきた関数です。aggregate関数の第一引数は関数、第二引数にはby（因子のリスト）、第三引数に関数を取ります。aggregate関数はbyに指定した因子に従い、各列に関数を適用します。因子にカテゴリ（下の例ではirisの種、Species）を指定することで、因子ごとにデータを集計するのに用いることができます。\n\naggregate関数は引数にデータフレームだけでなく、<font color=\"red\">**formula（式）**</font>というものを取ることもできます。このformulaはRでは統計でよく用いられる表現で、~（チルダ）を演算子として用いるものです。**~の左側には従属変数、右側には独立変数を足し算・掛け算で記入する**形をとるのが最も一般的です。aggregate関数では、左側に関数を適用する列名、右側にbyにあたる因子を指定します。また、formulaでは、~の左側または右側に.（ピリオド）を置くことがあります。このピリオドは、「従属変数または独立変数に使用しなかったすべての列」を表す表現です。このformulaについては、統計の章で詳しく説明します。\n\n**by関数**もaggregate関数と類似した関数ですが、byは関数の引数に各列のベクターではなく、因子で区切ったデータフレームを指定します。ですので、データフレームを処理できない関数を用いると、計算ができない場合があります。\n\n![図7：aggregate関数の使い方](./image/chapter15_aggregate.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggregate(iris[,1:4], by=list(iris$Species), FUN = \"mean\") # byはリスト\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n```\n:::\n\n```{.r .cell-code}\naggregate(iris[,1:4], by=list(iris$Species), FUN = \"min\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa          4.3         2.3          1.0         0.1\n2 versicolor          4.9         2.0          3.0         1.0\n3  virginica          4.9         2.2          4.5         1.4\n```\n:::\n\n```{.r .cell-code}\nhead(Species)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'Species' not found\n```\n:::\n\n```{.r .cell-code}\naggregate(.~Species, data = iris, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa          5.8         4.4          1.9         0.6\n2 versicolor          7.0         3.4          5.1         1.8\n3  virginica          7.9         3.8          6.9         2.5\n```\n:::\n\n```{.r .cell-code}\nhead(ToothGrowth)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   len supp dose\n1  4.2   VC  0.5\n2 11.5   VC  0.5\n3  7.3   VC  0.5\n4  5.8   VC  0.5\n5  6.4   VC  0.5\n6 10.0   VC  0.5\n```\n:::\n\n```{.r .cell-code}\naggregate(len~., data = ToothGrowth, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  supp dose   len\n1   OJ  0.5 13.23\n2   VC  0.5  7.98\n3   OJ  1.0 22.70\n4   VC  1.0 16.77\n5   OJ  2.0 26.06\n6   VC  2.0 26.14\n```\n:::\n\n```{.r .cell-code}\nby(iris[, 1], list(iris$Species), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n: setosa\n[1] 5.006\n------------------------------------------------------------ \n: versicolor\n[1] 5.936\n------------------------------------------------------------ \n: virginica\n[1] 6.588\n```\n:::\n\n```{.r .cell-code}\nby(iris[, 1:2], list(iris$Species), mean) # meanは2列のデータを処理できない\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(data[x, , drop = FALSE], ...): argument is not numeric\nor logical: returning NA\n\nWarning in mean.default(data[x, , drop = FALSE], ...): argument is not numeric\nor logical: returning NA\n\nWarning in mean.default(data[x, , drop = FALSE], ...): argument is not numeric\nor logical: returning NA\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n: setosa\n[1] NA\n------------------------------------------------------------ \n: versicolor\n[1] NA\n------------------------------------------------------------ \n: virginica\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nby(iris[, 1:4], list(iris$Species), summary) # summaryはデータフレームを引数にできるので、計算できる\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n: setosa\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  \n 1st Qu.:4.800   1st Qu.:3.200   1st Qu.:1.400   1st Qu.:0.200  \n Median :5.000   Median :3.400   Median :1.500   Median :0.200  \n Mean   :5.006   Mean   :3.428   Mean   :1.462   Mean   :0.246  \n 3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  \n Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  \n------------------------------------------------------------ \n: versicolor\n  Sepal.Length    Sepal.Width     Petal.Length   Petal.Width   \n Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000  \n 1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200  \n Median :5.900   Median :2.800   Median :4.35   Median :1.300  \n Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326  \n 3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500  \n Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800  \n------------------------------------------------------------ \n: virginica\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  \n 1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  \n Median :6.500   Median :3.000   Median :5.550   Median :2.000  \n Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  \n 3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  \n Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  \n```\n:::\n:::\n",
    "supporting": [
      "chapter15_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}