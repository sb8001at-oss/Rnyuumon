{
  "hash": "db63284f2df839f802d773dbdbf316d3",
  "result": {
    "engine": "knitr",
    "markdown": "# グラフ作成：高レベルグラフィック関数\n\n\n\n\n\nRでは、ライブラリを用いることなく、論文に使用できるレベルのグラフを作成することができます。Rでのグラフ作成に用いる関数には、\n\n- 高レベルグラフィック関数（High-level plotting functions）\n- 低レベルグラフィック関数（Low-level plotting functions）\n- インタラクティブグラフィック関数（Interactive plotting functions）\n\nの3種類があります。\n\n**高レベルグラフィック関数**は、一つの関数でグラフ全体を作成するもの、**低レベルグラフィック関数**はグラフ上に点や線、軸、ラベルなどを置く関数、インタラクティブグラフィック関数はグラフをマウスでクリックすることでその点の値を取得したりするものです。\n\nRでは通常、高レベルグラフィック関数で作成したグラフを重ねて表現し、低レベルグラフィック関数で修正・追記してグラフを完成させます。また、グラフ上の点を選択して統計モデルを実行するようなプログラムを組む場合には、インタラクティブグラフィック関数を用います。\n\n:::{.callout-tip collapse=\"true\"}\n\n## グラフ作成に関するライブラリ\n\nRでは、ライブラリを読み込むことなくグラフを作成することができますが、現在では、[`ggplot2`](https://ggplot2.tidyverse.org/index.html)をグラフ作成に用いるのが事実上のデフォルトのようになっています。`ggplot2`については[後の章](./chapter22.html)で詳しく説明します。\n\n`ggplot2`には、`ggplot2`に機能を追加するような[Extensions](https://exts.ggplot2.tidyverse.org/gallery/)もたくさん作成されています。\n\n`ggplot2`の他にも、この章で紹介する3Dグラフ作成ライブラリである[`rgl`パッケージ](https://dmurdoch.github.io/rgl/) [@rgl_bib]、インタラクティブなグラフを作成することができる[`plotly`](https://plotly.com/r/) [@plotly_bib]、`ggplot2`にお株を奪われたような形ではありますが、複数のグラフを簡単に並べて書くことができる[`lattice`](https://lattice.r-forge.r-project.org/) [@lattice_bib]、`plotly`のようにインタラクティブなグラフ作成できる[`dygraphs`](https://rstudio.github.io/dygraphs/) [@dygraphs_bib]などがあります。\n\n:::\n\n## 高レベルグラフィック関数\n\nRの高レベルグラフィック関数の一覧を以下の表1に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表1：高レベルグラフィック関数の一覧\n\n|関数                   |グラフの種類                         |\n|:----------------------|:------------------------------------|\n|plot(x, y)             |xとyの散布図                         |\n|plot(tz)               |時系列tzの時系列グラフ               |\n|plot(factor)           |因子ごとの要素の数の棒グラフ         |\n|plot(function)         |関数に対応した線グラフ               |\n|plot(data.frame)       |相関行列の散布図（各列を要素とする） |\n|coplot(x ~ y &#124; z) |xとyの散布図を因子zで分けて表示      |\n|hist(x, breaks)        |ヒストグラム                         |\n|pairs(x, y, z)         |相関行列の散布図                     |\n|boxplot(x ~ y)         |箱ひげ図（yは因子）                  |\n|dotchart(d)            |行列dの散布図                        |\n|image(x, y, z)         |カラーチャート（ヒートマップ）       |\n|persp(x, y, z)         |3Dグラフ                             |\n|plot3d(d)              |3Dグラフ（rglパッケージを使用）      |\n|contour(x, y, z)       |等高線図                             |\n\n\n:::\n:::\n\n\n## plot関数\n\n`plot`関数は、Rでは最も基本的で、かつ利用範囲の広いグラフ作成関数です。`plot`関数は典型的なジェネリック関数で、グラフを引数に適した形で表示してくれます。ライブラリを呼び出していない場合、`plot`関数で呼び出されている関数は以下の30種類です。\n\n\n::: {.cell filename='ジェネリック関数としてのplot関数'}\n\n```{.r .cell-code}\nmethods(\"plot\")\n##  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*\n##  [4] plot.default        plot.dendrogram*    plot.density*      \n##  [7] plot.ecdf           plot.factor*        plot.formula*      \n## [10] plot.function       plot.hclust*        plot.histogram*    \n## [13] plot.HoltWinters*   plot.isoreg*        plot.lm*           \n## [16] plot.medpolish*     plot.mlm*           plot.ppr*          \n## [19] plot.prcomp*        plot.princomp*      plot.profile*      \n## [22] plot.profile.nls*   plot.raster*        plot.spec*         \n## [25] plot.stepfun        plot.stl*           plot.table*        \n## [28] plot.ts             plot.tskernel*      plot.TukeyHSD*     \n## see '?methods' for accessing help and source code\n```\n:::\n\n\nライブラリには、そのライブラリで使用するオブジェクトを引数とするのに適した形の`plot`関数が設定されていることも多く、ライブラリを使用した場合にはこの30種類よりも多くのグラフを`plot`関数だけで描画することができます。\n\n### 散布図\n\n`plot`関数の引数に、`x`と`y`の2つの同じ長さのベクターを数値で取った場合、`plot`関数は散布図を描画します。`x`に取った引数が横軸、`y`に取った引数が縦軸となります。\n\n\n::: {.cell filename='plot関数：散布図'}\n\n```{.r .cell-code}\nx <- 1:10\ny <- 2 * x\nplot(x = x, y = y)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n`x`と`y`の関係は、チルダ（`~`）を用いてformulaの形式で書くこともできます。中学校で習った関数のグラフと同様に、チルダの前が縦軸、チルダの後ろが横軸になります。\n\n\n::: {.cell filename='plot関数：formulaで指定'}\n\n```{.r .cell-code}\nplot(y ~ x)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n`plot`関数は引数が一つだけでも、グラフを作図してくれます。引数が一つだけの場合、`plot`関数は値を縦軸に、インデックスを横軸に取ったグラフを作成します。`stripchart`関数を用いても、同じグラフを作成することができます。\n\n\n::: {.cell filename='plot関数：引数が1つの場合'}\n\n```{.r .cell-code}\nz <- sample(1:10, 10) # 1~10をランダムに並べ替える\nz\n##  [1]  3  2  7  8  5  4 10  1  9  6\n\nplot(z) # 縦軸に値を取るグラフを表示\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n`plot`関数はデータフレーム（もしくは行列）を引数に取ることもできます。2列のデータフレームを引数に取った場合には、1列目をx軸、2列目をy軸とした散布図を描画します。\n\n\n::: {.cell filename='plot関数：データフレームを引数に取る'}\n\n```{.r .cell-code}\ncars |> head() # 車の速度が1列目、停車までの距離が2列目\n##   speed dist\n## 1     4    2\n## 2     4   10\n## 3     7    4\n## 4     7   22\n## 5     8   16\n## 6     9   10\n\nplot(cars) # x軸に速度、y軸に停車までの距離をプロット\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### 散布行列図\n\n2列以上のデータフレーム（もしくは行列）を引数に取った場合には、`plot`関数は**散布行列図（matrix of scatterplots）**を表示します。因子は数値に自動的に変換されます。\n\n\n::: {.cell filename='plot関数：散布図行列'}\n\n```{.r .cell-code}\nplot(iris)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n散布行列図には専用の関数である、`pairs`関数もありますが、`plot`関数で記述するものと差はありません。\n\n\n::: {.cell filename='pairs関数で散布図行列'}\n\n```{.r .cell-code}\npairs(iris)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n### 時系列プロット\n\n時系列（ts）クラスのオブジェクトを引数にした場合、`plot`関数は横軸に時間、縦軸に値を取った線グラフを表示します。\n\n\n::: {.cell filename='plot関数：時系列（ts）を引数に取る'}\n\n```{.r .cell-code}\nplot(Nile)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n`ts`クラスに季節性（四半期や12か月）がある場合、単に`plot`関数の引数に取ると、上記の通り、単に線グラフが返ってきます。\n\n\n::: {.cell filename='季節性のあるデータの描画'}\n\n```{.r .cell-code}\nplot(JohnsonJohnson) # JohnsonJohnsonの4半期ごとの株価\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n季節性のある時系列データを`decompose`関数の引数に指定すると、時系列データをトレンド、季節性、ランダムな要素に分離してくれます。この`decompose`関数の返り値を`plot`関数の引数に取ると、観察データ、トレンド、季節性、ランダムな要素をそれぞれ線グラフとして表示してくれます。\n\n\n::: {.cell filename='decompose関数と時系列の要素分離'}\n\n```{.r .cell-code}\nJohnsonJohnson |> decompose() |> plot() # decomposeは時系列のトレンド・季節性・ランダム要素を分ける関数\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### 箱ひげ図\n\n`plot`関数の`x`に因子、`y`に数値を取った場合、`plot`関数は**箱ひげ図**を表示します。\n\n\n::: {.cell filename='plot関数：箱ひげ図'}\n\n```{.r .cell-code}\n# x軸が因子、y軸は数値\nplot(x = iris$Species, y = iris$Sepal.Length)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n箱ひげ図の記述する専用の関数として、Rには`boxplot`関数が設定されています。`boxplot`関数を用いた場合、数値ベクターを引数に取り、その数値ベクターに対応した箱ひげ図を記述することができます。`plot`関数と同様に因子で分割した箱ひげ図を記載することもできますが、分割する場合、`boxplot`関数では引数をformulaで設定する必要があります。\n\n\n::: {.cell filename='boxplot関数で箱ひげ図を描画'}\n\n```{.r .cell-code}\nboxplot(iris$Sepal.Length) # 数値ベクターを引数に取ることもできる\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n```{.r .cell-code}\nboxplot(iris$Sepal.Length ~ iris$Species) # plot関数とは異なり、formulaを引数に取る\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n:::\n\n\n### 因子と棒グラフ\n\n`plot`関数では因子ベクターを一つだけ引数に取ることもできます。因子を引数に取った場合には、各レベルの要素の数（度数）を棒グラフで表示します。\n\n\n::: {.cell filename='plot関数：度数を棒グラフで描画'}\n\n```{.r .cell-code}\nfct <- sample(c(\"dog\", \"cat\", \"pig\"), 50, replace = T) |> factor()\nfct |> summary()\n## cat dog pig \n##  14  16  20\n\nplot(fct)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n`plot`関数の引数に2つの因子を取ると、**モザイク図（mosaic plot）**が表示されます。棒グラフの横幅、縦軸ともに各レベルの要素の数を反映しています。\n\n\n::: {.cell filename='plot関数：モザイク図'}\n\n```{.r .cell-code}\n# シロイヌナズナの場所ごとの集団と発芽の方法の関係\nplot(lme4::Arabidopsis$popu, lme4::Arabidopsis$status)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### 確率密度\n\nRでは、データの分布をカーネル密度に変換し、プロットすることもできます。`density`関数は数値データをカーネル密度に変換する関数です。`density`関数の返り値を`plot`関数の引数に取ると、カーネル密度に変換した数値データの分布が線グラフで表示されます。\n\n\n::: {.cell filename='density関数と確率密度'}\n\n```{.r .cell-code}\niris$Sepal.Length |> density() |> plot()\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### 関数の作図\n\n`plot`関数を用いれば、定義した関数をそのままグラフにすることもできます。`function`で関数を作成し、この関数を`plot`関数の引数に取ると、`plot`関数は作成した関数の引数をx軸に、関数の返り値をy軸に取った線グラフを作成します。\n\n\n::: {.cell filename='plot関数：関数の描画'}\n\n```{.r .cell-code}\nfun1 <- function(x){sin(x)}\nplot(fun1, xlim = c(-pi, pi)) # xlimはx軸の範囲を指定する引数\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(\\(x){cos(x)}, xlim = c(-pi, pi)) # \\で作成した無名関数も使える\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n\n同様の関数の作図は、`curve`関数を用いても記述することができます。\n\n\n::: {.cell filename='curve関数で関数を描画'}\n\n```{.r .cell-code}\ncurve(sin, -pi, pi) # sin関数を-piからpiまで記述\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n### ステップ関数（step functions）\n\n`stepfun`関数は2つの数値ベクターからステップ関数という、階段状になった値の列を返す関数です。引数`x`がx軸上の位置、引数`y`はy軸上の値を示します。この`stepfun`関数の返り値を`plot`関数の引数に取ると、ステップ関数が表示されます。\n\n\n::: {.cell filename='stepfunでステップ関数を描画する'}\n\n```{.r .cell-code}\nx <- 1:10\ny <- sample(c(1:3), 11, replace = T)\nstepfun(x, y) # stepfunクラスのオブジェクトを作成\n## Step function\n## Call: stepfun(x, y)\n##  x[1:10] =      1,      2,      3,  ...,      9,     10\n## 11 plateau levels =      1,      3,      1,  ...,      2,      3\n\nstepfun(x, y) |> plot()\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n### plot関数の引数一覧\n\n`plot`関数では、x軸・y軸を示す引数以外にも、軸ラベルやグラフの主題、散布図の点の形やグラフの表記のタイプなど、様々なグラフの要素を調整するための引数を指定することができます。引数の一覧を以下の表2に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表2：plot.default関数の引数一覧\n\n|引数        |引数のデータ型 |引数の意味                 |指定の例                     |\n|:-----------|:--------------|:--------------------------|:----------------------------|\n|type        |文字列         |プロットの形式             |type =\"l\" や type=\"p\"など    |\n|col         |文字列         |プロットの色               |col=\"red\"やcol=\"#111111\"など |\n|bg          |文字列         |背景色                     |bg=\"red\"                     |\n|pch         |数値           |プロットの形               |pch=2                        |\n|cex         |数値           |プロットの大きさ           |cex=2                        |\n|lty         |数値           |線の種類（実線、点線など） |lty = 1                      |\n|lwd         |数値           |線の太さ                   |lwd=2                        |\n|xlim        |数値ベクター   |x軸の範囲指定              |xlim=c(0, 10)                |\n|ylim        |数値ベクター   |y軸の範囲指定              |ylim=c(0, 10)                |\n|log         |文字列         |軸の対数変換               |\"x\", \"y\", \"xy\"               |\n|main        |文字列         |グラフの主題               |main=\"irisのグラフ\"          |\n|sub         |文字列         |グラフの副題               |sub=\"Petal.Lengthのグラフ\"   |\n|xlab        |文字列         |x軸の軸ラベル              |xlab=\"Petal.Length\"          |\n|ylab        |文字列         |y軸の軸ラベル              |ylab=\"Petal.Width\"           |\n|ann         |論理型         |ラベルを表記するか         |ann = FALSE                  |\n|axes        |論理型         |軸を表記するか             |axis = FALSE                 |\n|frame.plot  |論理型         |グラフの枠を表記するか     |frame.plot = FALSE           |\n|panel.first |expression     |グリッド表示を下から重ねる |panel.first=grid()           |\n|panel.last  |expression     |グリッド表示を上から重ねる |panel.last=grid()            |\n|asp         |数値           |xとyのアスペクト比         |asp=5                        |\n|xgap.axis   |数値           |x軸ラベルの記載間隔        |xgap.axis=10                 |\n|ygap.axis   |数値           |y軸ラベルの記載間隔        |ygap.axis=10                 |\n\n\n:::\n:::\n\n\n`plot`関数の`type`引数には、以下の文字列を設定できます。設定する文字列の一覧を以下の表3に示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表3：type引数の一覧\n\n|type引数の指定 |意味                       |\n|:--------------|:--------------------------|\n|\"p\"            |点（points）               |\n|\"l\"            |線（lines）                |\n|\"b\"            |点と線                     |\n|\"c\"            |線（点の部分は空白になる） |\n|\"o\"            |点と線（点に線が重なる）   |\n|\"s\"            |ステップ関数               |\n|\"h\"            |ヒストグラム風の棒グラフ   |\n|\"n\"            |何も表示しない             |\n\n\n:::\n:::\n\n\n`plot`関数の`pch`引数には、数値（または文字列）を設定します。数値によって、プロットされる点の形が変化します。指定できる点の形は以下の通りです。\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## hist関数：ヒストグラム\n\nデータの分布を棒グラフで示す**ヒストグラム**を表示する場合には、`hist`関数を用います。`hist`関数は数値のベクターを引数に取り、数値ごとの度数を棒グラフにした形で表示します。このとき、度数は数値の等間隔の範囲ごとに数えます。この等間隔の範囲（棒）の数のことを、binsやbreaksと呼びます。`hist`関数では、`breaks`引数でこのbreaks、棒グラフの棒の数を指定します。また、`freq`引数を`FALSE`に指定すると、縦軸を確率密度で表示することができます。\n\n\n::: {.cell filename='hist関数でヒストグラムを描画'}\n\n```{.r .cell-code}\nhist(iris$Sepal.Length) # デフォルトではちょうどよい感じで分割してくれる\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(iris$Sepal.Length, freq = FALSE, breaks = 15) # 縦軸は確率密度、15分割したヒストグラム\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-23-2.png){width=672}\n:::\n:::\n\n\n`breaks`は数値ベクターで指定することもできます。数値で指定した場合には、数値の間隔が棒グラフの幅となり、数値ベクターの長さ-1が棒の数となります。\n\n\n::: {.cell filename='breaks関数でヒストグラムの幅指定'}\n\n```{.r .cell-code}\nhist(iris$Sepal.Length, breaks = c(4, 5, 6, 8))\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n## coplot関数\n\n`coplot`関数は、2数の関係を示すグラフを、因子で分割して表示するための関数です。`coplot`関数ではformulaでx軸、y軸の数値を指定します（「`y軸の値 ~ x軸の値`」の形で指定）。グラフを分割するための因子は、formulaの後に、`|`を挟んで指定します。\n\n\n::: {.cell filename='coplot関数で因子ごとに分けたグラフを作成'}\n\n```{.r .cell-code}\ncoplot(iris$Sepal.Length ~ iris$Sepal.Width | iris$Species)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n## qqプロット\n\n数値が正規分布しているのか確認するために、正規分布に従った分位点とデータの分位点の関係をプロットするグラフを、**qqプロット**と呼びます。qqプロットでは、データが正規分布する場合、点が概ね直線上に乗ります。\n\nRでqqプロットを表示するための関数が、`qqnorm`関数です。`qqnorm`関数は数値ベクターを引数に取り、縦軸にデータの分位点、横軸に正規分布を仮定したときの分位点を示します。\n\n\n::: {.cell filename='qqnorm関数でqqプロットを作成'}\n\n```{.r .cell-code}\nqqnorm(iris$Sepal.Length) # 概ね正規分布するときは、直線に乗る\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\nqqnorm(runif(1000, 0, 1)) # 一様分布すると、直線に乗らない\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n:::\n\n\n正規分布ではなく、自分で指定した分布との比較を行いたい場合や、2つの数値の間での分布が一致するかどうか確かめるために用いるのが、`qqplot`関数です。`qqplot`関数は引数として数値ベクターを2つ取ります。`qqplot`関数では、2つの数値ベクターの長さが同じである必要はありません。\n\n\n::: {.cell filename='qqplot関数でデータの分布を評価する'}\n\n```{.r .cell-code}\nqqplot(iris$Sepal.Length, iris$Sepal.Width) # どちらも同じ分布に近いため、直線上に乗る\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n```{.r .cell-code}\nqqplot(iris$Sepal.Length, rchisq(1000, 5)) # Sepal.Lengthはカイ二乗分布とは分布が異なるため、直線に乗らない\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-27-2.png){width=672}\n:::\n:::\n\n\n## dotchart関数：ドットプロット\n\n`dotchart`関数は、クリーブランドドットプロットと呼ばれるグラフを作成するための関数です。このグラフは、カテゴリごとの値を点で示したもので、カテゴリや因子間で値を比較するときに用いられるものです。\n\n\n::: {.cell filename='dotchart関数でクリーブランドドットプロットを作成'}\n\n```{.r .cell-code}\ndotchart(WorldPhones[, 1:4])\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n## barplot関数：棒グラフ\n\n`barplot`関数は棒グラフを表示するための関数です。`barplot`関数は数値ベクターを引数に取り、ベクターのそれぞれの値を棒グラフで表示します。引数を行列で与えると、積み上げ式棒グラフを作図することもできます。\n\n\n::: {.cell filename='barplot関数で棒グラフを描画'}\n\n```{.r .cell-code}\nv <- c(first = 1, second = 2, third = 3)\nbarplot(v)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n\n```{.r .cell-code}\nv2 <- c(first = 2, second = 4, third = 6)\ncbind(v, v2) # 行列\n##        v v2\n## first  1  2\n## second 2  4\n## third  3  6\n\nbarplot(cbind(v, v2)) # 積み上げ式棒グラフ\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-29-2.png){width=672}\n:::\n:::\n\n\n## pie関数：円グラフ\n\n`pie`関数は円グラフを表示するための関数です。`pie`関数も`barplot`関数と同じく、数値のベクターを引数に取り、数値を反映した円グラフを表示します。ただし、この[`pie`関数のヘルプ](https://search.r-project.org/R/refmans/graphics/html/pie.html)にも記載されている通り（「*Pie charts are a very bad way of displaying information.*」）、円グラフは理解しにくく、良いグラフであるとは考えられていません。円グラフで表示せずにドットプロット、棒グラフを用いて示した方がよいでしょう。\n\n\n::: {.cell filename='pie関数で円グラフを描画'}\n\n```{.r .cell-code}\n(v <- sample(1:10, 5))\n## [1]  6 10  7  2  4\npar(mar = c(0.5, 0.5, 0.5, 0.5))\npie(v)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n## image関数：ヒートマップ\n\n`image`関数は行列を引数に取り、行列の位置（行・列）とその値の関係を色で示したグラフを表示する関数です。このようなグラフは**ヒートマップ**と呼ばれます。\n\n\n::: {.cell filename='image関数でヒートマップ作成'}\n\n```{.r .cell-code}\nimage(volcano) # 火山の緯度・軽度と標高の関係\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n\n```{.r .cell-code}\niris[,1:4] |> as.matrix() |> image() # 行列であればヒートマップにできる\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-31-2.png){width=672}\n:::\n:::\n\n\n## persp関数：3次元グラフ\n\n`persp`関数は3次元グラフを作成するための関数です。`x`軸、`y`軸、`z`軸の値をそれぞれ数値ベクターとして引数に指定し、`theta`と`phi`の2つの引数で、3次元グラフを観察する視点を指定します。ただし、この`persp`関数では3次元グラフの視点を動かすのが難しいため、Rではかなり前から**[`rgl`パッケージ](https://dmurdoch.github.io/rgl/)** [@rgl_bib]を用いて3次元グラフを描画するのが一般的です。\n\n\n::: {.cell filename='persp関数で3次元グラフ'}\n\n```{.r .cell-code}\npar(mar = c(0.5, 0.5, 0.5, 0.5))\npersp(x = 1:nrow(volcano), y = 1:ncol(volcano), z = volcano, theta = 45, phi = 30, expand = 0.5)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n## rglパッケージ：3次元グラフ\n\n`rgl`パッケージは、[OpenGL](https://www.opengl.org/) [@woo1999opengl]という、C言語の3Dグラフィックスライブラリを使用したRのグラフ作成ライブラリです。`rgl`パッケージの関数群を用いることで、R上でマウスを使って視点をグリグリ動かすことができる3次元グラフを作成することができます。\n\n\n::: {.cell filename='rglパッケージで3次元グラフ'}\n\n```{.r .cell-code}\npacman::p_load(rgl)\np_iris3d <- plot3d(iris$Sepal.Length, iris$Sepal.Width, iris$Petal.Length, col = as.numeric(iris$Species))\n\nrglwidget(elementId = \"plot3drgl\")\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"plot3drgl\" style=\"width:100%;height:464px;\" class=\"rglWebGL html-widget\" role=\"img\" aria-labelledby=\"plot3drgl-aria\"></div>\n<script type=\"application/json\" data-for=\"plot3drgl\">{\"x\":{\"material\":{\"color\":\"#000000\",\"alpha\":1,\"lit\":true,\"ambient\":\"#000000\",\"specular\":\"#FFFFFF\",\"emission\":\"#000000\",\"shininess\":50,\"smooth\":true,\"front\":\"filled\",\"back\":\"filled\",\"size\":3,\"lwd\":1,\"fog\":true,\"point_antialias\":false,\"line_antialias\":false,\"texture\":null,\"textype\":\"rgb\",\"texmode\":\"modulate\",\"texmipmap\":false,\"texminfilter\":\"linear\",\"texmagfilter\":\"linear\",\"texenvmap\":false,\"depth_mask\":true,\"depth_test\":\"less\",\"isTransparent\":false,\"polygon_offset\":[0,0],\"margin\":\"\",\"floating\":false,\"tag\":\"\",\"blend\":[\"src_alpha\",\"one_minus_src_alpha\"]},\"rootSubscene\":7,\"objects\":{\"13\":{\"id\":13,\"type\":\"points\",\"material\":{\"lit\":false},\"vertices\":\"0\",\"colors\":\"1\",\"centers\":\"2\",\"ignoreExtent\":false,\"flags\":34816},\"15\":{\"id\":15,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":0,\"floating\":true,\"edge\":[0,1,1]},\"vertices\":\"3\",\"colors\":\"4\",\"texts\":[[\"iris$Sepal.Length\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"5\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"16\":{\"id\":16,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":1,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"6\",\"colors\":\"7\",\"texts\":[[\"iris$Sepal.Width\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"8\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"17\":{\"id\":17,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":2,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"9\",\"colors\":\"10\",\"texts\":[[\"iris$Petal.Length\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"11\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"11\":{\"id\":11,\"type\":\"light\",\"vertices\":[[0,0,1]],\"colors\":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],\"viewpoint\":true,\"finite\":false},\"10\":{\"id\":10,\"type\":\"background\",\"material\":{},\"colors\":\"12\",\"centers\":\"13\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"12\":{\"id\":12,\"type\":\"background\",\"material\":{\"lit\":false,\"back\":\"lines\"},\"colors\":\"14\",\"centers\":\"15\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"14\":{\"id\":14,\"type\":\"bboxdeco\",\"material\":{\"front\":\"lines\",\"back\":\"lines\"},\"vertices\":\"16\",\"colors\":\"17\",\"axes\":{\"mode\":[\"pretty\",\"pretty\",\"pretty\"],\"step\":[1,0.5,1],\"nticks\":[5,5,5],\"marklen\":[15,15,15],\"expand\":[1.029999971389771,1.029999971389771,1.029999971389771]},\"draw_front\":true,\"flags\":32769},\"7\":{\"id\":7,\"type\":\"subscene\",\"par3d\":{\"antialias\":8,\"FOV\":30,\"ignoreExtent\":false,\"listeners\":7,\"mouseMode\":{\"none\":\"none\",\"left\":\"trackball\",\"right\":\"zoom\",\"middle\":\"fov\",\"wheel\":\"pull\"},\"observer\":[0,0,17.90336799621582],\"modelMatrix\":[[1.173371434211731,0,0,-7.157566070556641],[0,0.6019749641418457,0.6727780103683472,-4.583793163299561],[0,-1.653912544250488,0.2448711842298508,-13.57808876037598],[0,0,0,1]],\"projMatrix\":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863702774047852,-64.53955841064453],[0,0,-1,0]],\"skipRedraw\":false,\"userMatrix\":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],\"userProjection\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"scale\":[1.173371434211731,1.760056972503662,0.7159554362297058],\"viewport\":{\"x\":0,\"y\":0,\"width\":1,\"height\":1},\"zoom\":1,\"bbox\":[4.300000190734863,7.900000095367432,2,4.400000095367432,1,6.900000095367432],\"windowRect\":[164,187,420,443],\"family\":\"sans\",\"font\":1,\"cex\":1,\"useFreeType\":false,\"fontname\":\"TT Arial\",\"maxClipPlanes\":8,\"glVersion\":4.6,\"activeSubscene\":0},\"embeddings\":{\"viewport\":\"replace\",\"projection\":\"replace\",\"model\":\"replace\",\"mouse\":\"replace\"},\"objects\":[12,14,13,15,16,17,11],\"subscenes\":[],\"flags\":36113}},\"crosstalk\":{\"key\":[],\"group\":[],\"id\":[],\"options\":[]},\"width\":672,\"height\":480,\"buffer\":{\"accessors\":[{\"bufferView\":0,\"componentType\":5126,\"count\":150,\"type\":\"VEC3\"},{\"bufferView\":1,\"componentType\":5121,\"count\":150,\"type\":\"VEC4\",\"normalized\":true},{\"bufferView\":2,\"componentType\":5126,\"count\":150,\"type\":\"VEC3\"},{\"bufferView\":3,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":4,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":5,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":6,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":7,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":8,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":9,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":10,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":11,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":12,\"componentType\":5126,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":13,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":14,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":15,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":16,\"componentType\":5126,\"count\":14,\"type\":\"VEC3\"},{\"bufferView\":17,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"}],\"bufferViews\":[{\"buffer\":0,\"byteLength\":1800,\"byteOffset\":0},{\"buffer\":0,\"byteLength\":600,\"byteOffset\":1800},{\"buffer\":0,\"byteLength\":1800,\"byteOffset\":2400},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4200},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":4212},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4216},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4228},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":4240},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4244},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4256},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":4268},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":4272},{\"buffer\":0,\"byteLength\":16,\"byteOffset\":4284},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":4300},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":4303},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":4307},{\"buffer\":0,\"byteLength\":168,\"byteOffset\":4312},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":4480}],\"buffers\":[{\"byteLength\":4484,\"bytes\":\"MzOjQAAAYEAzM7M/zcycQAAAQEAzM7M/ZmaWQM3MTEBmZqY/MzOTQGZmRkAAAMA/AACgQGZm\\nZkAzM7M/zcysQJqZeUCamdk/MzOTQJqZWUAzM7M/AACgQJqZWUAAAMA/zcyMQJqZOUAzM7M/\\nzcycQGZmRkAAAMA/zcysQM3MbEAAAMA/mpmZQJqZWUDNzMw/mpmZQAAAQEAzM7M/mpmJQAAA\\nQEDNzIw/mpm5QAAAgECamZk/Zma2QM3MjEAAAMA/zcysQJqZeUBmZqY/MzOjQAAAYEAzM7M/\\nZma2QDMzc0Camdk/MzOjQDMzc0AAAMA/zcysQJqZWUCamdk/MzOjQM3MbEAAAMA/MzOTQGZm\\nZkAAAIA/MzOjQDMzU0Camdk/mpmZQJqZWUAzM/M/AACgQAAAQEDNzMw/AACgQJqZWUDNzMw/\\nZmamQAAAYEAAAMA/ZmamQJqZWUAzM7M/ZmaWQM3MTEDNzMw/mpmZQGZmRkDNzMw/zcysQJqZ\\nWUAAAMA/ZmamQDMzg0AAAMA/AACwQGZmhkAzM7M/zcycQGZmRkAAAMA/AACgQM3MTECamZk/\\nAACwQAAAYEBmZqY/zcycQGZmZkAzM7M/zcyMQAAAQEBmZqY/MzOjQJqZWUAAAMA/AACgQAAA\\nYEBmZqY/AACQQDMzE0BmZqY/zcyMQM3MTEBmZqY/AACgQAAAYEDNzMw/MzOjQDMzc0AzM/M/\\nmpmZQAAAQEAzM7M/MzOjQDMzc0DNzMw/MzOTQM3MTEAzM7M/mpmpQM3MbEAAAMA/AACgQDMz\\nU0AzM7M/AADgQM3MTEBmZpZAzczMQM3MTEAAAJBAzczcQGZmRkDNzJxAAACwQDMzE0AAAIBA\\nAADQQDMzM0AzM5NAZma2QDMzM0AAAJBAmpnJQDMzU0BmZpZAzcycQJqZGUAzM1NAMzPTQJqZ\\nOUAzM5NAZmamQM3MLECamXlAAACgQAAAAEAAAGBAzcy8QAAAQEBmZoZAAADAQM3MDEAAAIBA\\nMzPDQJqZOUBmZpZAMzOzQJqZOUBmZmZAZmbWQGZmRkDNzIxAMzOzQAAAQEAAAJBAmpm5QM3M\\nLEAzM4NAZmbGQM3MDEAAAJBAMzOzQAAAIECamXlAzcy8QM3MTECamZlAMzPDQDMzM0AAAIBA\\nmpnJQAAAIEDNzJxAMzPDQDMzM0BmZpZAzczMQJqZOUCamYlAMzPTQAAAQEDNzIxAmpnZQDMz\\nM0CamZlAZmbWQAAAQEAAAKBAAADAQJqZOUAAAJBAZma2QGZmJkAAAGBAAACwQJqZGUAzM3NA\\nAACwQJqZGUDNzGxAmpm5QM3MLECamXlAAADAQM3MLEAzM6NAzcysQAAAQEAAAJBAAADAQJqZ\\nWUAAAJBAZmbWQGZmRkBmZpZAmpnJQDMzE0DNzIxAMzOzQAAAQEAzM4NAAACwQAAAIEAAAIBA\\nAACwQGZmJkDNzIxAMzPDQAAAQEAzM5NAmpm5QGZmJkAAAIBAAACgQDMzE0AzM1NAMzOzQM3M\\nLEBmZoZAZma2QAAAQEBmZoZAZma2QJqZOUBmZoZAZmbGQJqZOUCamYlAMzOjQAAAIEAAAEBA\\nZma2QDMzM0AzM4NAmpnJQDMzU0AAAMBAmpm5QM3MLEAzM6NAMzPjQAAAQEDNzLxAmpnJQJqZ\\nOUAzM7NAAADQQAAAQECamblAMzPzQAAAQEAzM9NAzcycQAAAIEAAAJBAmpnpQJqZOUCamclA\\nZmbWQAAAIECamblAZmbmQGZmZkAzM8NAAADQQM3MTEAzM6NAzczMQM3MLECamalAmpnZQAAA\\nQEAAALBAZma2QAAAIEAAAKBAmpm5QDMzM0AzM6NAzczMQM3MTECamalAAADQQAAAQEAAALBA\\nZmb2QDMzc0BmZtZAZmb2QGZmJkDNzNxAAADAQM3MDEAAAKBAzczcQM3MTEBmZrZAMzOzQDMz\\nM0DNzJxAZmb2QDMzM0BmZtZAmpnJQM3MLEDNzJxAZmbWQDMzU0BmZrZAZmbmQM3MTEAAAMBA\\nZmbGQDMzM0CamZlAMzPDQAAAQEDNzJxAzczMQDMzM0AzM7NAZmbmQAAAQECamblAzczsQDMz\\nM0AzM8NAzcz8QDMzc0DNzMxAzczMQDMzM0AzM7NAmpnJQDMzM0AzM6NAMzPDQGZmJkAzM7NA\\nZmb2QAAAQEAzM8NAmpnJQJqZWUAzM7NAzczMQGZmRkAAALBAAADAQAAAQECamZlAzczcQGZm\\nRkDNzKxAZmbWQGZmRkAzM7NAzczcQGZmRkAzM6NAmpm5QM3MLEAzM6NAmpnZQM3MTEDNzLxA\\nZmbWQDMzU0BmZrZAZmbWQAAAQEBmZqZAmpnJQAAAIEAAAKBAAADQQAAAQEBmZqZAZmbGQJqZ\\nWUDNzKxAzcy8QAAAQEAzM6NAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/\\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\\nAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/\\nAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAA\\nAP/fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/\\n31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99T\\na//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/\\n31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/99Ta//fU2v/31Nr/2HQT/9h0E//YdBP/2HQ\\nT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//\\nYdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQ\\nT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//YdBP/2HQT/9h0E//\\nYdBP/2HQT/9h0E//YdBP/2HQT/9h0E//MzOjQAAAYEAzM7M/zcycQAAAQEAzM7M/ZmaWQM3M\\nTEBmZqY/MzOTQGZmRkAAAMA/AACgQGZmZkAzM7M/zcysQJqZeUCamdk/MzOTQJqZWUAzM7M/\\nAACgQJqZWUAAAMA/zcyMQJqZOUAzM7M/zcycQGZmRkAAAMA/zcysQM3MbEAAAMA/mpmZQJqZ\\nWUDNzMw/mpmZQAAAQEAzM7M/mpmJQAAAQEDNzIw/mpm5QAAAgECamZk/Zma2QM3MjEAAAMA/\\nzcysQJqZeUBmZqY/MzOjQAAAYEAzM7M/Zma2QDMzc0Camdk/MzOjQDMzc0AAAMA/zcysQJqZ\\nWUCamdk/MzOjQM3MbEAAAMA/MzOTQGZmZkAAAIA/MzOjQDMzU0Camdk/mpmZQJqZWUAzM/M/\\nAACgQAAAQEDNzMw/AACgQJqZWUDNzMw/ZmamQAAAYEAAAMA/ZmamQJqZWUAzM7M/ZmaWQM3M\\nTEDNzMw/mpmZQGZmRkDNzMw/zcysQJqZWUAAAMA/ZmamQDMzg0AAAMA/AACwQGZmhkAzM7M/\\nzcycQGZmRkAAAMA/AACgQM3MTECamZk/AACwQAAAYEBmZqY/zcycQGZmZkAzM7M/zcyMQAAA\\nQEBmZqY/MzOjQJqZWUAAAMA/AACgQAAAYEBmZqY/AACQQDMzE0BmZqY/zcyMQM3MTEBmZqY/\\nAACgQAAAYEDNzMw/MzOjQDMzc0AzM/M/mpmZQAAAQEAzM7M/MzOjQDMzc0DNzMw/MzOTQM3M\\nTEAzM7M/mpmpQM3MbEAAAMA/AACgQDMzU0AzM7M/AADgQM3MTEBmZpZAzczMQM3MTEAAAJBA\\nzczcQGZmRkDNzJxAAACwQDMzE0AAAIBAAADQQDMzM0AzM5NAZma2QDMzM0AAAJBAmpnJQDMz\\nU0BmZpZAzcycQJqZGUAzM1NAMzPTQJqZOUAzM5NAZmamQM3MLECamXlAAACgQAAAAEAAAGBA\\nzcy8QAAAQEBmZoZAAADAQM3MDEAAAIBAMzPDQJqZOUBmZpZAMzOzQJqZOUBmZmZAZmbWQGZm\\nRkDNzIxAMzOzQAAAQEAAAJBAmpm5QM3MLEAzM4NAZmbGQM3MDEAAAJBAMzOzQAAAIECamXlA\\nzcy8QM3MTECamZlAMzPDQDMzM0AAAIBAmpnJQAAAIEDNzJxAMzPDQDMzM0BmZpZAzczMQJqZ\\nOUCamYlAMzPTQAAAQEDNzIxAmpnZQDMzM0CamZlAZmbWQAAAQEAAAKBAAADAQJqZOUAAAJBA\\nZma2QGZmJkAAAGBAAACwQJqZGUAzM3NAAACwQJqZGUDNzGxAmpm5QM3MLECamXlAAADAQM3M\\nLEAzM6NAzcysQAAAQEAAAJBAAADAQJqZWUAAAJBAZmbWQGZmRkBmZpZAmpnJQDMzE0DNzIxA\\nMzOzQAAAQEAzM4NAAACwQAAAIEAAAIBAAACwQGZmJkDNzIxAMzPDQAAAQEAzM5NAmpm5QGZm\\nJkAAAIBAAACgQDMzE0AzM1NAMzOzQM3MLEBmZoZAZma2QAAAQEBmZoZAZma2QJqZOUBmZoZA\\nZmbGQJqZOUCamYlAMzOjQAAAIEAAAEBAZma2QDMzM0AzM4NAmpnJQDMzU0AAAMBAmpm5QM3M\\nLEAzM6NAMzPjQAAAQEDNzLxAmpnJQJqZOUAzM7NAAADQQAAAQECamblAMzPzQAAAQEAzM9NA\\nzcycQAAAIEAAAJBAmpnpQJqZOUCamclAZmbWQAAAIECamblAZmbmQGZmZkAzM8NAAADQQM3M\\nTEAzM6NAzczMQM3MLECamalAmpnZQAAAQEAAALBAZma2QAAAIEAAAKBAmpm5QDMzM0AzM6NA\\nzczMQM3MTECamalAAADQQAAAQEAAALBAZmb2QDMzc0BmZtZAZmb2QGZmJkDNzNxAAADAQM3M\\nDEAAAKBAzczcQM3MTEBmZrZAMzOzQDMzM0DNzJxAZmb2QDMzM0BmZtZAmpnJQM3MLEDNzJxA\\nZmbWQDMzU0BmZrZAZmbmQM3MTEAAAMBAZmbGQDMzM0CamZlAMzPDQAAAQEDNzJxAzczMQDMz\\nM0AzM7NAZmbmQAAAQECamblAzczsQDMzM0AzM8NAzcz8QDMzc0DNzMxAzczMQDMzM0AzM7NA\\nmpnJQDMzM0AzM6NAMzPDQGZmJkAzM7NAZmb2QAAAQEAzM8NAmpnJQJqZWUAzM7NAzczMQGZm\\nRkAAALBAAADAQAAAQECamZlAzczcQGZmRkDNzKxAZmbWQGZmRkAzM7NAzczcQGZmRkAzM6NA\\nmpm5QM3MLEAzM6NAmpnZQM3MTEDNzLxAZmbWQDMzU0BmZrZAZmbWQAAAQEBmZqZAmpnJQAAA\\nIEAAAKBAAADQQAAAQEBmZqZAZmbGQJqZWUDNzKxAzcy8QAAAQEAzM6NAAADAfwAAgEAAAIA/\\nAAAAAQAAwH8AAIBAAACAPwAAwH8AAIBAAACAPwAAAAEAAMB/AACAQAAAgD8AAMB/AACAQAAA\\ngD8AAAABAADAfwAAgEAAAIA/mZiYPpmYmD6ZmJg+AACAPwAAAAEBAQEAAAAAAAAAoEAAAMB/\\nAADAfwAAwEAAAMB/AADAfwAA4EAAAMB/AADAfwAAwH8AAABAAADAfwAAwH8AACBAAADAfwAA\\nwH8AAEBAAADAfwAAwH8AAGBAAADAfwAAwH8AAIBAAADAfwAAwH8AAMB/AACAPwAAwH8AAMB/\\nAAAAQAAAwH8AAMB/AABAQAAAwH8AAMB/AACAQAAAwH8AAMB/AACgQAAAwH8AAMB/AADAQAAA\\nAAE=\"}]},\"context\":{\"shiny\":false,\"rmarkdown\":null},\"vertexShader\":\"#line 2 1\\n// File 1 is the vertex shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\n\\nattribute vec3 aPos;\\nattribute vec4 aCol;\\nuniform mat4 mvMatrix;\\nuniform mat4 prMatrix;\\nvarying vec4 vCol;\\nvarying vec4 vPosition;\\n\\n#ifdef NEEDS_VNORMAL\\nattribute vec3 aNorm;\\nuniform mat4 normMatrix;\\nvarying vec4 vNormal;\\n#endif\\n\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nattribute vec2 aTexcoord;\\nvarying vec2 vTexcoord;\\n#endif\\n\\n#ifdef FIXED_SIZE\\nuniform vec3 textScale;\\n#endif\\n\\n#ifdef FIXED_QUADS\\nattribute vec3 aOfs;\\n#endif\\n\\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\nvarying float normz;\\nuniform mat4 invPrMatrix;\\n#else\\nattribute vec3 aPos1;\\nattribute vec3 aPos2;\\nvarying float normz;\\n#endif\\n#endif // IS_TWOSIDED\\n\\n#ifdef FAT_LINES\\nattribute vec3 aNext;\\nattribute vec2 aPoint;\\nvarying vec2 vPoint;\\nvarying float vLength;\\nuniform float uAspect;\\nuniform float uLwd;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  \\n#ifndef IS_BRUSH\\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\\n  vPosition = mvMatrix * vec4(aPos, 1.);\\n#endif\\n  \\n#ifndef FIXED_QUADS\\n  gl_Position = prMatrix * vPosition;\\n#endif\\n#endif // !IS_BRUSH\\n  \\n#ifdef IS_POINTS\\n  gl_PointSize = POINTSIZE;\\n#endif\\n  \\n  vCol = aCol;\\n  \\n// USE_ENVMAP implies NEEDS_VNORMAL\\n\\n#ifdef NEEDS_VNORMAL\\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\\n#endif\\n\\n#ifdef USE_ENVMAP\\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \\n                        normalize(vNormal.xyz/vNormal.w)));\\n#endif\\n  \\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\n  /* normz should be calculated *after* projection */\\n  normz = (invPrMatrix*vNormal).z;\\n#else\\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\\n#endif\\n#endif // IS_TWOSIDED\\n  \\n#ifdef NEEDS_VNORMAL\\n  vNormal = vec4(normalize(vNormal.xyz), 1);\\n#endif\\n  \\n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\\n  vTexcoord = aTexcoord;\\n#endif\\n  \\n#if defined(FIXED_SIZE) && !defined(ROTATING)\\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w;\\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\\n#endif\\n  \\n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w + vec4(aOfs,  0.);\\n  gl_Position = prMatrix*pos;\\n#endif\\n  \\n#ifdef FAT_LINES\\n  /* This code was inspired by Matt Deslauriers' code in \\n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\\n  vec2 aspectVec = vec2(uAspect, 1.0);\\n  mat4 projViewModel = prMatrix * mvMatrix;\\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\\n  currentProjected = currentProjected/currentProjected.w;\\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\\n  vec2 currentScreen = currentProjected.xy * aspectVec;\\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\\n  float len = uLwd;\\n  vec2 dir = vec2(1.0, 0.0);\\n  vPoint = aPoint;\\n  vLength = length(nextScreen - currentScreen)/2.0;\\n  vLength = vLength/(vLength + len);\\n  if (vLength > 0.0) {\\n    dir = normalize(nextScreen - currentScreen);\\n  }\\n  vec2 normal = vec2(-dir.y, dir.x);\\n  dir.x /= uAspect;\\n  normal.x /= uAspect;\\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\\n  gl_Position = currentProjected + offset;\\n#endif\\n  \\n#ifdef IS_BRUSH\\n  gl_Position = vec4(aPos, 1.);\\n#endif\\n}\",\"fragmentShader\":\"#line 2 2\\n// File 2 is the fragment shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\nvarying vec4 vCol; // carries alpha\\nvarying vec4 vPosition;\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nvarying vec2 vTexcoord;\\nuniform sampler2D uSampler;\\n#endif\\n\\n#ifdef HAS_FOG\\nuniform int uFogMode;\\nuniform vec3 uFogColor;\\nuniform vec4 uFogParms;\\n#endif\\n\\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\\nvarying vec4 vNormal;\\n#endif\\n\\n#if NCLIPPLANES > 0\\nuniform vec4 vClipplane[NCLIPPLANES];\\n#endif\\n\\n#if NLIGHTS > 0\\nuniform mat4 mvMatrix;\\n#endif\\n\\n#ifdef IS_LIT\\nuniform vec3 emission;\\nuniform float shininess;\\n#if NLIGHTS > 0\\nuniform vec3 ambient[NLIGHTS];\\nuniform vec3 specular[NLIGHTS]; // light*material\\nuniform vec3 diffuse[NLIGHTS];\\nuniform vec3 lightDir[NLIGHTS];\\nuniform bool viewpoint[NLIGHTS];\\nuniform bool finite[NLIGHTS];\\n#endif\\n#endif // IS_LIT\\n\\n#ifdef IS_TWOSIDED\\nuniform bool front;\\nvarying float normz;\\n#endif\\n\\n#ifdef FAT_LINES\\nvarying vec2 vPoint;\\nvarying float vLength;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  vec4 fragColor;\\n#ifdef FAT_LINES\\n  vec2 point = vPoint;\\n  bool neg = point.y < 0.0;\\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\\n                 -(point.y - vLength)/(1.0 - vLength);\\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\\n  if (neg && length(point) <= 1.0) discard;\\n#endif\\n  point.y = min(point.y, 0.0);\\n  if (length(point) > 1.0) discard;\\n#endif // FAT_LINES\\n  \\n#ifdef ROUND_POINTS\\n  vec2 coord = gl_PointCoord - vec2(0.5);\\n  if (length(coord) > 0.5) discard;\\n#endif\\n  \\n#if NCLIPPLANES > 0\\n  for (int i = 0; i < NCLIPPLANES; i++)\\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\\n#endif\\n    \\n#ifdef FIXED_QUADS\\n    vec3 n = vec3(0., 0., 1.);\\n#elif defined(IS_LIT)\\n    vec3 n = normalize(vNormal.xyz);\\n#endif\\n    \\n#ifdef IS_TWOSIDED\\n    if ((normz <= 0.) != front) discard;\\n#endif\\n\\n#ifdef IS_LIT\\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\\n    vec3 lightdir;\\n    vec4 colDiff;\\n    vec3 halfVec;\\n    vec4 lighteffect = vec4(emission, 0.);\\n    vec3 col;\\n    float nDotL;\\n#ifdef FIXED_QUADS\\n    n = -faceforward(n, n, eye);\\n#endif\\n    \\n#if NLIGHTS > 0\\n    // Simulate two-sided lighting\\n    if (n.z < 0.0)\\n      n = -n;\\n    for (int i=0;i<NLIGHTS;i++) {\\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\\n      lightdir = lightDir[i];\\n      if (!viewpoint[i]) {\\n        if (finite[i]) {\\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\\n        } else {\\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\\n        }\\n      }\\n      if (!finite[i]) {\\n        halfVec = normalize(lightdir + eye);\\n      } else {\\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\\n        halfVec = normalize(lightdir + eye);\\n      }\\n      col = ambient[i];\\n      nDotL = dot(n, lightdir);\\n      col = col + max(nDotL, 0.) * colDiff.rgb;\\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\\n      lighteffect = lighteffect + vec4(col, colDiff.a);\\n    }\\n#endif\\n    \\n#else // not IS_LIT\\n    vec4 colDiff = vCol;\\n    vec4 lighteffect = colDiff;\\n#endif\\n    \\n#ifdef IS_TEXT\\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\\n#endif\\n    \\n#ifdef HAS_TEXTURE\\n\\n// These calculations use the definitions from \\n// https://docs.gl/gl3/glTexEnv\\n\\n#ifdef USE_ENVMAP\\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\\n#else\\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\\n#endif\\n\\n#ifdef TEXTURE_rgb\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\\n#endif\\n\\n#endif //TEXTURE_rgb\\n        \\n#ifdef TEXTURE_rgba\\n\\n#ifdef TEXMODE_replace\\n// already done\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*textureColor;\\n#endif\\n\\n#ifdef TEXMODE_decal\\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\\n                     textureColor.a*textureColor.rgb, \\n                     lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n    \\n#endif //TEXTURE_rgba\\n    \\n#ifdef TEXTURE_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(lighteffect.rgb, luminance);\\n#endif \\n\\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\\n#endif\\n \\n#endif // TEXTURE_alpha\\n    \\n// The TEXTURE_luminance values are not from that reference    \\n#ifdef TEXTURE_luminance\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#endif // TEXTURE_luminance\\n \\n    \\n#ifdef TEXTURE_luminance_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n\\n#endif\\n\\n#endif // TEXTURE_luminance_alpha\\n    \\n    fragColor = textureColor;\\n\\n#elif defined(IS_TEXT)\\n    if (textureColor.a < 0.1)\\n      discard;\\n    else\\n      fragColor = textureColor;\\n#else\\n    fragColor = lighteffect;\\n#endif // HAS_TEXTURE\\n    \\n#ifdef HAS_FOG\\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\\n    // In Exp and Exp2: use density = density/far\\n    // fogF will be the proportion of fog\\n    // Initialize it to the linear value\\n    float fogF;\\n    if (uFogMode > 0) {\\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\\n      if (uFogMode > 1)\\n        fogF = mix(uFogParms.w, 1.0, fogF);\\n      fogF = fogF*uFogParms.z;\\n      if (uFogMode == 2)\\n        fogF = 1.0 - exp(-fogF);\\n      // Docs are wrong: use (density*c)^2, not density*c^2\\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\\n      else if (uFogMode == 3)\\n        fogF = 1.0 - exp(-fogF*fogF);\\n      fogF = clamp(fogF, 0.0, 1.0);\\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\\n    } else gl_FragColor = fragColor;\\n#else\\n    gl_FragColor = fragColor;\\n#endif // HAS_FOG\\n    \\n}\",\"players\":[],\"webGLoptions\":{\"preserveDrawingBuffer\":true}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## 3次元グラフについて\n\nRに限らず、3次元グラフを作成できると何か楽しいような気がします。しかし、データ解析においては3次元グラフではデータを理解しにくく、数値を直感的に比較することが困難です。「3次元グラフでなければ表現できない」などの非常に特別な場合を除けば、3次元グラフの利用は避けた方が良いでしょう。\n\n:::\n\n## contour関数：等高線グラフ\n\n`contour`関数は`image`関数と同様に行列を引数に取り、x軸に列、y軸に行、高さとして行列の値を用いた等高線グラフを作成するための関数です。\n\n\n::: {.cell filename='contour関数で等高線グラフを描画'}\n\n```{.r .cell-code}\ncontour(volcano)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n`filled.contour`関数を用いると、等高線に加えて、`image`関数と同様の色での表現を加えることができます。\n\n\n::: {.cell filename='filled.contour関数で色付き等高線グラフを描画'}\n\n```{.r .cell-code}\nfilled.contour(volcano)\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n## デバイス\n\nRStudioを用いるときにはあまり意識する必要がない概念ですが、R GUIを用いてグラフを作成するときには、**デバイス**というものを理解することが重要となります。デバイスとは、グラフを描画するときの「キャンパス」に当たるもので、この「キャンパス」にグラフを描画して、「キャンパス」を表示したり、PDFやJEPGのようなファイル形式として出力したりすることができます。デバイスは、絵を描く時に「キャンパス」を複数準備することができるのと同じように、複数準備することができます。また、グラフを描画したデバイス上に、もう一枚グラフを重ね書きすることもできます。\n\n上記の高レベルグラフィック関数は、呼び出した際に自動的にデバイスを作成し、そのデバイス上にグラフを描画、表示しています。\n\nデバイスを作成する関数が、`dev.new`関数です。`dev.new`関数を引数なしで指定することで、新しいデバイスを作成することができます。この新しく作成したデバイスには何も描画されていません。`dev.new`関数を呼び出すたびに、新しいデバイスが作成されます。\n\n\n::: {.cell filename='デバイスの作成'}\n\n```{.r .cell-code}\ndev.new() # device 2を作成\ndev.new() # device 3を作成\ndev.cur() # 現在のデバイス（3が返ってくる）\ndev.list() # デバイスのリスト（2と3が返ってくる）\nplot(1:10) # device 3にプロットを描画\n```\n:::\n\n\n作成したデバイスを閉じるための関数が、`dev.off`関数です。`dev.off`関数では、後に作成したデバイスから閉じていきます。ですので、上の例のように、2枚のデバイス（device 2 とdevice 3）を作成していた場合には、`dev.off`関数によりまずdevice 3 が閉じられて、次に`dev.off`関数を呼ぶとdevice 2 が閉じ、すべてのデバイスが閉じられることになります。\n\n複数のデバイスが存在している時に、すべてのデバイスを閉じる関数が、`graphics.off`関数です。`dev.new`関数で複数のデバイスを開いていても、`graphics.off`関数を呼び出せばすべてのデバイスを一度に閉じることができます。\n\n\n::: {.cell filename='dev.off関数とgraphics.off関数'}\n\n```{.r .cell-code}\ndev.off() # device 3を閉じる\ndev.off() # device 2を閉じる\ngraphics.off() # デバイスをすべて閉じる\n```\n:::\n\n\n### OSごとのデバイス\n\nRでは、OS（Windows、UNIX、MacOX）ごとのデバイス呼び出し関数が設定されています。Windowsでは`windows`関数、UNIXでは`X11`関数、MacOXでは`quartz`関数が新しいデバイスを作成する際に用いられます。\n\n\n::: {.cell filename='各OSでのデバイス操作'}\n\n```{.r .cell-code}\nwindows() # windowsでのデバイス作成\ndev.off()\n\nX11() # UNIXでのデバイス作成\ndev.off()\n\nquartz() # Macでのデバイス作成\ndev.off()\n```\n:::\n\n\n## グラフをファイルに保存する\n\nデバイスには、pdfやtiffのような、画像に関するファイルを作成する機能を持つものもあります。例えば`pdf`関数は引数にファイル名を取るデバイス作成関数で、そのデバイスを引数で指定したファイル名で保存する関数です。デバイスが開いている間は、そのPDFファイルを開いている状態になっており、Windowsなどからアクセスすることはできません。したがって、PDFファイルが完成するのは、**そのデバイスを閉じた時**になります。\n\n\n::: {.cell filename='pdf関数でPDFにグラフを出力する'}\n\n```{.r .cell-code}\npdf(file = \"filename.pdf\") # PDFファイルをデバイスに設定\nplot(1:10)\ndev.off() # plotが保存されたpdfが作成される\n```\n:::\n\n\nRには、`pdf`関数の他に、[postscriptファイル](https://www.adobe.com/jp/products/postscript.html)として保存するための`postscript`関数やtiffファイルとして保存するための`tiff`関数など、グラフをファイルとして保存するための複数の関数が設定されています。\n\n以下の表4に、Rでのデバイス操作に関する関数の一覧を示します。\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: 表4：デバイス操作に関する関数の一覧\n\n|関数         |関数の意味                           |\n|:------------|:------------------------------------|\n|dev.new      |デバイスを作成する                   |\n|windows      |デバイスを作成する（Windows）        |\n|X11          |デバイスを作成する（UNIX）           |\n|quartz       |デバイスを作成する（Mac）            |\n|pdf          |PDFデバイスを作成する                |\n|postscript   |postscriptデバイスを作成する（.eps） |\n|bitmap       |bmpデバイスを作成する                |\n|tiff         |tiffデバイスを作成する               |\n|dev.cur      |現在のデバイスを返す                 |\n|dev.list     |デバイスの一覧を返す                 |\n|dev.off      |デバイスを閉じる                     |\n|graphics.off |デバイスをすべて閉じる               |\n\n\n:::\n:::\n\n\n## グラフの重ね書き\n\n同じデバイス上に2つのグラフを重ね書きする場合には、「`par(new = T)`」を2つの高レベルグラフィック関数の間に置きます。この「`par(new = T)`」は、デバイスは以前にグラフを描画したものと同じものを利用して、グラフを重ね書きすることを指示するための関数です。ただし、この重ね書きでは、プロットの**横軸と縦軸のレンジが同じになるよう調整はしてくれない**ので、高レベルグラフィック関数内で軸のレンジ等をあらかじめ設定する必要があります。\n\n\n::: {.cell filename='par(new=T)でグラフを重ね書きする'}\n\n```{.r .cell-code}\nplot(1:10)\npar(new = T)\nplot(1:10, c(1:5, 1:5), col = \"red\") # 軸がずれたグラフが重ね書きされる\n```\n\n::: {.cell-output-display}\n![](chapter20_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "chapter20_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/rglWebGL-binding-1.3.1/rglWebGL.js\"></script>\n<link href=\"site_libs/rglwidgetClass-1.3.1/rgl.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/rglwidgetClass-1.3.1/rglClass.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/utils.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/buffer.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/subscenes.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/shaders.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/shadersrc.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/textures.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/projection.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/mouse.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/init.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/pieces.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/draw.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/controls.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/selection.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/rglTimer.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/pretty.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/axes.src.js\"></script>\n<script src=\"site_libs/rglwidgetClass-1.3.1/animation.src.js\"></script>\n<script src=\"site_libs/CanvasMatrix4-1.3.1/CanvasMatrix.src.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}