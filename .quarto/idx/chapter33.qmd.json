{"title":"ネットワーク解析","markdown":{"headingText":"ネットワーク解析","containsRefs":false,"markdown":"\n```{r, setup, include=FALSE, echo=FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE\n)\n\npacman::p_load(tidyverse)\n```\n\n## ネットワーク解析とは？\n\n**ネットワーク解析**とは、たくさんの人や都市、ウェブページなどの関係性（ネットワーク）を解析する一連の解析手法のことを指します。ここでのネットワークとは、例えば友人関係やメールの送付、電車の路線での駅同士のつながりや物資のやり取りなど、多岐に渡ります。生物学であれば代謝経路や遺伝子の誘導・抑制の関係性、会社であれば命令系統などもネットワークの例となります。これらのネットワークを表示し、特徴を抽出することでネットワークを評価する手法がネットワーク解析です。\n\nネットワークの基本は、人や都市などの要素と、そのつながりの2つです。ネットワーク解析では、人や都市などの要素のことを**node**や**vertex**、つながりのことを**link**や**edge**と呼びます。また、このネットワーク全体のことを**graph**と呼びます。\n\nlinkやedge、つまりネットワークのつながりには、大きく分けて2つのタイプがあります。一つは友人関係や線路での結合など、方向性が無いもので、もう一つはメールの送付や物資の輸送などの方向性があるものです。方向性のないつながりのことを**無向（undirected）**、方向性のあるつながりのことを**有向（directed）**と呼びます。\n\n![図1：ネットワークの用語](./image/network_graph.png)\n\n主要なネットワーク解析の目的は以下の通りです。\n\n- ネットワークを作成し、取り扱う \n- ネットワークを表示する \n- 重要なnodeを抽出する（中心性） \n- nodeをグループ分けする（クラスター化） \n- グラフの特徴を評価する \n- nodeからnodeへの経路を探索する \n\nこの他にランダムなグラフの作成、グラフの類似性の評価や検定を用いたネットワーク解析もあります。\n\n## Rでのネットワーク解析のライブラリ\n\nRでのネットワーク解析には、[`statnet`](https://statnet.org/)[@statnet_bib1; @statnet_bib2]系ライブラリと[`igraph`](https://r.igraph.org/index.html)[@igraph_bib1; @igraph_bib2]系ライブラリの2系統があります。どちらもネットワーク解析を行うために必要十分な機能を備えていますが、オブジェクトの取り扱いや関数名の特徴が異なります。どちらを使うかは好みで決めてしまってよいですが、`igraph`系の方が情報が多いため比較的使いやすいと思います。\n\n`statnet`は`sna`[@sna_bib]や`network`[@network_bib1; @network_bib2]などの一連のネットワーク解析用ライブラリの総称で、`tidyverse`のように`install.packages(\"statnet\")`で一度にインストールし、`library(statnet)`で一度にロードすることができます。`statnet`はよくできたライブラリ群だと思うのですが、解説文（Documentation）があまり充実しておらず、なかなか手を付けにくい印象があります。\n\n`igraph`はネットワーク解析に必要な関数を一通り備えたライブラリで、RだけでなくpythonやMathematica、Cにも機能を提供しています。ネット上にも`igraph`の情報はたくさん落ちており、`statnet`よりは間口が広く学びやすいかと思います。ただし、`statnet`も`igraph`もたくさんの機能を備えたライブラリであり、学習コストは高めです。\n\nこの`igraph`、非常にたくさんの関数を備えたライブラリではあるのですが、関数の命名規則や引数の形が一定ではなく、そのまま使うとやや使いにくいです。また、`tidyverse`などのRの標準的なパッケージとの相性もあまりよくありません。この命名や`tidyverse`との整合性を取るためのライブラリが`tidygraph`[@tidygraph_bib]です。`tidygraph`はほぼ`igraph`のwrapper（関数名と引数の形を整えたもの）ですが、`igraph`をそのまま使うよりは使いやすく、パイプ演算子との相性も悪くありません。\n\nこの章ではまず`igraph`について説明し、その後に`tidygraph`と`igraph`の関数との対応を説明することにします。\n\n```{r, filename=\"ライブラリのロード\"}\npacman::p_load(igraph, tidygraph, tidyverse)\n```\n\n## igraph\n\n### igraphでの用語\n\n`igraph`では、ネットワーク全体を**graph**、ノードを**vertex**、リンクを**edge**と呼びます。それぞれをnetwork、node、linkと呼ぶことは基本的にありません（ただし、一部の関数の引数としてnodeを使っていたりします）。\n\n![図2：igraphでの呼び方](./image/graph_at_igraph.png)\n\n### グラフを作成する\n\n`igraph`でグラフ、つまりネットワークの全体図を作成する方法はいくつかあります。\n\n- **edge vector**から作成する\n- **edge list**から作成する\n- **adjacent matrix**から作成する\n- **literal**から作成する\n- formulaから作成する\n- **data.frame**から作成する\n\n単純なグラフを作成するのであればedge vectorやedge listから、vertexやnodeに特性（`attribute`）を付けた複雑なグラフを作成するのであれば`data.frame`を用いるのが比較的簡単だと思います。\n\n#### edge vectorから作成する\n\nまずはベクターから作成する方法を説明します。\n\nベクターでネットワークを表現する場合には、ベクターに、edgeで繋ぎたいvertex2つをセットで記載します。例えば、`c(\"A\", \"B\")`であれば、AとBというvertexをedgeで繋いだグラフとなります。edgeでつなぐvertexは必ず2つセットになりますので、もう一つedgeを設定したい場合には、1つ目のedgeを示す2つのvertexの後に、さらに2つのvertexを記載します。つまり、`c(\"A\",\"B\", \"A\",\"C\")`といった形で表現することで、A-B、A-Cのedgeを持つ、A、B、Cのvertexを表現することができます。このようなベクターを`igraph`では**edge vector**と呼びます。\n\nとは言っても、edge vectorはただのベクターですので、このedge vectorからグラフを作成する必要があります。グラフの作成には、`make_graph`関数を用います。edge vectorを`make_graph`関数の引数とすることで、グラフを作成することができます。\n\nedge vectorでは、基本的に1つ目のvertexから2つ目のvertexの方向にedgeを繋ぐ、有向グラフが作成されます。無向グラフを作成する場合には、引数に`directed=FALSE`と指定します。\n\nグラフを作成し表示すると、グラフの情報が示されます。このグラフの情報については後ほど説明します。\n\n```{r, filenamae=\"edge vectorからグラフを作成する\"}\n# 有向グラフ\nmake_graph(\n  c(1, 2,\n    2, 3,\n    3, 1)\n)\n\n# 無向グラフ\nmake_graph(\n  c(1, 2,\n    2, 3,\n    3, 1),\n  directed = FALSE\n)\n```\n\n##### グラフを描画する\n\nグラフを描画するには、先ほど作成したグラフを`plot`関数の引数に取ります。より複雑なグラフの描画方法については後ほど説明します。\n\n```{r, filename=\"グラフを表示する\"}\nmake_graph(\n  c(1, 2,\n    2, 3,\n    3, 1)\n) |> plot()\n```\n\n#### edge listからグラフを作成する\n\n**edge list**はedge vectorと似ており、edgeでつなぐvertexを1、2列目にそれぞれ記載した行列（edge list）を用いてグラフを作成する方法です。下の例では、A→B、B→C、C→Aのそれぞれのedgeを2列の行列で表現しています。edge listからグラフを作成する場合には、`graph_from_edgelist`関数を用います。`make_graph`関数と同様に、無向グラフを作成する場合には引数に`directed=FALSE`を指定します。\n\n```{r, filename=\"edge listからグラフを作成する\"}\n# byrow=TRUEを指定すると表記と一致してわかりやすい\nedgelist_matrix <- \n  matrix(\n    c(\"A\",\"B\", \n      \"B\",\"C\", \n      \"C\",\"A\"),\n    ncol = 2,\n    byrow=TRUE\n  )\n\n# edgelistを表示する\nedgelist_matrix\n\ngraph_from_edgelist(edgelist_matrix) |> plot()\n```\n\n#### adjacency matrixからグラフを作成する\n\nedge vector、edge listを用いないグラフの作成方法として、**adjacency matrix（隣接行列）**を用いる方法があります。隣接行列は行数と列数が同じ行列（正方行列）で、行名・列名をvertexの名前とした行列です。隣接行列では、行方向に見て0であればedgeなし、1以上であればedgeありとなります。例えば下の例では、Aの行を見ると、A列は0、B列に1、C列に1となっています。これは、AからAはedgeがなく、AからB、AからCへのedgeがあることを示しています。\n\n隣接行列からグラフを作成するための関数が`graph_from_adjacency_matrix`です。`graph_from_adjacency_matrix`関数では、有向グラフ・無向グラフを指定する引数として`directed`ではなく、`mode`が用いられます。デフォルトは`mode=\"directed\"`で、有向グラフが作成されます。無向グラフを作成する場合には`mode=\"undirected\"`を指定します。\n\n隣接行列には1以上の値を設定することができます。1以上の値を設定した場合には、そのedgeが複数、平行なedgeとして設定されます。ただし、`weighted=TRUE`とした場合には、edgeの数ではなく、edgeの`weight`という特性（attribute）の値が指定されることになります。\n\n```{r, filename=\"adjacency matrixからグラフを作成する\"}\nmat <- \n  matrix(\n    c(0, 1, 1,\n      1, 0, 1,\n      1, 1, 0),\n    nrow = 3,\n    byrow = TRUE\n  )\n\n# vertex名は行・列名で設定する\ncolnames(mat) <- c(\"A\", \"B\", \"C\")\nrownames(mat) <- c(\"A\", \"B\", \"C\")\n\n# 隣接行列を表示する\nmat\n\n# 有向グラフ\ngraph_from_adjacency_matrix(mat) |> plot()\n\n# 無向グラフ\ngraph_from_adjacency_matrix(mat, mode = \"undirected\") |> plot()\n```\n\n上の例ではA、B、Cを繋ぐすべてのedgeが両方向になっていますが、片方向にする場合には、例えばA行B列を1、B行A列を0とします。このように設定することで、A→Bのみの有向グラフを作成することができます。また、対角成分（A行A列など）が1以上に設定されている場合には、AからAへの**ループ**となるedgeが設定されます。\n\n```{r, filename=\"adjacency matrixで方向を設定する\"}\nmat2 <-\n  matrix(\n    c(0, 1, 0,\n      0, 0, 1,\n      1, 0, 0),\n    nrow = 3,\n    byrow = TRUE\n  )\n\nmat2\n\n# 有向グラフ\ngraph_from_adjacency_matrix(mat2) |> plot()\n\n# vertex自身へのedge（ループ）\nmatrix(\n  c(1, 1, 1,\n    1, 1, 1,\n    1, 1, 0),\n  nrow = 3,\n  byrow = TRUE\n) |> \n  graph_from_adjacency_matrix() |> \n  plot()\n```\n\n#### literalからグラフを作成する\n\nグラフの表現として、`--`や`-+`などの記号を用いる、literalでもグラフを作成することができます。グラフの表現はそれぞれ以下の通りです。\n\n| literal   | graph              | \n| --------- | ------------------ | \n| A -- B    | A－B（無向グラフ） | \n| A -+ B    | A→B               | \n| A +- B    | A←B               | \n| A ++ B    | A↔B               | \n| A ----+ B | A→B               | \n\n要は、+側が矢印の先になるような記法がliteralです。矢印の反対側は-になります。左端と右端の-、+の間には-を複数挟むこともできます。無向グラフと有向グラフを同じグラフに含めることはできませんので、`--`を用いた場合にはすべてのedgeを`--`で表現する必要があります。\n\nこのliteralからグラフを作成する関数が`graph_from_literal`です。literalは文字列ではなく、そのまま引数として取り、edgeの表現として必要な分だけコンマで繋ぎます。\n\n```{r, filename=\"literalからグラフを作成する\"}\ngraph_from_literal(\n  A-+B, B-+C, C-+D, D++A \n) |> plot()\n```\n\n##### formulaでグラフを作成する\n\nまた、このliteralに似た表現を用いてグラフを作成する方法もあります。引数としてベクターではなく、チルダ（`~`）で始まり、edgeとvertexを表現した`―`と`:`から成る式（formula）を用いる方法です。グラフの作成にはedge vectorの際に用いた`make_graph`を用います。`-`がedge、`:`は複数のvertexへの接続を表します。Rでは`:`の表現が数列（`1:3`など）と異なり混乱しやすいので、あまりお勧めできる表記方法ではないように思います。\n\n```{r, filename=\"formulaを用いてグラフを作成する\"} \nmake_graph(~ A-B, B-C, C-A:D) |> plot() # C-A、C-Dを設定\n```\n\n#### data.frameからグラフを作成する\n\nRで最も頻繁に用いられるデータ型の一つである、データフレームを用いてもグラフを作成することができます。グラフの作成方法はedge listとよく似ていて、1列目と2列目にedgeで接続するvertexを表記したデータフレームを用います。列名はわかりやすいようにそれぞれ`from`と`to`にしておきます。このデータフレームがグラフ作成の基本となります。\n\nまた、データフレームを用いると、edgeやvertexに特性（`attributes`）を持たせたいときに便利です。例えば人間関係であれば、edgeにはメールのやり取りの回数であったり、交友関係の深さを設定することがあります。また、人間関係におけるvertex、つまり人には性別や年齢、所属する組織などを設定したい場合もあるでしょう。データフレームからグラフを作成すると、このような特性を比較的簡単にグラフに持たせることができます。\n\nedgeに特性を持たせたい場合には、上記の`from`と`to`からなるデータフレームに列を追加します。edgeに設定される主な特性は`weight`です。上記のメールの数や交友関係の深さなどを`weight`として数値で設定します。\n\n同じように、vertexにも特性を持たせることができます。edgeを示したデータフレームとは別に、vertexを表現するためのデータフレームを準備します。このデータフレームの1列目には、edgeのデータフレームに示したvertexをすべて含める必要があります。また、edgeのデータフレームに含まれないvertexを含めることもできます（edgeによる接続のない、独立したvertexが追加されます）。2列目以降には、vertexの特性、例えば人であれば年齢や性別の列を作成しておきます。\n\nこの2つのデータフレームを用いて、グラフを作成します。データフレームからグラフを作成するための関数が`graph_from_data_frame`です。`graph_from_data_frame`では、edgeを表現したデータフレームだけあればグラフを作成することができます。また、`vertices`引数にvertexを表現したデータフレームを設定することで、edgeとは別にvertexやその特性を設定することができます。\n\n```{r, filename=\"データフレームからグラフを作成する\"}\n# edgeのデータフレーム（weightは特性）\nd_edge <- data.frame(\n  from = c(\"A\", \"B\", \"C\"),\n  to = c(\"B\", \"C\", \"A\"),\n  weight = c(1, 2, 3)\n)\n\n# vertexのデータフレーム（age、sexは特性）\nd_vertex <- data.frame(\n  name = c(\"A\", \"B\", \"C\"),\n  age = c(20, 25, 30),\n  sex = c(\"F\", \"M\", \"F\")\n)\n\ng <- graph_from_data_frame(d_edge, vertices = d_vertex)\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## attribute\n\n`attribute`については[3章](./chapter3.html)や[18章](./chapter18.html)で簡単に説明しています。ベクターの名前（`names`）や行列の次元（`dim`）は`attribute`として設定されており、関数から呼び出したり、演算に用いたりすることができます。`igraph`ではこの`attribute`を設定することで、vertexやedgeの性質をリストのように呼び出すことができます。\n\n:::\n\n#### グラフの表示とattributes\n\nここまでで、グラフを作成する方法について述べてきました。作成したグラフは`igraph`クラスのオブジェクトで、表示させるとedgeの一覧と色々な情報が表示されます。\n\n```{r, filename=\"igraphクラス\"}\nclass(g)\n```\n\n```{r, filename=\"igraphクラスのオブジェクトを表示する\"}\ng\n```\n\nこの表示のうち、1行目の`DNW-`という部分はこのグラフの性質を示しています。始めの`D`はDirected（有向グラフ）の略です。無向グラフの場合には`U`（Undirected）と表示されます。\n\n次の`N`はNamedの略で、vertexに名前（`name`）の特性（`attribute`）がついていることを示しています。その次の`W`はWeightedの略で、edgeに`weight`が設定されていることを示しています。vertexに名前がついていない場合には`N`の位置が`-`に、edgeに`weight`が設定されていない場合には`W`の位置が`―`になります。\n\n最後の`―`は**2部グラフ（Bipartite graph）**であるかどうかを示しており、2部グラフの場合は`B`、2部グラフでない場合には`―`が表示されます。2部グラフについては後ほど説明します。\n\n次の`3 3`の部分はvertexとedgeの数を示しており、前がvertexの数、後ろがedgeの数になります。\n\n次の行の`+ attr`は設定されている`attribute`を示しています。`name`、`sex`には`(v/c)`と表示されています。この`(v/c)`はvertexの`attribute`であり、characterであることを示しています。`age`は`(v/n)`、つまりvertexの`attribute`でnumericであること、`weight`は`(e/n)`、edgeの`attribute`でnumericであることが表示されています。この他にグラフ自体にも`attribute`を設定することができます。グラフの`attribute`は`(g/c)`や`(g/n)`で示されます。\n\n最後の行はedgeのリストです。この場合は有向グラフであり、A→B、B→C、C→Aの3つのedgeがあることが示されています。\n\n#### edge/vertexをgraphから取り出す\n\nグラフからedgeを取り出す場合には`E`関数、vertexを取り出す場合には`V`関数をそれぞれ用います。取り出したedgeやvertexには`attribute`が付いたままになっています。\n\n```{r, filename=\"vertex・edgeを取り出す\"}\nE(g)\nV(g)\n```\n\n上記のように、グラフには`attribute`を設定することができます。`attribute`を設定することができるのは、graph全体と、edge、vertexの3種類です。それぞれの`attribute`は`graph_attr`、`edge_attr`、`vertex_attr`関数でそれぞれリストとして取り出すことができます。\n\n```{r, filename=\"attributesを取り出す\"}\ngraph_attr(g)\nedge_attr(g)\nvertex_attr(g)\n```\n\n他のRの関数と同様に、`graph_attr`、`edge_attr`、`vertex_attr`関数にベクターやリストを代入することで、グラフに後から`attribute`を設定することもできます。代入により`attribute`を設定する場合には、関数の第一引数にグラフ、第二引数に`attribute`の名前を文字列で設定します。\n\n```{r, filename=\"attributeを設定する\"}\ngraph_attr(g, \"name\") <- \"ABC\"\nedge_attr(g, \"degree\") <- c(3, 4, 5)\nvertex_attr(g, \"height\") <- c(167, 182, 153)\n\n# attributeが増えている\ng\n```\n\n`attribute`の取り出しには、`graph_attr`、`edge_attr`、`vertex_attr`関数だけでなく、上記の`E`関数、`V`関数を用いることもできます。`E`関数、`V`関数の返り値には`attribute`がくっついているので、`E`関数、`V`関数の後に`$ + attribute名`をつけることで`attribute`をリストのように取り出すことができます。`attribute`を用いて演算を行う場合（たとえばネットワークを`plot`関数で表示するときのオプション設定に`attribute`を用いる場合など）には`E`、`V`関数からの`attribute`の呼び出しを用いることになります。\n\n```{r, filename=\"edgeのattributeをE関数から呼び出す\"}\n# edgeに指定したweightを呼び出し\nE(g)$weight\n\n# edgeの太さをweightに従い決める\nplot(g, edge.width = E(g)$weight)\n```\n\n同じように、vertexの`attribute`もノードの色調整などに用いることができます。\n\n```{r, filename=\"vertexのattributeをV関数から呼び出す\"}\nV(g)$sex\n\nplot(\n  g, \n  edge.width = E(g)$weight, \n  # 男性のvertexはlightblue、女性のvertexはlightpinkで表示する\n  vertex.color = if_else(V(g)$sex == \"M\", \"lightblue\", \"lightpink\"))\n```\n\n### ネットワークを描画する\n\n上記の通り、ネットワークを描画する場合には、`plot`関数の引数にグラフのオブジェクトを取ります。\n\n```{r, filename=\"plot関数でネットワークを表示する\"}\nplot(g)\n```\n\nただし、これだけではedgeやvertexの特性をグラフに反映することはできませんし、場合によっては表示が見にくく、ネットワークの構造をきちんととらえることができないこともあります。\n\n`igraph`では、`plot`関数の引数や`layout`（vertexの位置を決める要素）を設定する一連の関数により、ネットワークを自由に描画できるようになっています。以下に`plot`関数の引数の一覧を示します。\n\n```{r, echo=FALSE}\npacman::p_load(DT, readxl)\ndargs <- read_excel(\"./data/chapter33_plot.igraph_args.xlsx\")\n\nDT::datatable(dargs, caption=\"表1：plot.igraph関数の引数一覧\")\n```\n\nいくつかの引数を指定した例を以下に示します。いろいろ試してみることで自由にネットワークを表示できるようになるでしょう。\n\n```{r, filename=\"vertexのグループ化\"}\nplot(g, mark.groups=list(c(1, 2), c(3)), mark.col = c(\"red\", \"blue\"))\n```\n\n#### layout\n\nネットワークを表示する際には、上記のような引数による細かな表示の変更の他に、ネットワーク自体の形を大きく変える**layout**というものを指定することができます。`plot`関数内の`layout`引数にlayoutを指定するための関数を指定することで、ネットワークの見た目を大きく変えることができます。また、layoutを指定するための関数を前もって宣言しておくことでもlayoutを変更することができます。各`layout`関数にはそれぞれ引数も設定されているので、同じlayout内で見た目を微調整することもできます。\n\n:::{.panel-tabset}\n\n## star\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_as_star(karate))\n```\n\n## tree\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_as_tree(karate))\n```\n\n## circle\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_in_circle(karate))\n```\n\n## nicely\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_nicely(karate)) # plotのデフォルト\n```\n\n## grid\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_on_grid(karate))\n```\n\n## sphere\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_on_sphere(karate))\n```\n\n## randomly\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_randomly(karate))\n```\n\n## with_dh\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_dh(karate)) # Davidson-Harel layout algorithm\n```\n\n## with_fr\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_fr(karate)) # Fruchterman-Reingold layout algorithm\n```\n\n## with_gem\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_gem(karate)) # GEM layout algorithm\n```\n\n## with_graphopt\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_graphopt(karate)) # graphopt layout algorithm\n```\n\n## with_kk\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_kk(karate)) # Kamada-Kawai layout algorithm\n```\n\n## with_lgl\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_lgl(karate)) # Large Graph layout\n```\n\n## with_mds\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_mds(karate)) # multidimensional scaling\n```\n\n## with_sugiyama\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_sugiyama(karate)) # Sugiyama graph layout\n```\n\n## with_drl\n\n```{r}\nkarate <- make_graph(\"Zachary\")\nplot(karate, layout=layout_with_drl(karate)) # force-directed graph layout\n```\n\n:::\n\n:::{.callout-tip collapse=true}\n\n## ネットワークの表記と情報としての正しさ\n\nネットワークをグラフとしてプロットすると、何となくそのネットワークが分かったような気がします。ですので、ネットワーク解析においてプロットすること、ネットワークの表記は非常に重要です。一方で、上記のようにネットワークの表記の方法は様々であり、どのようなネットワークの表記がネットワークの正確な理解につながるのかは難しい問題です。\n\nネットワークに関する[論文](https://www.frontiersin.org/journals/psychology/articles/10.3389/fpsyg.2018.01742/full) [@Jones_2018_f_in_psycho_bib]では、ネットワークの表記において勘違いしやすい点が4点挙げられています。\n\n- vertexの位置が近いとvertexの関係が密接で、遠いと密接ではないように思う\n- vertexの縦横の位置に意味があるように思う\n- ネットワークの中心に表記されているvertexが重要だと思う\n- 2つのネットワークの図が全然違うと、ネットワークは全く異なっていると思う\n\n上記の4点は表記法により正しかったり間違っていたりするため、必ずしも表示されたネットワークがネットワークの正確な情報を伝えているというわけではありません。ネットワークの描画は乱数依存であるため、例えば下図のように同じグラフを2回表示するだけでも、グラフは同じ形には表記されません。\n\n```{r, filename=\"同じネットワークを2度表示する\"}\npar(mfrow = c(1, 2))\nkarate |> plot()\nkarate |> plot() # seedを指定しないと見た目が変わる\n```\n\n上記で紹介した[論文](https://www.frontiersin.org/journals/psychology/articles/10.3389/fpsyg.2018.01742/full)には、ネットワークの情報を正確に伝えるためのプロットの手法について記載されています。ご一読されるとよいでしょう。\n\n:::\n\n## Zachary's karate club\n\n上記のlayoutでは、`karate <- make_graph(\"Zachary\")`という形で`igraph`に登録されているネットワークである、`\"Zachary\"`を読み込んで利用しています。`make_graph`関数では、`igraph`に登録されているネットワーク（[Notable graphs](https://r.igraph.org/reference/make_graph.html)）を文字列で指定することで、`igraph`に保存されているネットワークを呼び出すことができます。\n\nこれらのネットワークの中でも有名なものの一つが上記の[**Zachary's karate club**](https://en.wikipedia.org/wiki/Zachary%27s_karate_club)です。この空手クラブのデータは[Zachary et al. (1976)](https://www.researchgate.net/publication/248519014_An_Information_Flow_Model_for_Conflict_and_Fission_in_Small_Groups1)[@Zachary1976]で人類学的な解析に用いられたもので、アメリカの大学の空手クラブにおけるメンバー間の交友関係をネットワークとしたものです。この空手クラブ、1番と34番のメンバーを中心とした2つのグループに別れたことで有名で、ネットワークについての教科書などで頻出するデータとなっています。\n\n以下のネットワーク図はメンバーが分離した後の2グループを色で示したものになっています。次に説明する中心性の評価、クラスターの評価にはこのデータを用います。\n\n```{r, filename=\"Zachary`s karate club\"}\nkarate <- make_graph(\"Zachary\")\n\n# 2つに分離した後のグループ\nkarate_col <- \n  c(\"A\", \"A\", \"A\", \"A\", \"A\", \n    \"A\", \"A\", \"A\", \"A\", \"B\", \n    \"A\", \"A\", \"A\", \"A\", \"B\", \n    \"B\", \"A\", \"A\", \"B\", \"A\", \n    \"B\", \"A\", \"B\", \"B\", \"B\",\n    \"B\", \"B\", \"B\", \"B\", \"B\", \n    \"B\", \"B\", \"B\", \"B\")\n\nset.seed(1)\nplot(\n  karate, \n  vertex.color=\n    if_else(\n      karate_col == \"A\", \n      \"lightblue\", \n      \"orange\"), \n  vertex.size = 25)\n```\n\n### 中心性\n\n上記の通り、Zachary's karate clubのネットワークは1と34のメンバーを中心に2つのグループに分離しました。上のネットワーク図を見ると、確かに1と34にはたくさんのedgeが接続しているように見えます。しかし、実際に1と34がネットワークで中心的な役割があるのかと言われると、グラフだけを見ていてもいまいちよくわかりません。\n\nネットワークで中心的でかつ重要なvertexを抽出するための手法の一つが、**中心性（centrality）**の評価です。ネットワーク解析でよく用いられる中心性は以下の4種類です。\n\n- **次数中心性**（degree centrality）\n- **媒介中心性**（betweenness centrality）\n- **近接中心性**（closeness centrality）\n- **固有ベクトル中心性**（eigenvector centrality）\n\n**次数中心性**は最も単純な中心性で、そのvertexに接続しているedgeの数を表します。`igraph`では`degree`関数で次数中心性を計算することができます。\n\n**媒介中心性**はそのvertexが他のvertexの間に存在する頻度を表したものです。`igraph`では`betweenness`関数で媒介中心性を計算することができます。\n\n**近接中心性**はそのvertexから他のvertexまでの距離の和を反映したもので、`igraph`では`closeness`関数で近接中心性を計算することができます。\n\n**固有ベクトル中心性**は隣接行列から演算できる中心性の指標です。`igraph`では`eigen_centrality`関数で固有ベクトル中心性を計算することができます。\n\nこの他にも様々な中心性の指標はありますが、とりあえずこの4つを比較するとある程度は中心的なvertexを特定することができるでしょう。以下はkarate clubのネットワークでのvertexの中心性を評価したものです。いずれの中心性でも、1と34が高い値を示しており、この2人が重要なvertexであったことがわかります。\n\n```{r, filename=\"中心性の演算\", fig.width=10, fig.height=7}\n# 次数中心性\ndegree(karate)\n\n# 媒介中心性\nbetweenness(karate)\n\n# 近接中心性\ncloseness(karate)\n\n# 固有ベクトル中心性\neigen_centrality(karate)$vector\n\n# それぞれをプロットする\npar(mfrow = c(2, 2))\ndegree(karate) |> plot()\ntitle(\"次数中心性\")\nbetweenness(karate) |> plot()\ntitle(\"媒介中心性\")\ncloseness(karate) |> plot()\ntitle(\"近接中心性\")\neigen_centrality(karate)$vector |> plot()\ntitle(\"固有ベクトル中心性\")\n```\n\n#### PageRank\n\n上記の中心性と似た中心性の評価基準として、**PageRank**があります。PageRankは[Googleが検索エンジンにおいてホームページの順位付けをする](https://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%A9%E3%83%B3%E3%82%AF)のに用いた評価方法です。`igraph`では`page_rank`関数でPageRankの演算を行うことができます。\n\n```{r, filename=\"PageRankによるvertexの評価\"}\npage_rank(karate)[[1]] |> plot()\n```\n\n#### Edge betweenness\n\nvertexの媒介性ではなく、edgeの媒介性、つまりvertexとvertexの経路の間にあるedgeを評価する方法がedge betweenness（辺の媒介性）です。edge betweennessが高い辺が切れてしまった場合には、ネットワークが大きく分断されることになります。以下の通り、karate clubでは1と32の間のedge betweennessが高く、ココが切れるとネットワークが2つに分離しやすくなります。\n\n```{r, fig.width=10, filename=\"edge betweenness\"}\n# edge betweennessを演算\nedge_betweenness(karate)\nedge <- karate |> as_edgelist() |> as.data.frame()\n\n# Edge betweennessをグラフで表示\ndata.frame(edge , betweenness = edge_betweenness(karate)) |> \n  mutate(edge = paste0(V1, \"-\", V2)) |> \n  ggplot(aes(x = edge, y = betweenness))+\n  geom_point(size = 3)+\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))\n```\n\n### ネットワークのクラスター（コミュニティ）\n\nネットワーク解析の目的の一つは、ネットワーク上のクラスター（コミュニティ）を明らかにすることです。karate clubの例であれば、2つのクラスターが存在することがあらかじめ分かっていれば、グループが割れないように対策することができたかもしれません。\n\n[28章](./chapter28.html)で説明したようにクラスター解析には様々な方法があります。同じように、ネットワーク解析におけるクラスター解析にも様々なものがあります。`igraph`に登録されているクラスター解析だけで10種以上あります。どれがいいのかは時と場合によりますが、いずれも`igraph`では名前が`cluster_`から始まる一連の関数で演算することができます。\n\n以下に`igraph`が備えているクラスター解析とkarate clubの分離後の2グループを比較したものを示します（一番左の`karate`が分離後のグループ）。グラフで左側に示したものほど`karate`との一致度が高くなっています。それぞれの関数には解析方法を調整するための引数が多数準備されているので、うまく調整することでより精度の高いクラスター解析を行うこともできます。したがって、必ずしも以下の例のように`cluster_fluid_communities`が優れているというわけではありません。時と場合により手法を使い分けるのが良いでしょう。\n\n```{r, filename=\"ネットワークのクラスターの演算\"}\n# クラスターを計算\nkarate_clus <- data.frame(\n  vertex = as.character(1:34) |> factor(levels=1:34),\n  karate = if_else(karate_col == \"A\", 1, 2),\n  edge_betweenness = cluster_edge_betweenness(karate)$membership,\n  fast_greedy = cluster_fast_greedy(karate)$membership,\n  fluid_communities = cluster_fluid_communities(karate, no.of.communities = 2)$membership,\n  infomap = cluster_infomap(karate)$membership,\n  label_prop = cluster_label_prop(karate)$membership,\n  leading_eigen = cluster_leading_eigen(karate)$membership,\n  optimal = cluster_optimal(karate)$membership,\n  spinglass = cluster_spinglass(karate)$membership,\n  walktrap = cluster_walktrap(karate)$membership\n) \n\n# 同一クラスターのvertexを同じ色で表示する\nkarate_clus|> \n  pivot_longer(2:11, names_to = \"type\", values_to = \"cluster\") |> \n  mutate( # 見やすいように順番を入れ替え\n    type = \n      fct_relevel(\n        type, \n        c(\n          \"karate\", \n          \"fluid_communities\", \n          \"fast_greedy\", \n          \"leading_eigen\", \n          \"edge_betweenness\", \n          \"walktrap\", \"infomap\", \n          \"label_prop\", \n          \"optimal\", \n          \"spinglass\"))) |> \n  ggplot(aes(x = type, y = vertex, color = factor(cluster), fill = factor(cluster))) +\n  geom_tile()+\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))\n\n```\n\n#### クリーク（cliques）\n\n類似の解析方法として、クリーク（cliques、小集団）という、サブグループを見つけるための解析方法もあります。こちらはすべてのvertexをクラスターに所属させるようなものではなく、内部に存在する小集団（例えば、会社の一部署のメンバーなど）を求める手法となっています。`clique_num`関数はクリークに含まれる最大のvertex数を返す関数です。この`clique_num`の返り値を`cliques`関数の`min`引数に取ることで、クリークを比較的簡単に見つけることができます。下の例では、5人のクリークを2つ検出しています。\n\n```{r, filename=\"クリーク（clique）の演算\"}\nclique_num(karate)\ncliques(karate, min = 5)\n```\n\n### ネットワークの特徴を評価する\n\n#### edgeの密度（edge density）\n\nネットワーク解析では、ネットワーク全体を評価することもあります。代表的な特徴として、ネットワークの密度（edge density）があります。密度とは、現在のedgeの数の、そのvertex数で実現可能な最大のedgeの数に対する割合を指します。karateの例では、edgeの数は78ですが、34人のネットワークですべての人がedgeでつながっている場合、つまりedgeの最大数は`sum(33:1)`、つまり561となります。この78と561の比、`78/561`がedge densityとなります。\n\n`igraph`ではedge densityを`edge_density`関数で演算することができます。\n\n```{r, filename=\"edgeの密度（edge density）\"}\nedge_density(karate) # edgeの密度\nE(karate) # 78 edge\nE(make_full_graph(n=34)) # full graph(すべてのvertexがedgeでつながっている場合)：561 edge\n\n78 / 561 # edge_densityの結果と同じ\n```\n\n#### 次数の分布\n\n次数（degree）、つまりそれぞれのvertexから出ているedgeの数もネットワークの構造を反映するパラメータとなります。次数をヒストグラムとして表示すれば、edgeの分布やその偏りを図示することができます。`igraph`では、`degree_distribution`関数で次数の頻度を計算することができます。また、この関数の返り値を`hist`関数の引数とすることで、次数のヒストグラムを表示することができます。\n\n```{r, filename=\"次数の分布\"}\ndegree_distribution(karate) |> hist() # 次数の分布\n```\n\n#### その他の評価尺度：vertexの距離・ネットワークの直径\n\n上記のedgeの密度や次数の分布に加えて、vertex間の平均距離や距離の分布、ネットワークの直径もネットワークの性質を表すパラメータとして用いられています。vertex間の距離の分布は`distance_table`関数で、ネットワークの直径は`girth`関数で計算することができます。\n\n```{r}\nmean_distance(karate) # vertex間の平均距離\ndistance_table(karate) # vertex間の距離の要約\ngirth(karate) # ネットワークの直径\n```\n\n\n### 経路を探索する\n\nネットワーク解析では、上記のような中心性やクラスター以外に、vertexからvertexまでの経路を探索することも目的となります。karate clubでは経路を調べる意味はあまりありませんが、例えば鉄道の路線図や飛行機の航路であれば、最短経路や複数の経路を求める必要があるでしょう。\n\n経路の探索の例として、路線図のデータを利用します。以下は奈良の鉄道（近鉄・JR）の路線のネットワーク（路線図）です。この路線図を利用して経路の探索を説明します。\n\n```{r, filename=\"奈良の路線図\"}\n# 駅同士の接続（d）と駅（vt）のデータを読み込む\nd <- read.csv(\"./data/chapter33_nara_stations.csv\")\nvt <- read.csv(\"./data/chapter33_nara_stations_vertex_list.csv\")\n\n# dとvtからネットワークを作成\nnara_stations <- graph_from_data_frame(d, vertices = vt, directed = FALSE)\n\n# ネットワークの表示\nnara_stations\n\n# ネットワークを図にする\nplot(\n  nara_stations, \n  curved = TRUE, \n  layout = cbind(V(nara_stations)$lon, V(nara_stations)$lat), \n  vertex.label = NA, \n  vertex.size = 4)\n```\n\n#### vertex間の距離行列\n\nvertex間の距離は行列の形で、`distances`関数を用いることで求めることができます。到達可能性が無いvertexとの間の距離は無限大（`Inf`）となります。`distances`関数には到着点（`to`引数）を設定することができます。\n\n奈良の鉄道路線の例であれば、田原本線は独立線になっている（王寺-新王寺、西田原本-田原本間は路線としては接続しておらず、別の駅）ので、奈良へは到達不可能（`Inf`）になっています。\n\n```{r, filename=\"vertex間の距離を調べる\"}\ndistances(nara_stations)[1:5, 1:5]\ndistances(nara_stations, to=\"奈良\")[40:50,]\n```\n\n#### 最短距離の探索\n\n最短距離の探索には、`shortest_paths`関数、`all_shortest_paths`関数を用います。`shortest_paths`関数は最短距離を1つだけ、`all_shortest_paths`関数はすべての最短距離を返します。路線ではなかなか最短距離が複数存在する場合はありませんので、下の例では`all_shortest_paths`は一つの経路を返しています。\n\n```{r, filename=\"最短距離の探索\"}\nshortest_paths(nara_stations, from = \"奈良\", to = \"吉野口\")\nall_shortest_paths(nara_stations, from = \"桜井\", to = \"吉野口\")\n```\n\n距離行列・最短距離の探索には、幅優先探索（breadth-first search）や深さ優先探索（depth-first search）などのアルゴリズムが用いられています。また、edgeの特性に`weight`を設定していた場合には、`weight`を考慮した評価を行うこともできます。\n\n### その他の分析について\n\nネットワーク解析には、上記に示した解析方法に加えて、ランダムなグラフの作成、グラフの類似性や検定を用いたネットワーク解析などがあります。\n\n`igraph`ではランダムなグラフの作成には関数名が`sample_`から始まる一連の関数が、一定の構造を持つグラフの作成には`make_ring`や`make_star`関数などの関数が備わっています。ランダムなグラフの作成では、それぞれの関数に設定されたアルゴリズムに従いネットワークが作成されます。また、`make_`関数でのグラフ作成では、一定の構造を持つグラフが作成されるため、グラフ作成時の基礎構造を準備するのに便利です。\n\n```{r, filename=\"ランダム・一定の構造を持つグラフの作成\"}\ng <- sample_tree(n = 30) # ランダムな木構造型ネットワークを作成\nplot(g, layout=layout_as_tree(g))\n```\n\nとは言っても`igraph`に登録されている`sample_`関数だけでも10種以上あり、それぞれのアルゴリズムも複雑です。また、グラフの類似性や検定を用いたネットワーク解析に関しては`igraph`のみでは対応できず、別のライブラリ（`statnet`、`sna`）が必要となります。上記のネットワーク解析に関しても詳細な説明は加えていませんので、詳細を理解したい方は教科書（[Rで学ぶデータサイエンス ネットワーク分析](https://www.amazon.co.jp/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E5%88%86%E6%9E%90-%E7%AC%AC2%E7%89%88-R%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9-%E9%88%B4%E6%9C%A8-%E5%8A%AA/dp/4320113152)）を一読されることをおすすめいたします。\n\n以下に`sample_`と`make_`関数の一覧を示します。\n\n:::{.panel-tabset}\n\n## sample_bipartite\n\n```{r}\n# ランダムな2部グラフを作成する\nsample_bipartite(10, 10, p = 0.3) |> plot(layout = layout_as_bipartite) # pはedgeの頻度\n```\n\n## sample_gnp\n\n```{r}\ngr <- sample_gnp(20, p = 0.3) # Erdos-Renyi modelに従い作成（20はvertex数、pはedgeの頻度）\ngr |> plot() \n```\n\n## sample_correlated_gnp\n\n```{r}\ngr |>  sample_correlated_gnp(corr = 0.2) |> plot() # edgeをランダムに付け加え・取り除く\n```\n\n## sample_degseq\n\n```{r}\nsample_degseq(rep(4, 10)) |> plot() # nodeのdegree（次数、この例では4）を指定したグラフ\n```\n\n## sample_dot_product\n\n```{r}\nma <- matrix(runif(90, 0, 0.5), nrow = 9) # matrixを引数に取る\nsample_dot_product(ma) |> plot() # 各列がvertexになる\n```\n\n## sample_fitness\n\n```{r}\nsample_fitness(10, runif(10, 0.1, 0.5)) |> plot()\n```\n\n## sample_fitness_pl\n\n```{r}\nsample_fitness_pl(10, 15, exponent.out = 2.5) |> plot() # vertexの数、edgeの数、degreeの分布を指定する引数\n```\n\n## sample_gnm\n\n```{r}\nsample_gnm(10, 15) |> plot() # vertexの数、nodeの数を指定\n```\n\n## sample_grg\n\n```{r}\nsample_grg(10, 0.85) |> plot() # vertexの数、radiusを指定\n```\n\n## sample_growing\n\n```{r}\nsample_growing(10, m = 3) |> plot() # vertexの数、ランダムに追加するedgeの数\n```\n\n## sample_islands\n\n```{r}\nsample_islands(5, 3, 0.3, 5) |> plot() # gnpでのvertex3つのグラフを5つつないだもの\n```\n\n## sample_k_regular\n\n```{r}\nsample_k_regular(10, 3) |> plot()\n```\n\n## sample_last_cit\n\n```{r}\nsample_last_cit(10, agebins = 5) |> plot()\n```\n\n## sample_pa\n\n```{r}\nsample_pa(10) |> plot()\n```\n\n## sample_pa_age\n\n```{r}\nsample_pa_age(10, 3, -0.5) |> plot()\n```\n\n## sample_pref\n\n```{r}\nsample_pref(30, 10) |> plot()\n```\n\n## sample_sbm\n\n```{r}\nsample_sbm(10, pref.matrix = matrix(runif(9, 0.1, 0.3), nrow=3), block.sizes = c(3, 3, 4), directed = TRUE) |> plot()\n```\n\n## sample_smallworld\n\n```{r}\nsample_smallworld(dim = 2, size = 5, nei = 1, p = 0.2) |> plot()\n```\n\n## sample_traits_callaway\n\n```{r}\nsample_traits_callaway(10, types = 3, edge.per.step = 3) |> plot()\n```\n\n## sample_tree\n\n```{r}\ng_tree <- sample_tree(20)\ng_tree |> plot(layout = layout_as_tree(g_tree))\n```\n\n:::\n\n:::{.panel-tabset}\n\n## make_star\n\n```{r}\nmake_star(n = 10, mode = \"undirected\") |> plot()\n```\n\n## make_ring\n\n```{r}\nmake_ring(n = 10) |> plot()\n```\n\n## make_chordal_ring\n\n```{r}\nmake_chordal_ring(12, w = matrix(c(2, 4, 6, 8, 10, 12), nrow = 2)) |> plot()\n```\n\n## make_empty_graph\n\n```{r}\nmake_empty_graph(10) |> plot()\n```\n\n## make_full_graph\n\n```{r}\nmake_full_graph(10) |> plot()\n```\n\n## make_lattice\n\n```{r}\nmake_lattice(c(3, 3, 3)) |> plot()\n```\n\n## make_tree\n\n```{r}\nmake_tree(16) |> plot()\n```\n\n:::\n\n### 2部グラフ\n\n**2部グラフ（Bipartite graph）**とは、vertexが2つのタイプからなるグラフのことです。この2つのタイプとは、例えば人物と所属するクラブのような、互いに関係性はあるけれども同じタイプ同士のvertex間のつながりは無視できるようなものになります。\n\n以下に2部グラフの例を示します。2部グラフを作成する場合、専用の関数（`make_bipartite_graph`）がありますが、この関数を用いるよりはedge listや`data.frame`からグラフを作成した後、vertexの`type`という`attribute`に論理型で2部のどちらであるか（上の例では人物を`TRUE`、所属するクラブを`FALSE`で指定）を指定する方が作成しやすいと思います。\n\n```{r, filename=\"2部グラフ\"}\nset.seed(0)\n# edgeを示したデータフレームを作成する\nd_edge <- data.frame(\n  club = sample(c(\"野球\", \"サッカー\", \"バスケットボール\", \"バレーボール\"), 52, replace = TRUE),\n  person = c(LETTERS, LETTERS)\n) |> distinct()\n\n# データフレームから2部グラフを作成する\ng <- graph_from_data_frame(d_edge, directed = F)\n\n# typeのattributeを追加する（TRUE、FALSEで2部のどちらであるかを指定する）\nV(g)$type <- V(g)$name %in% d_edge[,2]\nV(g)$type\n\n# 2部グラフ（UN-B、BがBipartiteの意味）になっている\ng\n\ng |> plot(layout = layout_as_bipartite, vertex.color = c(\"orange\", \"lightblue\")[V(g)$type + 1], vertex.shape = c(\"square\", \"circle\")[V(g)$type + 1])\n```\n\n## tidygraph\n\nここまで説明してきた`igraph`は非常に多機能でよくできたパッケージではありますが、関数名や引数名があまり一定ではなく、使用する際に関数名や引数名をチェックしないとうまく使うことができません。引数の指定方法も多岐に渡っており、統一した手法でグラフを取り扱うことができず、使いにくさがあります。\n\nこのような問題を解決するためのライブラリが`tidygraph`パッケージです。`tidygraph`パッケージは基本的に`tibble`を用いてグラフを作成し、`tidyverse`（特に`dplyr`）とパイプ演算子を用いてグラフを編集することを目的として構成されています。\n\nとは言え、`igraph`が非常に機能豊富なパッケージであったのと同様に、`tidygraph`も機能豊富で、利用の難易度は高めです。また、解説文等が少ないため、使い方を理解するのが難しい関数もあります。`dplyr::mutate`関数内以外では使えない関数がたくさんあるなど、使い方もやや複雑です。\n\n### tidygraphの基礎とグラフの作成\n\n`tidygraph`ではグラフはnodeとedgeで表されます。`igraph`とは異なり、nodeがvertexと呼ばれることはありません。\n\n`tidygraph`では、`igraph`と同じく、データフレームからグラフを作成します。また、`igraph`で作成したグラフオブジェクトやedge vector、adjacency matrixからもグラフを作成することができます。データフレームからグラフを作成する場合には`tbl_graph`関数、その他のオブジェクトや`igraph`のグラフから`tidygraph`のグラフを作成する場合には`as_tbl_graph`関数を用います。\n\n作成したグラフのクラスは`igraph`と`tbl_graph`となっており、表示するとnodeとedgeのデータフレームが示されます。`igraph`ではvertexに指定するデータフレームの2列目以降、edgeに指定するデータフレームの3列目以降はattributeとして登録されますが、`tbl_graph`ではnodeとedgeのtibbleとして表示されます。`tbl_graph`は`igraph`のオブジェクトでもあるので、`igraph`と同じように`attributes`としてtibbleの列を呼び出すこともできます。\n\n```{r, filename=\"tbl_graphを作成する\"}\npacman::p_load(tidygraph)\n\nd <- read.csv(\"./data/chapter33_nara_stations.csv\") # edgeのデータフレーム\nvt <- read.csv(\"./data/chapter33_nara_stations_vertex_list.csv\") # nodeのデータフレーム\n\ncolnames(vt) <- c(\"name\", \"lat\", \"lon\", \"linename\", \"company\") # vertex名はname列から取り込まれる\ncolnames(d) <- c(\"from\", \"to\", \"linename\", \"company\") # edgeはfrom→toになる\n\n# tbl_graphをデータフレームから作成する\ng <- tbl_graph(nodes = vt, edges = d, directed = FALSE) \n\n# igraphオブジェクトをtbl_graphに変換する\nas_tbl_graph(karate)\n\nclass(g) # クラスはtbl_graph\nV(g)$lat # igraphとして取り扱い、attributeとして2列目以降を呼び出すこともできる\n```\n\n### node/edgeをactivateする\n\n`igraph`ではnode（vertex）やedgeを呼び出す場合、`V`関数と`E`関数を用いますが、`tidygraph`ではnode・edgeの呼び出しに`activate`関数を用います。`activate`関数はパイプ演算子を用いて呼び出すことが想定されている関数で、パイプ演算子でつないでグラフに適用します。第2引数として`nodes`と`edges`を用います。`activate`関数をグラフに適用すると、`node`・`edge`のtibbleに「activate」と表示されます。この状態でさらにパイプ演算子をつなぐと、activateされている側のtibbleを編集することができます。\n\nnode・edgeのどちらがactiveであるかを調べる場合には、`active`関数を用います。\n\n```{r, filename=\"activate関数\"}\n# node・edgeをactivateする\ng |> active() # nodeがactiveになっている\ng |> activate(edges) # edgeをactiveにする（nodeはactiveではなくなる）\ng |> activate(edges) |> active() # edgeがactiveになっている\n```\n\n### focus\n\n`tidygraph`では、基本的に`activate`でnode・edgeのいずれかを選択した後、`mutate`など`dplyr`の関数を用いてグラフの要素であるtibbleを編集していきます。\n\n`mutate`などで編集を行うために、行を選択するための関数が`focus`です。`focus`関数の引数には論理型を用い、`TRUE`の行のみを`dplyr`の関数での編集の対象とすることができます。以下の例では、nodeのはじめの5行を選択し、その行だけを`mutate`での演算の対象としています。\n\n```{r, filename=\"focusで行を選択して編集する\"}\ng |> \n  activate(nodes) |> \n  focus(c(T, T, T, T, T, rep(F, 114))) |> # 始めの5つのnodeにfocusする\n  mutate(lat = lat - 50) # 初めの5つのnodeのlatから50を引く\n```\n\n### morph・unmorphとcrystalise\n\n上記の`igraph`で説明したクラスター計算では、nodeを各クラスターに分離することができます。ただし、分離したクラスターごとに何らかの演算をしたい場合や、nodeのグループごとに演算を行いたい場合、`igraph`には簡単に計算する方法はありません。`tidygraph`では、このようなグループごとの演算を`morph`関数を用いて簡単に行うことができます。\n\n`morph`関数はnode・edgeのtibbleを一時的に変換するための関数です。`tidygraph`の開発者（Dr. \nThomas Lin Pedersen、`patchwork`や`gganimate`の開発者）は、この`morph`/`unmorph`/`crystalise`を[`tidygraph`の最も代表的な関数の一つ](https://www.data-imaginist.com/posts/2018-02-12-tidygraph-1-1-a-tidy-hope/index.html)だと考えているようで、使い方を理解すれば非常に便利な関数群です。\n\n以下の例では`group_infomap`関数（`igraph`の`cluster_infomap`関数のwrapper）でnodeをクラスター分けし、`morph`関数内ではそのクラスター（`group`）に従い`to_split`関数でtibbleを一時的に`nest`しています（`tidyr::nest`に関しては[16章](./chapter16.html)を参照。複数の要素をtibbleの「セル」として設定する方法のこと）。\n\n`nest`したtibbleに対して`graph_diameter`関数（`igraph`の`diameter`関数のwrapper）と`centrality_degree`関数（`igraph`の`degree`関数のwrapper）を適用することで、クラスターごとのネットワークの直径、nodeの中心性を演算して行に追加しています。ただし、このままではtibbleが`nest`されたままです。\n\nこの`nest`されたtibbleをもとに戻すのが`unmorph`関数です。`unmorph`関数を適用することで、nodeのtibbleの`nest`が解除される、つまり`unnest`されて元のグラフに戻ります。\n\nこのように、`morph`/`unmorph`を用いることで、node・edgeのグループごとの演算を簡単に行うことができます。`morph`でのグループ分けのための関数には`to_subgraph`関数（`dplyr::filter`に近い演算を行うもの）や`to_components`関数などが準備されています。\n\n```{r, filename=\"morph・unmorph関数\"}\n# サブグループ内での演算を行うときにはmorph/unmorphを用いる\n# morph内の関数はto_から始まる関数群を用いる\ng |> \n  activate(nodes) |> # nodeをactiveにして\n  mutate(group = group_infomap()) |> # クラスターに分けて\n  morph(to_split, group) |> # グループで一時的に分割・ネストして\n  mutate(\n    group_diameter = graph_diameter(), \n    centrality = centrality_degree()) |> # グループごとに直径を計算して\n  unmorph() # morphをもとに戻す\n```\n\n`morph`で変形したグラフをそのまま固定するための関数が`crystallise`関数です。`crystallise`関数を用いると、`morph`で指定した変形の状態などが固定され、tibbleとしてデータが返ってきます。\n\n```{r, filename=\"crystallise関数\"}\ng |> \n  mutate(group = group_infomap()) |> # クラスターに分けて\n  morph(to_split, group) |> # グループで一時的に分割して\n  crystallise() # crystalliseして固定してしまう\n\ng |> \n  mutate(group = group_infomap()) |> \n  morph(to_split, group) |> \n  crystallise() |> \n  class() # classからgraph関係のものがなくなり、tibbleになっている\n```\n\n### 中心性\n\n`igraph`と同様に、`tidygraph`にも中心性を評価する関数群（`centrality_`から始まる関数）が設定されています。`igraph`との違いは、これらの`centrality_`関数群は単独で呼び出すことができず、nodeをactiveにした上で`mutate`関数の中で呼び出すような使い方をする点です。単独で使用するとエラーが返ってきます。\n\n`tidygraph`にはこの`centrality_`関数が30個以上も設定されています（`igraph`の中心性演算の関数に加えて、`netrankr`[@netrankr_bib]パッケージから方法を引用しています）。\n\n```{r, filename=\"中心性：centrality_関数\", error=TRUE}\ncentrality_degree(g) # 直接呼び出せない\n\n# nodeをactiveにしてからmutateで呼び出す\ng |> \n  activate(nodes) |> \n  mutate(degree_cent = centrality_degree()) \n\n# 4種のcentralityを同時に演算する\ng |> \n  activate(nodes) |> \n  mutate(\n    cent_degr = centrality_degree(),\n    cent_betw = centrality_betweenness(),\n    cent_clos = centrality_closeness(),\n    cent_eigv = centrality_eigen()) \n```\n\n### node・edge・graphの評価\n\n`tidygraph`には、`igraph`と同様にnode、edge、graphを評価するための関数群が設定されています。いずれの関数も単独で呼び出すことはできず、`mutate`関数内で呼び出して用いることが前提とされています。\n\n以下にnodeの評価に関わる関数を示します。上記の中心性もこのnodeの評価に関わる関数の一部となります。\n\n```{r, error=TRUE, filename=\"nodeの評価\"}\n# 単独では呼び出せない\nnode_efficiency(g)\n\ng |> \n  activate(nodes) |> \n  mutate(\n    node_eff = node_efficiency(), # nodeの効率（igraph::local_efficiency）\n    node_core = node_coreness(), # k-core分解（igraph::coreness）\n    node_clos = node_closeness_impact()) # nodeを取り除いたときのclosenessへの影響の大きさ\n```\n\nedgeの評価では、edgeの性質を論理型で返すような関数が主に設定されています。edgeの評価に関する関数はそもそも引数にedgeのtibbleを取るように設定されていません。nodeの場合と同じく、edgeの評価の関数も`mutate`関数内で用いることが想定されています。\n\n```{r, error=TRUE, filename=\"edgeの評価\"}\ng |> \n  activate(edges) |> \n  edge_is_multiple() # そもそも引数として設定できない\n\ng |> \n  activate(edges) |> \n  mutate(\n    multiple = edge_is_multiple(), # 平行するedgeがあるか\n    bridge = edge_is_bridge() # edgeが切断されるとグラフが分離されるか\n  )\n```\n\ngraphの評価に関する関数は`igraph`に設定されている関数群とほぼ同じですが、やはり直接呼び出して用いることはできません。評価の意味に関しては以下を参照して下さい。\n\n[GeekforGeeksのネットワークに関するページ](https://www.geeksforgeeks.org/graph-measurements-length-distance-diameter-eccentricity-radius-center/?ref=lbp)\n\n[グラフ理論講義ノート#8 井上純一先生（北海道大学 情報科学研究科）](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://ocw.hokudai.ac.jp/wp-content/uploads/2016/01/GraphTheory-2007-Note-08.pdf)\n\n```{r, error=TRUE, filename=\"graphの評価\"}\ng |> graph_diameter() # 直接呼び出せない\n\ng |> \n  activate(nodes) |> \n  mutate(\n    g_diameter = graph_diameter(), # グラフの直径（最大の経路長）\n    g_girth = graph_girth(), # グラフの内周（最小の閉路長）\n    g_radius = graph_radius(), # グラフの離心率（igraph::radius）\n    g_size = graph_size() # グラフのedgeの数\n  )\n```\n\n### create_関数とplay_関数\n\n`igraph`では`make_`関数（`make_ring`関数や`make_star`関数など）で形状を指定したグラフを、`sample_`関数（`sample_tree`関数や`sample_gnp`関数など）でアルゴリズムに従ったランダムなグラフを作成することができます。この`igraph`の`make_`関数と`sample_`関数に当たるものが`tidygraph`の`create_`関数と`play_`関数です。出力がtbl_graphであることと、引数の順序・名前以外に`igraph`の関数群と大きな差は無いので、`igraph`の関数に慣れているのであれば`igraph`の関数を用いてグラフを作成した後で`as_tbl_graph`関数を用いて`tbl_graph`に変換してもよいでしょう。\n\n:::{.panel-tabset}\n\n## create_ring\n\n```{r}\ncreate_ring(10) |> plot()\n```\n\n## create_chordal_ring\n\n```{r}\ncreate_chordal_ring(10, 2) |> plot()\n```\n\n## create_complete\n\n```{r}\ncreate_complete(10) |> plot()\n```\n\n## create_empty\n\n```{r}\ncreate_empty(10) |> plot()\n```\n\n## create_tree\n\n```{r}\ncreate_tree(10, 4) |> plot()\n```\n\n## create_star\n\n```{r}\ncreate_star(10) |> plot()\n```\n\n## play_gnm\n\n```{r}\nplay_gnm(10, 20) |> plot()\n```\n\n## play_gnp\n\n```{r}\nplay_gnp(10, 0.25) |> plot()\n```\n\n## play_geometry\n\n```{r}\nplay_geometry(10, 3) |> plot()\n```\n\n:::\n\n### map_関数群\n\n`purrr`の`map`関数と同様に、node、edgeのtibbleに関数を適用して演算を行う関数が`map_`関数群です。\n\n`map_`関数群には大きく分けるとbfs（breath first search）を演算に用いるもの（`map_bfs_`関数）と、dfs（depth first search）を用いるもの（`map_dfs_`関数）があります。\n\n`map_`関数も単独では呼び出すことができず、`mutate`関数内で呼び出すことが想定された関数で、`map_`関数内で引数（`.f`引数）として設定する関数は無名関数のみとなります。この`.f`関数で指定する無名関数については引数が定められていて（`node`, `rank`, `path`など）、かなり使い方が複雑です。また、bfs、dfsで到達不可能なパスが存在すると演算ができなくなります。\n\n以下の例では、bfsによってJR奈良駅から他の駅までの到達に必要な距離を演算しています。`value`に駅間の距離や運賃などを正確に設定すれば、`map_bfs_dbl`関数を用いて到達距離を計算することができます。\n\n```{r, filename=\"map_関数\"}\ng |> \n  # 離れているとbfsで探索できないので、田原本線をつなげる\n  bind_edges(data.frame(from = \"田原本\", to = \"西田原本\", linename = \"田原本線\", company = \"近鉄\")) |> \n  mutate(value = rep(1, 119)) |>  # 駅間を1としている\n  mutate(value_acc = map_bfs_dbl(1, .f = function(node, path, ...){ \n    sum(.N()$value[c(node, path$node)]) # searchの順に値を足していく（各nodeまでの距離を反映）\n  }))\n```\n\n## グラフ表示のライブラリ\n\n上記のように、グラフの表示はグラフの理解において非常に重要です。`igraph`を用いることでグラフを様々な形式で表示することができますが、デザイン的には`ggplot2`などとは異なり、Rのデフォルトのプロットに近い形での表示となります。Rには、`igraph`だけでなく、グラフを表示するためのライブラリがいくつかありますので、以下に簡単に紹介します。\n\n### ggraph\n\n`ggraph`[@ggraph_bib]は上記の`tidygraph`の開発者が開発した、`tbl_graph`を`ggplot2`の文法・デザインで描画するためのライブラリです。仕組みは比較的単純で、以下の例のように`tbl_graph`を`ggplot2`のグラフ表示に適したtibbleに変形し（`create_layout`関数）、`ggplot2`の文法でこの`tibble`を表示しています。この変換において、nodeの位置を`layout`引数で指定した位置に指定させています。\n\n`layout`引数には`\"auto\"`、`\"igraph\"`、`\"dendrogram\"`、`\"manual\"`、`\"linear\"`、`\"matrix\"`、`\"treemap\"`などの様々な値を指定することができます。`layout`による違いは後ほど説明します。\n\n```{r, filename=\"ggraph：create_layout関数\"}\npacman::p_load(ggraph)\n\ncreate_layout(g, layout = \"tree\")\n```\n\n`ggraph`の文法は`ggplot2`と非常に類似しています。まず、`ggplot2`での`ggplot`関数に当たる`ggraph`関数の引数として、グラフ、`layout`引数を設定します。`layout`によってはこの`ggraph`関数内で追加の引数を設定する必要があります。`ggplot2`と同様に、この`ggraph`関数に足し算（`+`）で他の`geom`関数を付け加えていくことでグラフを構成していきます。\n\n以下の例では、nodeを点で表示し（`geom_node_point`）、node側のtibbleの変数である`name`（駅名）をテキストとして重ね書きし（`geom_node_text`）、edgeを運行会社により色分けして直線でつないでいます（`geom_edge_link`）。`ggplot2`の`aes`関数に関しては`geom_node_`関数、`geom_edge_`関数内で指定します。`geom_node_`関数内ではnode側のtibble、`geom_edge_`関数内ではedge側のtibbleの列名を用いて表示する色や大きさを指定することができます。\n\n```{r, filename=\"ggraph：グラフを描画する\"}\n# グラフのテーマの設定（ggplot2のthemeをあらかじめ定めておくもの）\nwindowsFonts(Meiryo = windowsFont(\"Meiryo\"))\nset_graph_style(family=\"Meiryo\", text_size = 5, background = \"white\", caption_size = 3)\n\n# x、yで指定した位置にnodeを表示する\nggraph(g, layout = \"manual\", x = lon, y = lat) +\n  geom_node_point() +\n  geom_node_text(aes(label = name)) +\n  geom_edge_link(aes(color = company))\n```\n\n#### ggraphのlayout\n\nこのggraphのlayout・node・edgeの表示は非常に多種多様で、情報を捉えにくいものも含まれています。[開発者がアートに興味がある](https://thomaslinpedersen.art/)こともあり、ggraphにはどちらかというと現代美術的な、意味よりも見た目重視な表示方法も含まれています。\n\n以下に`layout`の例を示します。`layout`は単にnodeのx・y軸上の位置を定めているだけで、`layout`自体にはそれほど変わったものはありません。とは言え、特定のnode・edgeの表示とセットで用いることを前提としている、使いにくいものもあります。\n\n`layout`には`sf`をベースにしたもの（`layout = \"sf\"`）もあるため、上記のような路線図であれば、`sf`で表示するのもよいでしょう。`sf`については[32章](./chapter32.html)で説明しています。\n\n:::{.panel-tabset}\n\n## auto\n\n```{r}\ng |> ggraph(layout = \"auto\") +\n  geom_node_point() +\n  geom_edge_link() # stressが選択されている\n```\n\n## stress\n\n```{r}\ng |> ggraph(layout = \"stress\") +\n  geom_node_point() +\n  geom_edge_link() # autoで選ばれているのと同じ\n```\n\n## sparse_stress\n\n```{r}\ng |> \n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"sparse_stress\", pivots = 10) + # 分離したグラフでは表示できない\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## igraph\n\n```{r}\ng |> \n  ggraph(layout = \"igraph\", algorithm = \"grid\") + # igraphのon_gridと同じ\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## backbone\n\n```{r}\ng |> \n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"backbone\") + # 分離したグラフには適さない\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## pmds\n\n```{r}\ng |> \n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"pmds\", pivots = 10) +  # 分離したグラフでは表示できない\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## eigen\n\n```{r}\ng |> \n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"eigen\") +  # 分離したグラフでは表示できない\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## centrality\n\n```{r}\ng |> \n  mutate(cent = centrality_degree()) |> # 中心性に従い位置を決定する\n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"centrality\", centrality = cent) +  # 分離したグラフでは表示できない\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## focus\n\n```{r}\ng |> # 分離したグラフでは表示できない\n  bind_edges(data.frame(from=\"田原本\", to=\"西田原本\", linename=\"田原本線\", company=\"近鉄\")) |> \n  ggraph(layout = \"focus\", focus = 1) + # JR奈良駅にfocusする\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## dendrogram\n\n```{r}\ncreate_tree(n=30, children = 4)  |> # 有向グラフにしか適用できない\n  ggraph(layout = \"dendrogram\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## unrooted\n\n```{r}\ng  |> \n  ggraph(layout = \"unrooted\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## linear\n\n```{r}\ng |> \n  ggraph(layout = \"linear\") + \n  geom_node_point() +\n  geom_edge_arc() # 直線ではedgeが見えないのでarcとしている\n```\n\n## circlepack\n\n```{r}\nplay_gnm(30, 80, directed = TRUE)  |>  # 有向グラフのみ対応\n  ggraph(layout = \"circlepack\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## treemap\n\n```{r}\ncreate_tree(n=30, children = 4)  |> # 有向グラフにしか適用できない\n  ggraph(layout = \"treemap\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## partition\n\n```{r}\ncreate_tree(n=30, children = 4)  |> # 有向グラフにしか適用できない\n  ggraph(layout = \"partition\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## cactustree\n\n```{r}\ncreate_tree(n=30, children = 2)  |> # 有向グラフでないとnodeが範囲外に出る\n  ggraph(layout = \"cactustree\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## htree\n\n```{r}\ncreate_tree(n=15, children = 2)  |> # 二分木でないと描画できない\n  ggraph(layout = \"htree\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n## matrix\n\n```{r}\ng |> ggraph(layout = \"matrix\") +\n  geom_node_point() +\n  geom_edge_arc() # 直線では見えなくなるのでarcを選択\n```\n\n## hive\n\n```{r}\ng |> \n  activate(nodes) |> \n  mutate(linename = E(g)$linename[1:119]) |> \n  ggraph(layout = \"hive\", axis = linename) + # linenameを軸として配置\n  geom_node_point() +\n  geom_edge_arc(aes(color=linename)) # 直線では見えなくなるのでarcを選択\n```\n\n## fabric\n\n```{r}\ng |> ggraph(layout = \"fabric\") +\n  geom_node_point() +\n  geom_edge_link()\n```\n\n## metro\n\n```{r}\ng |> ggraph(layout = \"metro\", x = lon, y = lat) +\n  geom_node_point() +\n  geom_edge_link()\n```\n\n:::\n\n#### nodeの表示\n\nnodeの表示には、`geom_node_`関数を用います。`geom_node_`の後にnodeの形状を示す単語（`point`、`text`、`tile`、`voronoi`など）を繋ぐことで、nodeの形状を指定します。`geom_node_`関数は`ggplot2`の`geom_`関数と同様に、`ggraph`関数に`+`でつないで用います。\n\n`geom_node_point`や`geom_node_text`、`geom_node_label`はどのようなグラフで用いても使いやすいですが、`geom_node_voronoi`のようにデザイン重視でネットワークの理解にはつながらないものもあります。以下に`geom_node_`関数の使用例を示します。\n\n:::{.panel-tabset}\n\n## point\n\n```{r}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_point()\n```\n\n## text\n\n```{r}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_text(aes(label = name))\n```\n\n## label\n\n```{r}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_label(aes(label = name))\n```\n\n## tile\n\n```{r}\ng |> \n  ggraph(layout = \"igraph\", algorithm = \"grid\") +\n  geom_node_tile(aes(fill=lon, color = lat, width=0.9, height=0.9))\n```\n\n## voronoi\n\n```{r}\ng |> \n  ggraph(layout = \"stress\") +\n  geom_node_voronoi(aes(color=factor(1), fill=factor(lat), alpha = 0.3))+\n  theme(legend.position = \"none\")\n```\n\n## circle\n\n```{r}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_circle(aes(r = lon/10000, color = factor(lon)))+\n  theme(legend.position = \"none\")\n```\n\n## arc_bar\n\n```{r}\ncreate_tree(n=30, children = 2)  |> \n  mutate(colors = rep(1:5, 6)) |> \n  ggraph(layout = \"partition\", circular = TRUE) +\n  geom_node_arc_bar(aes(fill = factor(colors))) # 内→外へのtreeになっている\n```\n\n## range\n\n```{r}\ng |> \n  ggraph(layout = \"fabric\") +\n  geom_node_range(aes(color = factor(lon)))+\n  theme(legend.position = \"none\")\n```\n\n:::\n\n#### edgeの表示\n\nedgeの表示には、`geom_edge_`関数を用います。`geom_edge_`関数は`geom_node_`関数とほぼ同じように用います。つまり、`geom_edge_`の後に形状を指定する単語（`link`、`arc`など）を繋いだ関数として用い、`ggraph`関数に`+`でつないで用います。\n\n`geom_edge_link`関数や`geom_edge_arc`関数のように比較的使いやすいものから、平行するedge（同じnode間をつなぐ複数のedge）を示すときだけに用いるもの（`geom_edge_parallel`、`geom_edge_fan`）、ループ（ノードからそのノード自身に接続するedge）を示すときだけに用いるもの（`geom_edge_loop`）、特定のlayout・nodeと共に用いることが想定されているもの（`geom_edge_hive`、`geom_edge_span`）など、特定の場合以外にはほぼ用いないものもあります。\n\n:::{.panel-tabset}\n\n## link\n\n```{r}\ncreate_tree(n=30, children = 4)  |>\n  ggraph(layout = \"dendrogram\") + \n  geom_node_point() +\n  geom_edge_link()\n```\n\n\n## arc\n\n```{r}\nkarate  |>\n  ggraph(layout = \"auto\") + \n  geom_node_point() +\n  geom_edge_arc()\n```\n\n## parallel\n\n```{r}\n# マニュアルの例の通り\ngr <- create_notable('bull') |>\n  convert(to_directed) |>\n  bind_edges(data.frame(from = c(1, 2, 2, 3), to = c(2, 1, 3, 2)))\n \nggraph(gr, 'stress') +\n  geom_node_point(aes(size=1))+\n  geom_edge_parallel(aes(alpha = after_stat(index)))+\n  theme(legend.position = \"none\")\n```\n\n## fan\n\n```{r}\ngr <- create_notable('bull') |>\n  convert(to_directed) |>\n  bind_edges(data.frame(from = c(1, 2, 2, 3), to = c(2, 1, 3, 2)))\n \nggraph(gr, 'stress') +\n  geom_node_point(aes(size=1))+\n  geom_edge_fan(aes(alpha = after_stat(index)))+\n  theme(legend.position = \"none\")\n```\n\n## loop\n\n```{r}\ndata.frame(from = c(1, 1, 2, 2, 3, 3, 3), to = c(1, 2, 2, 3, 3, 1, 1)) |> \n  as_tbl_graph() |> \n  ggraph(layout = \"auto\") + \n  geom_node_point() +\n  geom_edge_loop() + # node自身への接続（ループ）を表示する\n  geom_edge_fan()\n```\n\n## diagonal\n\n```{r}\ncreate_tree(n=30, children = 4)  |>\n  ggraph(layout = \"dendrogram\") + \n  geom_node_point() +\n  geom_edge_diagonal() # ベジェ曲線\n```\n\n## elbow\n\n```{r}\ncreate_tree(n=30, children = 4)  |>\n  ggraph(layout = \"auto\") + \n  geom_node_point() +\n  geom_edge_elbow()\n```\n\n## bend\n\n```{r}\ncreate_tree(n=30, children = 4)  |>\n  ggraph(layout = \"auto\") + \n  geom_node_point() +\n  geom_edge_bend()\n```\n\n## hive\n\n```{r}\ncreate_tree(n=30, children = 4)  |> \n  mutate(group = rep(1:3, 10)) |> \n  ggraph(layout = \"hive\", axis = group) + \n  geom_node_point() +\n  geom_edge_hive() # axis間しか繋がない\n```\n\n## span\n\n```{r}\ng |> \n  ggraph(layout = \"fabric\") +\n  geom_node_range(aes(color = factor(lon)))+\n  theme(legend.position = \"none\")+\n  geom_edge_span()\n```\n\n## point\n\n```{r}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  theme(legend.position = \"none\")+\n  geom_edge_point(aes(color = factor(linename)))\n```\n\n## tile\n\n```{r}\ng |> \n  ggraph(layout = \"matrix\") +\n  theme(legend.position = \"none\")+\n  geom_edge_tile(aes(color = linename, fill=linename))\n```\n\n## density\n\n```{r, warning=FALSE}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  theme(legend.position = \"none\")+\n  geom_node_point(size = 0.1)+\n  geom_edge_density(aes(fill=linename))\n```\n\n## bundle_force\n\n```{r}\nmake_graph(\"Zachary\") |> \n  as_tbl_graph() |> \n  ggraph(layout = \"auto\") +\n  theme(legend.position = \"none\")+\n  geom_node_point(size = 0.1)+\n  geom_edge_bundle_force()\n```\n\n## bundle_path\n\n```{r}\nmake_graph(\"Zachary\") |> \n  as_tbl_graph() |> \n  ggraph(layout = \"auto\") +\n  theme(legend.position = \"none\")+\n  geom_node_point(size = 0.1)+\n  geom_edge_bundle_path()\n```\n\n## bundle_path\n\n```{r}\nmake_graph(\"Zachary\") |> \n  as_tbl_graph() |> \n  ggraph(layout = \"auto\") +\n  theme(legend.position = \"none\")+\n  geom_node_point(size = 0.1)+\n  geom_edge_bundle_minimal()\n```\n\n:::\n\n#### faceting\n\n`ggplot2`と同じように、`facet`関数を用いることで、tbl_graphに含まれている変数（`igraph`における`attribute`）を用いてグラフを分割し、表示することができます。`facet`関数には`facet_graph`、`facet_node`、`facet_edge`の3つの関数があり、それぞれ使用感が少しずつ異なります。\n\n`facet`関数の引数にはチルダ（`~`）を用い、チルダの右辺、もしくは両辺に変数を指定することで、グラフを分割表示することができます。\n\n`ggraph`には上に示したものの他に、色や文字等を指定するたくさんの関数が設定されています。\n\n```{r, filename = \"faceting\"}\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_label(aes(label = name, color = company)) +\n  geom_edge_link(aes(, color = company)) +\n  facet_graph(~ company)\n\n# 上と同じ\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_label(aes(label = name, color = company)) +\n  geom_edge_link(aes(, color = company)) +\n  facet_nodes(~ company)\n\n# edgeだけが2つに分かれる\ng |> \n  ggraph(layout = \"manual\", x = lon, y = lat) +\n  geom_node_label(aes(label = name, color = company)) +\n  geom_edge_link(aes(, color = company)) +\n  facet_edges(~ company)\n```\n\n### networkD3\n\n上記のように`igraph`の`plot`関数や`ggraph`で静的なグラフを準備すれば、論文や出版物、プレゼンテーションで示すグラフとしては十分ですが、Web上ではグラフをインタラクティブに示すことでグラフの構造を読み取りやすくできる場合があります。\n\nこのようなインタラクティブなグラフの表示を行うためのライブラリが`networkD3`[@networkD3_bib]です。`networkD3`はJavascriptのグラフィックライブラリである[D3.js](https://d3js.org/)をRに持ち込んで、ネットワークの表記ができるようにしたものです。\n\nD3.jsを用いることができるライブラリには[`r2d3`](https://rstudio.github.io/r2d3/)[@r2d3_bib]もありますが、`r2d3`との違いはネットワークの表記にのみ対応していることで、`r2d3`でもネットワークを表記することはできます。ただし、`r2d3`はデータの準備がかなり独特（[`r2d3`のgithubページ](https://github.com/rstudio/r2d3/blob/main/vignettes/gallery/dendogram/flare.csv)を参照。idの列にネットワークの情報を入力）ですので、`networkD3`の方が比較的使いやすいでしょう。\n\n```{r, filename=\"ライブラリの読み込み\"}\npacman::p_load(networkD3)\n```\n\n#### データの準備\n\n`networkD3`でのグラフ表記には、nodeのデータフレームとedgeのデータフレームをそれぞれ独立に準備する必要があります。`igraph`や`tidygraph`のグラフオブジェクトを`networkD3`で利用する場合には、`igraph_to_networkD3`関数でデータをリストに変換します。この`igraph_to_networkD3`関数は`igraph`のオブジェクトをnodeのデータフレーム、edgeのデータフレーム（名前は`links`）からなるリストに変換してくれるだけの関数です。`group`引数を指定すると、元の`igraph`オブジェクトのattributeやベクターをnodeのデータフレームに付け加えることもできます。\n\n```{r, filename=\"ファイルの準備\"}\n# dとvtからネットワークを作成\nnara_stations <- graph_from_data_frame(d, vertices = vt, directed = FALSE)\n\nns_D3 <- nara_stations |> \n  igraph_to_networkD3(group = V(nara_stations)$linename)\n\nns_D3$links |> head() # edge_listに似たデータフレーム\nns_D3$nodes |> head() # nodeをまとめたもの\n```\n\n#### simpleNetwork関数\n\n最も簡単にネットワークを表示するための関数が、`simpleNetwork`関数です。この関数の引数にedgeを示すデータフレームを設定するだけで、D3.jsを用いたネットワークを表示することができます。このグラフ上では、nodeをドラッグすることでnodeを移動させて表記することができます。\n\nただし、この`simpleNetwork`をそのまま用いるとグラフが拡大されすぎて見えなかったり、nodeの意味がよくわからなくなったりします。グラフが拡大されて見にくい問題は引数に`zoom = TRUE`することで拡大・縮小できるようにすることで対処できます。しかし、他の情報を表示するのにはこの`simpleNetwork`関数は向いていません。\n\n```{r, filename=\"simpleNetwork関数\"}\nsimpleNetwork(ns_D3$links, zoom = TRUE)\n```\n\n#### forceNetwork\n\nもう少し情報を詰め込んだグラフを作成するための関数が`forceNetwork`関数です。この関数ではedgeのデータフレーム（`Links`引数）とnodeのデータフレーム（`Nodes`引数）を別に指定することができます。\n\nこの関数では、ネットワークの接続（edgelistに当たるもの）を`Source`と`Target`引数に、edgeの太さを`Value`引数に、ノードに表示される名前を`NodeID`引数に、色などのグループ分けを`Group`引数に指定することで、比較的簡単に情報量の多いインタラクティブなグラフを作成することができます。\n\n```{r, filename=\"forceNetwork関数\"}\nforceNetwork(\n  Links = ns_D3$links,\n  Nodes = ns_D3$nodes,\n  Source = \"source\",\n  Target = \"target\",\n  NodeID = \"name\",\n  Group = \"group\",\n  fontSize = 30, zoom = TRUE\n)\n```\n\n#### dendroNetwork\n\n`dendroNetwork`関数はネットワークではなく、階層ありクラスタリングの結果を表示するための関数です。引数に取れるのは`hclust`関数の返り値（`hclust`クラスのオブジェクト）だけです。`dendroNetwork`関数を用いることで簡単にインタラクティブな階層ありクラスタリングの結果を表示することができます。\n\n```{r, filename=\"dendroNetwork関数\"}\n# hclustクラスのオブジェクトをプロットする\nhc <- hclust(dist(USArrests))\ndendroNetwork(hc)\n```\n\n#### その他の関数\n\n`networkD3`には上記の`forceNetwork`、`dendroNetwork`の他にも円形・階層型のグラフを表示することができる`radialNetwork`関数や`diagonalNetwork`関数、サンキー図を表示する`sankeyNetwork`関数も備わっています。以下の例ではjsonを`jsonline::fromJSON`関数でリストにして引数としていますが、`sankeyNetwork`関数は上記の`forceNetwork`と同様にedgeとnodeのデータフレームを引数に取ることもできます。\n\n```{r, filename=\"radialNetwork関数\"}\n# JSONのアドレスを読み込み\nURL <- \n  \"https://cdn.rawgit.com/christophergandrud/networkD3/master/JSONdata//flare.json\"\n\n# JSONをリストにする\nFlare <- jsonlite::fromJSON(URL, simplifyDataFrame = FALSE)\n\n# ネットワークを表示\nradialNetwork(List = Flare, opacity = 0.9)\n```\n\n```{r, filename=\"diagonalNetwork関数\"}\ndiagonalNetwork(List = Flare, opacity = 0.9)\n```\n\n```{r, filename=\"sankeyNetwork関数\"}\n# sankeyNetwork（サンキー図）\nURL <- \n  \"https://cdn.rawgit.com/christophergandrud/networkD3/master/JSONdata/energy.json\"\n\n# データはforceNetworkと同じように準備する（valueがlink側に必要）\nEnergy <- jsonlite::fromJSON(URL)\nEnergy$links |> head()\nEnergy$nodes |> head()\nsankeyNetwork(Links = Energy$links, Nodes = Energy$nodes, Source = \"source\",\n              Target = \"target\", Value = \"value\", NodeID = \"name\",\n              units = \"TWh\", fontSize = 12, nodeWidth = 30)\n```\n\n### visNetwork\n\n[visNetwork](https://datastorm-open.github.io/visNetwork/)[@visNetwork_bib]はD3.jsとは異なるJavascriptのビジュアライゼーションライブラリである[vis.js](https://visjs.org/)を用いたインタラクティブなネットワーク描画に関するパッケージです。上記の`NetworkD3`とは少し違う感じでネットワークが描画されるので、好みの方を用いるとよいでしょう。\n\n```{r, filename=\"ライブラリの読み込み\"}\npacman::p_load(visNetwork)\n```\n\n#### visNetwork関数\n\n`visNetwork`関数は、`NetworkD3`の`forceNetwork`関数に近い使い勝手の関数で、`forceNetwork`関数と同様にnodeとedgeのデータフレームを引数に取る関数です。ただし、`forceNetwork`関数が引数で色やnode名の指定を行うのに対し、`visNetwork`関数は引数に取ったデータフレームの列名に従ってネットワークを描画するという特徴があります。Rの他のグラフィックライブラリとは少し使い勝手が異なります。\n\nnodeに指定するデータフレームには`id`という名前の列が、edgeに指定するデータフレームには`from`と`to`という名前の列が必要です。この列名を読み取って、`visNetwork`はグラフを描画します。\n\n```{r, filename=\"visNetwork関数\"}\nd <- read.csv(\"./data/chapter33_nara_stations.csv\")\nvt <- read.csv(\"./data/chapter33_nara_stations_vertex_list.csv\")\n\ncolnames(d) <- c(\"from\", \"to\", \"linename\", \"company\")\ncolnames(vt) <- c(\"id\", \"lat\", \"lon\", \"linename\", \"company\")\n\nvisNetwork(nodes = vt, edges = d)\n```\n\n`visNetwork`関数にnodeとedgeを指定しただけでは、nodeをドラッグして位置を変えることができる程度で、nodeの情報などは表示されません。nodeをクリックしたときに表示される文字列は`title`という列名に指定します。また、nodeの色を変える場合には、nodeに指定するデータフレームに`color`という列が必要です。この`title`や`color`に指定された値・色を読み取って、`visNetwork`関数はnodeの情報を変更します。\n\n```{r, filename=\"nodeの情報を指定する\"}\nvt$title <- vt$id # nodeをクリックしたときに表示する文字\nvt$color <- if_else(vt$company == \"JR\", \"red\", \"blue\") # nodeの色\nvisNetwork(nodes = vt, edges = d)\n```\n\nまた、`visNetwork`ではパイプ演算子（`%>%`や`|>`）を用いてグラフの要素を追加することもできます。`visNodes`関数をパイプで繋ぐことでnodeの編集、`visOptions`をパイプで繋ぐことでオプション設定の変更を行うこともできます。\n\n```{r, filename=\"パイプ演算子でグラフを編集する\"}\nvisNetwork(nodes = vt, edges = d) |> \n  visNodes(shape = \"square\") |> \n  # クリックすると連結したノードがハイライトされる\n  visOptions(highlightNearest = TRUE) \n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"chapter33.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","lightbox":"auto","bibliography":["references.bib"],"editor":"source","theme":{"light":"united","dark":"cyborg"},"toc-expand":2,"code-block-bg":true,"code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}