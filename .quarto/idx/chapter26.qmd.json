{"title":"相関と回帰","markdown":{"headingText":"相関と回帰","containsRefs":false,"markdown":"\n**相関と回帰**は、共に数値である2変数の関係を表現するための方法で、統計では最も一般的な分析手法の一つです。\n\n2変数の関係では、どちらかが原因、もう一方が結果となっている場合と、どちらが原因でどちらが結果かわからない場合があります。例えば、ガソリンエンジンの排気量とガソリン消費量の関係を考えると、排気量が増えるからガソリン消費量が増えることはあっても、ガソリン消費量が多いから排気量が大きくなることはありません。つまり、排気量は原因で、ガソリン消費量は結果となります。一方、学生の数学の成績と国語の成績の関係の場合では、どちらが原因でどちらが結果ということはありません。\n\n原因と結果がはっきりしている場合には、2変量の関係を**回帰**することになります。回帰では、原因となる変数を**説明変数**（独立変数）、結果となる変数を**目的変数**（従属変数）と呼びます。上記の例では、エンジンの排気量は説明変数、ガソリンの消費量は目的変数となります。\n\n一方で原因と結果がはっきりしていない場合には、2数の関係を回帰せず、通常は**相関**を評価することとなります。\n\n回帰には、直線的な関係があるもの、直線的でないもの、データを繰り返し取得しているものなど、様々な場合に対応した手法が存在します。様々な回帰の手法について、以下の図にまとめています。自分が取り扱いたいデータに対応した手法を選択することが正確な回帰の結果を得るために重要となります。\n\n```{r, setup, include=FALSE, echo=FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE\n)\n\npacman::p_load(tidyverse)\n```\n\n![](./image/reg_category.png)\n\n## 相関\n\n**相関**は、どちらが原因でどちらが結果かはっきりしない2変量（共に数値）の関係を示すときに用いられる分析の方法です。通常は**相関係数（correlation coefficient）**を用いて評価します。相関係数は2変量の直線的な関係を評価するための数値で、絶対値が1に近いほど2変量の関係は直線的、0に近いほどランダム（2変量は**独立**）であることを示します。また、相関係数がプラスの場合には片方が増えるともう片方も増える（正の相関）、マイナスの場合には片方が増えるともう片方は減る（負の相関）関係にあることを示します。\n\nRで相関係数を計算する場合には、`cor`関数を用います。`cor`関数は同じ長さのベクター2つを引数に取り、その2つのベクター間の相関係数を計算する関数です。`cor`関数の引数にデータフレームを与えると、各行の値の総当りの相関係数（相関行列）を返します。\n\n`cor`関数は通常ピアソンの相関係数を計算する関数ですが、`method=\"kendall\"`や`method=\"spearman\"`を指定するとケンドールの相関係数やスピアマンの相関係数（いずれもノンパラメトリックな相関係数計算の手法）を計算することができます。2つの変数が正規分布しない場合や、直線的な関係にない時（例えば反比例するような場合）にはノンパラメトリックな方法を用いる方がよいときもあります。\n\nまた、相関係数が0ではないこと、つまり相関があることを検定するための関数が`cor.test`関数です。ただし、データ数が多ければ相関係数が0に近くても`cor.test`では統計的に有意となりやすくなります。\n\nまた、`GGally`パッケージ[@GGally_bib]の`ggpairs`関数を用いれば、相関係数、`cor.test`の結果、散布図を一度に確認することができます。\n\n```{r, filename=\"相関係数の計算\"}\n# 2変量の相関（ピアソンの相関係数）\ncor(iris$Sepal.Length, iris$Sepal.Width)\n\n# ケンドールの相関係数\ncor(iris$Sepal.Length, iris$Sepal.Width, method=\"kendall\")\n\n# スピアマンの相関係数\ncor(iris$Sepal.Length, iris$Sepal.Width, method=\"spearman\")\n\n# データフレームを引数にした場合の相関行列の計算\ncor(iris[, 1:4])\n\n# 相関係数が0ではないことに関する検定\ncor.test(iris$Sepal.Length, iris$Sepal.Width)\n\n# GGally::ggpairsで相関係数等を一度に表示する\nGGally::ggpairs(iris[, 1:4])\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## 相関係数の大きさと相関の強さ\n\n相関係数の絶対値が1に近ければ相関は強くなるのですが、どの程度の数値であれば相関があると言えるのか、という点についてははっきりしていません。教科書や資料を読むと、0.5ぐらいだと相関があるとしているものもありますし、0.3でも相関として意味があると書いている場合もあります。以下に例として、相関係数が異なるデータのグラフを示します。グラフから、相関係数がどれぐらいならどの程度相関があるのか、イメージして頂ければと思います。\n\n```{r, echo=FALSE, fig.width=10}\nset.seed(0)\nx = runif(100, -1, 1)\ny1 = x\ny2 = x + rnorm(100, 0, 0.5)\ny3 = x + rnorm(100, 0, 0.8)\ny4 = x + rnorm(100, 0, 3)\ny5 = x + rnorm(100, 0, 10)\ny6 = -x\ny7 = -x + rnorm(100, 0, 0.5)\ny8 = -x + rnorm(100, 0, 0.8)\ny9 = -x + rnorm(100, 0, 3)\ny10 = -x + rnorm(100, 0, 10)\n\nd <- data.frame(\n  x = x, \n  y = c(y1, y2, y3, y4, y5, y6, y7, y8, y9, y10),\n  yl = rep(c(\"y1\", \"y2\", \"y3\", \"y4\", \"y5\", \"y6\", \"y7\", \"y8\", \"y9\", \"y10\"), rep(100, 10)) |> factor(levels=c(\"y1\", \"y2\", \"y3\", \"y4\", \"y5\", \"y6\", \"y7\", \"y8\", \"y9\", \"y10\"))\n)\n\ncor_v <- d |> group_by(yl) |> summarise(v_col=cor(x, y)) |> _$v_col |> round(digits=3)\n\ncor_v <- paste0(\"r = \", cor_v)\n\nd$colv <- rep(cor_v, rep(100, 10)) |> factor(levels=cor_v)\n\nd |> ggplot(aes(x=x, y=y, color=yl))+\n  geom_point(size=1)+\n  facet_wrap(~colv, nrow=2, scales=\"free_y\")+\n  theme(legend.position=\"none\")\n```\n\nまた、2変量の関係が直線的でない場合には、何らかの関係が2変量間にあったとしても相関係数は小さくなります。相関係数を調べるだけでなく、グラフで2変量の関係を確認することが重要です。\n\n:::\n\n## 線形回帰\n\n**回帰**は目的変数も説明変数も数値である場合に、目的変数と説明変数の関係を線形で示す統計解析です。回帰は、**目的変数と説明変数の関係を説明**するために用いられるものですが、回帰式を用いて**説明変数を得た時に目的変数を予測**する、予測的なモデルとしても用いることができます。\n\n前者、説明的な回帰の例としては、作物に与える窒素肥料の量が作物の収率にどの程度影響を及ぼすのか調べるような場合が当てはまります。後者、予測的な回帰の例としては、検量線を引いておいて、吸光度から物質の濃度を計算するような場合が当てはまります。回帰の種類によっては、予測的なモデルが**機械学習**として取り扱われることもあります。\n\n説明変数が一つである場合、**単回帰**と呼ばれる線形回帰を行うことになります。**目的変数が正規分布する場合、回帰の結果は直線**となります。\n\n線形回帰では、**最小二乗法**と呼ばれる手法を用いて回帰を行います。最小二乗法は、直線と各データの点までのy軸方向の距離の2乗の和（2乗誤差）を最小にする直線を求める方法です。図で表すと、以下のグラフの赤線の長さを2乗して合計し、この合計を最小にする線の数式を求めるが最小二乗法です。この最小二乗法は微分を使えば比較的簡単に解けるため、昔からよく用いられてきた方法です。y軸方向（目的変数）の誤差のみを考慮して結果を求めるため、説明変数と目的変数を逆にしてしまうと計算結果が変わります。\n\n:::{.callout-tip collapse=\"true\"}\n\n## ggplot2のコード\n\n```{r, eval=FALSE}\nset.seed(0)\nx <- rnorm(50, mean = 10, sd = 2)\ny <- 0.5 * x + 3 + rnorm(50)\n\nlmresult <- lm(y ~ x)\npred <- predict(lmresult)\n\nnew_d <- data.frame(x, y, pred)\n\nnew_d |> \n  ggplot(aes(x = x, y = y, ymax = pred, ymin = y))+\n  geom_linerange(linewidth = 1, color = \"#F8766D\")+\n  geom_point(size = 3, color = \"#00BFC4\")+\n  geom_abline(intercept = lmresult$coefficients[1], slope = lmresult$coefficients[2], color = \"black\", linewidth = 0.25)+\n  labs(title = \"最小二乗法のイメージ\", caption = \"青点：データの点、黒線：線形回帰の線、赤線：最小二乗法で最小とする長さ\")\n```\n\n:::\n\n```{r, echo=FALSE}\nset.seed(0)\nx <- rnorm(50, mean = 10, sd = 2)\ny <- 0.5 * x + 3 + rnorm(50)\n\nlmresult <- lm(y ~ x)\npred <- predict(lmresult)\n\nnew_d <- data.frame(x, y, pred)\n\nnew_d |> \n  ggplot(aes(x = x, y = y, ymax = pred, ymin = y))+\n  geom_linerange(linewidth = 1, color = \"#F8766D\")+\n  geom_point(size = 3, color = \"#00BFC4\")+\n  geom_abline(intercept = lmresult$coefficients[1], slope = lmresult$coefficients[2], color = \"black\", linewidth = 0.25)+\n  labs(title = \"最小二乗法のイメージ\", caption = \"青点：データの点、黒線：線形回帰の線、赤線：最小二乗法で最小とする長さ\")\n```\n\nRで線形回帰を行う場合には、`lm`関数を用います。`lm`関数の引数はformulaで、`目的変数~説明変数`という形で、チルダ（`~`）の前に結果（目的変数）のデータ、チルダの後に原因（説明変数）のデータをつないで用います。目的変数と説明変数は1対となるため、目的変数と説明変数に指定する変数の長さは同じである必要があります。`lm`関数の結果として、coefficients（係数、パラメータ）が2つ求まります。1つはIntercept、つまり切片で、もう一つは説明変数に対する傾きです。下の例では、$Sepal.Length = 6.5262 - 0.2234 \\cdot Sepal.Width$という線形で回帰の式が表されることを示しています。\n\n```{r, filename=\"線形回帰（単回帰）\"}\nlm(iris$Sepal.Length ~ iris$Sepal.Width)\n```\n\n### lmオブジェクトの取り扱い\n\n線形回帰の結果を変数に代入すると、lmクラスの変数となります。lmクラスのオブジェクトからは、`$coefficients`で切片と傾きを取り出すことができます。また、`summary`関数の引数とすると、回帰の詳細が表示されます。\n\n`summary`関数で示される回帰の詳細には、coefficientsとして、分散分析表のようなものが表示されます。この表のうち、Estimateは切片と傾きの推定値、Std. Errorは切片と傾きの標準誤差、t valueとPr(>|t|)はt検定の結果を示しています。このt検定の結果は、coefficients（切片と傾き）が0と有意に異なっているかを示しています。以下の例では、Interceptは0と有意に異なるのに対して、iris\\$Sepal.Width、つまり傾きは0とは有意に異ならないことを示しています。つまり、`Sepal.Width`は目的変数である`Sepal.Length`にはほとんど影響がないことを表しています。\n\nMultiple R squaredは**決定係数**と呼ばれるもので、線形性の高さを示します。決定係数（R^2^）は相関係数（R）の2乗として計算されるもので、0~1の値を取ります。1に近いほど線形性が高く、0に近いほどあまり線形性がみられないという結果となります。Adjusted R squaredは調整済み決定係数で、説明変数の数でペナルティを付けて計算した決定係数です。\n\n```{r, filename=\"lmクラスの取り扱い\"}\nlmresult <- lm(iris$Sepal.Length ~ iris$Sepal.Width) # 変数にlmの結果を代入\nclass(lmresult) # lmクラスのオブジェクト\n\nlmresult$coefficients # 切片と傾きを取り出す\n\nsummary(lmresult) # 線形回帰の詳細（内容の詳細は?summary.lmで調べることができる）\n```\n\n### predict関数\n\n`predict`関数は、lmクラスのオブジェクトを引数に取り、x軸の値を与えた時のy軸側の直線上の値やyの値の信頼区間を計算する関数です。\n\n`predict`関数の第一引数はlmクラスのオブジェクトで、第二引数（`newdata`）に、予測したいx軸上の値をデータフレームで設定します。`interval`という引数には、`\"none\"`、`\"confidence\"`、`\"prediction\"`の3つのうちどれかを設定します。`\"none\"`の場合には`newdata`で与えたxを与えた場合の直線上のyの値のみを返します。`\"confidence\"`の場合は信頼区間、`\"prediction\"`の場合は個々の値に関する予測区間が表示されます。区間の幅は`levels`引数で指定することができます。`levels`引数のデフォルト値は0.95なので、`levels`を設定しない場合には信頼区間などの区間は95％区間として求まります。\n\n```{r, filename=\"データの準備\"}\nset.seed(0)\nx <- rnorm(15) # xは平均0、標準偏差1の正規乱数\ny <- x + rnorm(15) # yはxに正規乱数を足したもの\nplot(x, y, xlim = c(-1.75, 2.5), ylim = c(-2, 2.5))\npar(new = T)\nplot(\\(x){x}, xlim = c(-1.75, 2.5), ylim = c(-2, 2.5), xlab = \"\", ylab = \"\")\n```\n\n```{r, filename=\"predict関数の利用\"}\nlmr <- lm(y ~ x)\nnew <- data.frame(x = 1:5) # x=1～5のときの予測値を求める\n\n# fitが直線上の値、lwr、uprがそれぞれ信頼区間の2.5％、97.5％分位値\npredict(lmr, newdata = new, interval = \"confidence\", levels = 0.95)\n```\n\n```{r, filename=\"95%信頼区間を加えた回帰のグラフ\"}\nggplot()+\n  geom_point(data = data.frame(x, y), aes(x = x, y = y, size = 2)) +\n  geom_ribbon(\n    data = \n      data.frame(\n        x = seq(-2, 2.5, by = 0.1), \n        predict(lmr, newdata = data.frame(x = seq(-2, 2.5, by = 0.1)), interval = \"confidence\", levels = 0.95)),\n    aes(x = x, y = fit, ymax = upr, ymin = lwr, color = factor(1), fill = factor(1), alpha = 0.2)\n    )\n```\n\n```{r, filename=\"切片と傾きの95％信頼区間\"}\nconfint(lmr)\n```\n\n\n## 重回帰\n\n**重回帰**とは、1つの目的変数に対して、2つ以上の説明変数がある場合の回帰のことです。Rでは重回帰も単回帰と同じく`lm`関数で計算することができます。重回帰は二元分散分析と同様に、説明変数を`+`または`*`でつないでformulaを設定します。`+`でつないだ場合には交互作用なし、`*`でつないだ場合には交互作用ありの重回帰となります。ただし、重回帰の交互作用はその意味の理解が難しいため、意味をよく考えた上で交互作用の項を追加するかどうか決める方がよいでしょう。\n\n```{r, filename=\"lm関数で重回帰\"}\n# 交互作用なしモデル\n# Sepal.Length = 2.2491 + 0.5955 * Sepal.Width + 0.4719 * Petal.Length が結果となる\nlm(iris$Sepal.Length ~ iris$Sepal.Width + iris$Petal.Length)\n\n# 交互作用ありモデル\n# Sepal.Length = 1.4044 + 0.8500 * Sepal.Width + \n# 0.7185 * Petal.Length - 0.07701 * Sepal.Width * Petal.Length\nlm(iris$Sepal.Length ~ iris$Sepal.Width * iris$Petal.Length)\n```\n\n## 一般線形モデル\n\n**一般線形モデル**は、1つの目的変数に対して、数値や因子からなる複数の説明変数がある場合の回帰のことです。重回帰や共分散分析の拡張だと考えるとよいかと思います。Rでは一般線形モデルの計算も`lm`関数を用いて行います。一般線形モデルも重回帰とほぼ同じで、説明変数同士を`+`か`*`でつなぐだけです。\n\n一般線形モデルでは説明変数として非常にたくさんの数値や因子を登録できますが、すべての説明変数に対して交互作用ありにしてしまうと交互作用項が非常に多くなり、理解が難しくなるので、本当に必要がある部分にだけ交互作用を入れる方がよいでしょう。\n\n```{r, filename=\"一般線形モデル\"}\n# 一般線形モデル\n# 結果は Sepal.Length = 2.39039 + 0.43222 * Sepal.Width + 0.77563 * Petal.Length で、\n# 種がsetosaなら上記の線形式のまま、versicolorなら-0.95581、virginicaなら-1.39410を線形式に足す形となる。\nlm(iris$Sepal.Length ~ iris$Sepal.Width + iris$Petal.Length + iris$Species) |> summary()\n```\n\n```{r, filename=\"交互作用ありの一般線形モデル\"}\n# 一般線形モデル（交互作用あり）：たくさんの交互作用項が出てくる\nlm(iris$Sepal.Length ~ iris$Sepal.Width * iris$Petal.Length * iris$Species) |> summary()\n```\n\n## 一般化線形モデル\n\nここまでは目的変数が正規分布することを仮定した回帰でしたが、目的変数が正規分布しない場合、例えばポアソン分布や二項分布するときには、分布が上下非対称になります。ですので、最小二乗法を用いた直線での回帰は適していません。\n\n以下に目的変数が二項分布とポアソン分布するデータの例を示します。いずれも直線で回帰してしまうと、データの特徴を捉えていないことがわかると思います。\n\n::: {.panel-tabset}\n\n## 二項分布\n\n二項分布を回帰する場合の典型的な例としては、医薬品の投与量（説明変数）に対して病気が治る確率（目的変数、回復:1と未回復:0の2値）を回帰する場合などが挙げられます。\n\n```{r}\nset.seed(5)\nlogistic <- \\(x, sex){1 / (1 + exp(-3 * x + 150 + 10 * sex)) + rbeta(length(x), 0.5, 1.5)}\nx <- 1:100 ; sex <- rbinom(100, 1, 0.5)\nbinom_d <- data.frame(x, y = if_else(logistic(x, sex) > 0.5, 1, 0), sex = factor(sex))\nbinom_d |> ggplot(aes(x = x, y = y, color = sex)) + geom_point()\n```\n\n## 2項分布を直線で回帰\n\n```{r, warnings=FALSE, message=FALSE}\n(binom_d |> \n  ggplot(aes(x = x, y = y, color = sex)) + \n  geom_point() + geom_quantile(quantiles = 0.5)) |> \n  print() |> \n  suppressWarnings()\n```\n\n:::\n\n::: {.panel-tabset}\n\n## ポアソン分布\n\nポアソン分布を回帰する典型的な例としては、植物の生育サイズ（説明変数）と種子の数（目的変数、正の整数のみを取る）の関係などが挙げられます。\n\n```{r}\nx <- 1:10\ny <- c(replicate(10, rpois(10, exp(x / 3 + 0.25))), replicate(10, rpois(10, exp(x / 3))))\npois_d <- data.frame(x, y = as.vector(y), fertilizer = factor(rep(c(1, 0), c(100, 100))))\npois_d |> ggplot(aes(x = x, y = y, color = fertilizer)) + geom_jitter(width = 0.1)\n```\n\n## ポアソン分布を直線回帰\n\n```{r, warnings=FALSE, message=FALSE}\npois_d |> \n  ggplot(aes(x = x, y = y, color = fertilizer)) + \n  geom_jitter(width = 0.1) + \n  geom_quantile(quantiles = 0.5)\n```\n\n:::\n\n直線での回帰ができない場合には、最小二乗法を用いることができないため、別の方法を用いて回帰を行います。この回帰の際に用いるのが**最尤法（さいゆうほう）**と呼ばれる方法で、**尤度（ゆうど）**というものを最大にするような傾きや切片を選択する方法です。\n\n尤度は尤（もっと）もらしさの指標で、傾きや切片がある数値の時に、どの程度その傾きや切片の値が尤もらしいかを評価するためのものです。最も尤度が高い、つまり最も尤もらしい傾きや切片の値（**最尤推定値**）を、回帰における傾きや切片に当たるもの（パラメータ）として求めます。\n\n:::{.callout-tip collapse=\"true\"}\n\n## 尤度と最尤法\n\n尤度についてもう少し詳しく説明します。尤度の説明の例として正規分布を挙げます。以下は[24章](./chapter24.html)で示した正規分布の確率密度関数です。\n\n$$ Norm(x, \\mu, \\sigma)=\\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\cdot \\exp \\left( \\frac{(x-\\mu)^2}{2\\sigma^2} \\right) $$\n\nこの数式は間違ってはいないのですが、以下のように書く方が正しい表現です。\n\n$$ Norm(x | \\mu, \\sigma)=\\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\cdot \\exp \\left( \\frac{(x-\\mu)^2}{2\\sigma^2} \\right) $$\n\n変わっているところは、始めの関数のxとμの間がコンマではなく、縦線（\\|）になっているところです。この縦線の左は自由な値を取ることができる変数（未知の値、上の式ではx）、縦線の右はあらかじめわかっている数値（既知の値、上の式ではμとσ）を表します。ですので、上の式の意味は、平均値（μ）と標準偏差（σ）がわかっているときの、xという値が得られる確率（密度）を計算している、ということを意味しています。\n\nしかし、データが取れた時に、あらかじめ平均値や標準偏差がわかっていることはありません。ですので、普通はデータxが取れた時には、xから平均値μや標準偏差σを求める方に興味があるわけです。つまり、上の式では既知のパラメータ（x）と未知のパラメータ（μとσ）の関係が逆になっています。\n\nですので、既知と未知のパラメータを逆にしてしまえば、上の式はデータが取れた時に平均値や標準偏差が得られる確率にできるはずです。\n\n$$ L(\\mu, \\sigma| x)=\\frac{1}{\\sqrt{2\\pi \\sigma^2}} \\cdot \\exp \\left( \\frac{(x-\\mu)^2}{2\\sigma^2} \\right) $$\n\nこの、xというデータが取れた時に、特定の平均値μや標準偏差σが得られる確率（$L(\\mu, \\sigma| x)$）のことを尤度と呼びます。確率密度関数との差は\\|の左右が逆になっているだけです。ただし、通常データは複数取れる（x~1~～x~n~）ので、μとσが得られる確率は以下のように、データの数だけ尤度を掛け算することで計算できます。\n\n$$L(\\mu, \\sigma| x_{1}, x_{2}, \\cdots x_{n})=L(\\mu, \\sigma| x_{1}) \\cdot L(\\mu, \\sigma| x_{2}) \\cdots L(\\mu, \\sigma| x_{n})=\\prod_{i=1}^{n}L(\\mu, \\sigma| x_{i})$$\n\n最後のΠは総乗の記号で、i=1からnまで掛け算するという意味の式です。掛け算のままでは値が非常に小さくなり、取り扱いが難しくなるので、対数変換し、対数尤度というものを取り扱うのが一般的です。対数を取ることで、データごとの対数尤度の足し算として尤度を取り扱えるようになり、計算しやすくなります。\n\n$$logL(\\mu, \\sigma| x_{1}, x_{2}, \\cdots x_{n})=\\sum_{i=1}^{n}logL(\\mu, \\sigma| x_{i})$$\n\nこの対数尤度を最大とするμとσ（パラメータ）を求める手法のことを最尤法と呼びます。データが正規分布しているときにはこの最尤法の計算は微分を用いて計算でき、μとσの最尤推定値はそれぞれ平均値と標準偏差になります。\n\n:::\n\n最尤法を用いて、目的変数の分布に従った回帰を行う手法のことを、**一般化線形モデル（generalized linear model、GLM）**と呼びます。一般化線形モデルでは、目的変数の分布（Rではfamilyと呼ばれる）によって異なる、**リンク関数**というものを用いて回帰を計算します。正規分布のリンク関数は直線（identity）で、通常の線形回帰と一致します。\n\n:::{.callout-tip collapse=\"true\"}\n\n## リンク関数\n\n上に示した通り、目的変数が2項分布やポアソン分布する場合には、データを直線で回帰してしまうと実際の結果を正しく反映しない回帰となってしまいます。例えば、二項分布するデータでは0か1かしか取らない結果なのに、直線はその範囲を平気で超えていきます。ポアソン分布はマイナスの値を取れないのに、直線で回帰すると直線はマイナスの値を取ってしまいます。\n\nこのように、目的変数が正規分布しない場合、直線で回帰すると誤った結果を導いてしまいます。このような問題を解決するためのものが、**リンク関数**です。リンク関数は、目的変数の変換に関わる関数で、その変換結果を直線で回帰することで目的変数を適切に表現することができる関数です。目的変数が正規分布する場合には、目的変数をそのまま直線で回帰するため、リンク関数は**identity**、つまりそのままになります。\n\n二項分布では、**オッズ比**（$\\frac{p}{1-p}$、ベルヌーイ試行の成功確率pと失敗確率1-pの比、pが目的変数）の対数を以下のように線形で回帰します。\n\n$$log(\\frac{p}{1-p})=ax+b$$\n\n上の式のオッズ比の対数のことを**ロジット**（logit）と呼びます。この時、pは確率ですので、0～1の値を取ります。上の式をpについて解くと、以下の式になります。\n\n$$p=\\frac{1}{1+\\exp(-(ax+b))}$$\n\nこのpの式を**ロジスティック式**と呼びます。ロジスティック式はpが0～1の値を取り、xは-∞～+∞の値を取ります。この関数は個体群密度のモデル化にも用いられる関数で、二項分布する結果を回帰するのに適しています。目的変数が二項分布の場合はこのロジスティック式で回帰し、二項分布の場合のリンク関数はロジットになります。\n\n目的変数がポアソン分布の場合には、値の対数を以下のように線形で回帰します。\n\n$$log(y)=ax+b$$\n\nですので、目的変数yは以下のように指数関数で回帰することになります。\n\n$$y=\\exp(ax+b)$$\n\nですので、目的変数がポアソン分布する場合には指数関数で回帰し、リンク関数は対数（log）になります。\n\nこの他にも、目的変数の代表値と分散が一致しないカウントデータ（疑似ポアソン分布）や過分散の二項分布（疑似二項分布）などにもそれぞれ分布とリンク関数が設定されています。Rではこの目的変数の分布とリンク関数のセットのことをfamilyと呼びます。familyで指定されている目的変数の分布、Rのデフォルトのリンク関数、回帰する関数の種類を以下の表に示します。\n\n```{r, echo=FALSE}\ndata.frame(\n  `目的変数の分布` = c(\"二項分布\", \"正規分布\", \"ガンマ分布\", \"逆ガウス分布\", \"ポアソン分布\", \"疑似二項分布\", \"疑似ポアソン分布\"),\n  `リンク関数` = c(\"logit\", \"identity\", \"inverse\", \"1/mu^{2}\", \"log\", \"logit\", \"log\"),\n  `回帰する関数` = c(\"ロジスティック\", \"直線\", \"反比例\", \"(1/(ax+b))^0.5\", \"指数\", \"ロジスティック\", \"指数\")\n) |> \n  knitr::kable()\n```\n\nリンク関数にはデフォルトのものではなく、自分で選択した関数を別途設定することもできます。\n\n:::\n\n### 目的変数が正規分布の場合\n\nRでは、一般化線形モデルの計算を`glm`関数で行います。`glm`関数の使い方は`lm`関数とほぼ同じで、第一引数に`目的変数~説明変数`の形のformulaを取ります。データフレームのデータを利用する場合には、`data`引数にデータフレームを指定します。また、`glm`では、目的変数の分布を`family`引数に指定します。目的変数が正規分布する場合には、以下のように`family=\"gaussian\"`と指定します。`family=\"gaussian\"`の場合、`glm`での回帰の結果は`lm`での回帰の結果と同一になります。\n\n```{r, filename=\"glm関数：正規分布\"}\n## 一般化線形モデル\n# 正規分布（identityをリンク関数とする）\n# lmと同じなので、結果は Sepal.Length = 6.5262 - 0.2234 * Sepal.Width となる\nglm(Sepal.Length ~ Sepal.Width, data = iris, family = \"gaussian\")\n```\n\n`glm`関数の返り値を`summary`関数の引数とすることで、`lm`関数と同様に詳細な計算結果を得ることができます。Estimateが係数であることは`lm`関数と同じです。\n\n```{r, filename=\"glm関数：summaryで詳細を調べる\"}\nglm(Sepal.Length ~ Sepal.Width, data = iris, family = \"gaussian\") |> summary()\n```\n\n### 目的変数が二項分布の場合\n\n目的変数が二項分布の場合には、`glm`の引数に`family=\"binomial\"`（二項分布）を指定します。`family`に二項分布を指定すると、リンク関数はロジットとなり、ロジスティック式でデータを回帰することになります。ロジスティック式が表しているのは確率になるため、説明変数に応じてベルヌーイ試行の確率がどのように変化していくのかを示すような回帰を行うことになります。\n\n以下の例では、回帰の結果はcoefficientsで示されている通り、以下の数式となります。\n\n$$ log(\\frac{p}{1-p}) = -4.34896+0.09368x $$\n\n上式を変換し、ロジスティック関数にしたものが以下の式です。\n\n$$ y = \\frac{1}{1+exp(-(-4.34896+0.09368x))} $$\n\n```{r, filename=\"glm関数：二項分布\"}\n# 回帰するデータ\nplot(binom_d$x, binom_d$y, xlim = c(0, 100), ylim = c(0, 1))\n\n# 二項分布（logitをリンク関数とする）\nglm(y ~ x, data = binom_d, family = \"binomial\")\n\n# 回帰の結果をプロットする\npar(new = T)\nplot(\\(x)(1/(1 + exp(-(-4.34896 + 0.09368 * x)))), xlim = c(0, 100), ylim = c(0, 1), xlab = \"\", ylab = \"\")\n```\n\n```{r, echo=FALSE}\nx <- 1:10\nprobs <- 1 / (1 + exp(-(x - 5)))\ny <- numeric(10)\n\nfor(i in 1:10){\n  y[i] <- rbinom(10, 1, prob = probs[i]) |> sum()\n}\n\nz <- 10 - y\n\ndbn <- data.frame(x, y, z)\n```\n\n2項分布の成功、失敗回数がわかっている時には、成功回数の列と失敗回数の列を行列で目的変数として指定することもできます。行列を目的変数として指定する場合には、formulaのチルダ（`~`）の左側に、`cbind(成功回数, 失敗回数)`の形で行列として指定します。\n\n```{r, filename=\"cbindで二項分布の成功・失敗を指定\"}\n# yはベルヌーイ試行の成功数、zは失敗数\nhead(dbn)\n\n# 成功・失敗をmatrixで指定する\nglm(cbind(y, z) ~ x, family = \"binomial\")\n\n# 回帰をグラフで表示\ndbn |> \n  ggplot(aes(x = x, y = y / 10))+\n  geom_point()+\n  geom_function(fun=\\(x){1 / (1 + exp(-(-5.025 + 1.119 * x)))})\n```\n\n#### 説明変数を増やす\n\n`lm`関数と同様に、`formula`の右辺に`+`で説明変数を繋ぐことで、重回帰・一般線形モデルのように説明変数を増やすこともできます。\n\n```{r, filename=\"glm関数：二項分布で説明変数を増やす\"}\nhead(binom_d)\n\n# 二項分布（logitをリンク関数とする）\nglm(y ~ x + sex, data = binom_d, family = \"binomial\")\n\n# 回帰の結果をプロットする\nbinom_d |> \n  ggplot(aes(x = x, y = y, color = sex))+\n  geom_point()+\n  geom_function(fun = \\(x){1 / (1 + exp(-(-4.20991 + 0.09672 * x)))}, color = \"blue\") +\n  geom_function(fun = \\(x){1 / (1 + exp(-(-4.20991  - 0.52864 + 0.09672 * x)))}, color = \"red\")\n```\n\n上の例では、計算結果はcoefficientsから、以下の式となります。sexは0か1ですので、0の時は-0.52864×sexの部分が0に、1の時は―0.52864となります。\n\n$$ y = \\frac{1}{1+exp(-(-4.20991 + 0.09672x - 0.52864 \\cdot sex))} $$\n\n\n\n### 目的変数がポアソン分布の場合\n\n目的変数がポアソン分布する場合には、`glm`関数の`family`引数を、`family = \"poisson\"`の形で指定します。\n\n下の例では、coefficientsの計算結果から、回帰の式は以下となります。\n\n$$ log(y) = 0.1510 + 0.3331x $$\n\n指数関数に変換すると、以下の式となります。\n\n$$ y = exp(0.1510 + 0.3331x) $$\n\n```{r, filename=\"glm関数：ポアソン分布\"}\nhead(pois_d)\n\nglm(y ~ x, data = pois_d, family = \"poisson\")\n\nplot(pois_d$x, pois_d$y, xlim = c(0, 10), ylim = c(0, 50))\npar(new = T)\nplot(\\(x){exp(0.1510 + 0.3331 * x)}, xlim = c(0, 10), ylim = c(0, 50), xlab = \"\", ylab = \"\")\n```\n\n目的変数がポアソン分布の場合にも、説明変数を`+`でつなぐことで、重回帰のように説明変数を増やすことができます。\n\n```{r, filename=\"glm関数：ポアソン分布で説明変数を増やす\"}\nglm(y ~ x + fertilizer, data = pois_d, family = \"poisson\")\n\npois_d |> \n  ggplot(aes(x = x, y = y, color = fertilizer))+\n  geom_point()+\n  geom_function(fun = \\(x){exp(0.03425 + 0.33310 * x)}, color = \"red\")+\n  geom_function(fun = \\(x){exp(0.03425 + 0.22131 + 0.33310 * x)}, color = \"blue\")\n```\n\n上の例では、計算結果はcoefficientsから、以下の式となります。fertilizerは0か1ですので、0の時は0.22131×fertilizerの部分が0に、1の時は―0.22131となります。\n\n$$ y = exp(0.03425 + 0.33310x + 0.22131 \\cdot fertilizer)$$\n\n## 線形混合モデル\n\nデータに繰り返しの測定がある場合、例えば、実験で同じ個体を数日間おきに調べ、データを取るような場合には、個体間のばらつきが大きくて正しい線形回帰を得るのが難しい場合があります。また、線形回帰ではデータの各点は独立の（関連性のない）事象として扱われますが、繰り返しの測定がある場合、例えば同じ個体から繰り返し得られたデータは明確に独立ではありません。\n\nこのように、繰り返しがある場合、個体間に正規分布に従うばらつきがあると仮定して回帰を行う方法が、**線形混合モデル（Linear Mixed Model（LMM）またはMixed Model for Repeated Measures（MMRM））**です。線形混合モデルは、切片のみにばらつきがある場合（ランダム切片、下図1参照）と、切片にも傾きにもばらつきがある場合（ランダム傾き）の2つに対応し、それぞれ直線で回帰を計算します。線形混合モデルを用いることで、ランダム切片やランダム傾き（合わせて**ランダム効果**）を回帰の結果（**固定効果**）と分けて評価することで、回帰結果をうまく評価することができます。\n\n![図1：ランダム切片とランダム傾き](./image/randomeffects.jpg)\n\nRで線形混合モデルを計算する場合には、[`nlme`パッケージ](https://cran.r-project.org/web/packages/nlme/index.html) [@nlme_bib; @nlme_book]、[`lme4`パッケージ](https://cran.r-project.org/web/packages/lme4/index.html) [@lme4_bib]、[`lmerTest`パッケージ](https://cran.r-project.org/web/packages/lmerTest/index.html) [@lmerTest_bib]のいずれかを使うのが一般的です。`lme4`は`nlme`の改良版、`lmerTest`は`lme4`に分散分析の計算方法を追加したパッケージです。どれを用いても大きな差はありませんが、`lme4`と`lmerTest`が使われているのをよく見る印象があります。\n\n以下に線形混合モデルで解析するデータとして、`lme4`パッケージに登録されている`sleepstudy`を用います。この`sleepstudy`は睡眠をとっていない被験者の反応時間を毎日取得したデータです。睡眠をとらない期間が延びると、反応時間が延びていく様子が記録されていますが、被験者ごとに傾きも切片も異なる、ランダム切片＋ランダム傾きを持つように見えるデータとなっています。\n\n```{r, filename=\"sleepstudyのデータ\"}\n# 線形混合モデルのデータ\npacman::p_load(lmerTest)\ndata(\"sleepstudy\", package = \"lme4\")\nhead(sleepstudy)\n\n# DaysとReactionの関係を調べる\nggplot(sleepstudy, aes(x = Days, y = Reaction, color = Subject, alpha = 0.5)) +\n  geom_point(size = 2) + \n  theme(legend.position = \"none\") +\n  geom_line()\n```\n\n### ランダム切片モデル\n\nRで線形混合モデルの計算を行う場合には、`lmerTest`パッケージ（もしくは`lme4`パッケージ）の`lmer`関数を用います。`lmer`関数の使い方は`lm`関数とほぼ同じですが、ランダム切片とランダム傾きの項をformulaで表す必要があります。formulaは`目的変数+説明変数+(ランダム傾き|ランダム切片)`という形で設定し、縦線（`|`）の左にランダム傾き、右にランダム切片の項を入力します。ランダム切片のみの場合には`目的変数+説明変数+(1|ランダム切片)`という形で、ランダム傾きの部分に1を入れます。計算結果はFixed effects（固定効果）の部分で示されており、以下の式となります。Random effectsで示されている部分がランダム切片（ランダム効果）で、Subject間の切片の分散が示されています。\n\n$$Reaction = 251.4051 + 10.4673 \\cdot Days$$\n\n```{r, filename=\"lmer関数でランダム切片モデルを計算\"}\nlmer_sleepstudy <- lmer(Reaction ~ Days + (1 | Subject), data = sleepstudy)\nlmer_sleepstudy %>% summary()\n```\n\n### ランダム傾きモデル\n\nランダム傾きの項には、傾きを生じる軸（x軸）の値を入力します。上の`sleepstudy`の場合では、`Days`の方向にランダムな傾きが生じるため、ランダム傾きの項に`Days`を指定して計算します。演算結果は以下の式となります。ほぼランダム切片モデルと同じになっています。\n\n$$Reaction = 251.405 + 10.467 \\cdot Days$$\n\n```{r, filename=\"lmer関数でランダム傾きモデルを計算\"}\nlmer(Reaction ~ Days + (Days | Subject), sleepstudy) %>% summary()\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## lmer関数の返り値の取り扱い方\n\n`lmerTest::lmer`関数の返り値はS4オブジェクトなので、`@`や`$`を用いて計算結果にアクセスすることができます。また、関数を用いて計算結果にアクセスすることもできます。\n\n```{r}\nresult_lmer <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)\nresult_lmer@sigma # 残差の標準偏差\n\nanova(result_lmer, type = \"I\") # type Iの分散分析結果\n\ncoef(result_lmer) # 個々の被験者の傾きと切片\n```\n\n:::\n\n## 一般化線形混合モデル\n\n線形混合モデルを目的変数が正規分布以外の場合に拡張したものが、**一般化線形混合モデル（Generalized Linear Mixed Model、GLMM）**です。Rでは、GLMMを`lme4`パッケージの`glmer`関数で計算することができます。`glmer`関数は`lmer`関数と同じく`lme4`パッケージの関数ですので、`glmer`関数の使い方は基本的に`lmer`関数と同じです。\n\nGLMMの例として、`lme4`パッケージに含まれる`cbpp`（[牛肺疫](https://ja.wikipedia.org/wiki/%E7%89%9B%E8%82%BA%E7%96%AB)にかかった牛のデータ）での計算例を以下に示します。\n\n```{r, filename=\"cbppの内容\"}\n# cbpp（contagious bovine pleuropneumonia、牛肺疫）に関するデータ\ndata(cbpp, package = \"lme4\") \n\n# herdは牛の群、incidenceは牛肺疫への罹患数、sizeは群内の牛の数、periodは観察時期\nhead(cbpp) \n\ncbpp |> \n  ggplot(aes(x = period |> as.character() |> as.numeric(), y = incidence / size, color = herd)) +\n  geom_point() +\n  geom_line()\n```\n\n`glmer`の引数の指定は、`glm`と`lmer`を合わせたような形になります。ですので、`family`引数に目的変数の分布を指定し、ランダム切片、ランダム傾きは、formulaに`(ランダム傾き|ランダム切片)`の形で指定します。演算結果はFixed effectsに示された通り、以下の式となります。\n\n$$ incidance = \\frac{1}{1 + exp(-(-0.9323 - 0.5592 \\cdot period))}$$\n\n```{r, filename=\"glmer関数で一般化線形混合モデルを計算\"}\ncbind(cbpp$incidence, cbpp$size - cbpp$incidence) |> head() # 左が牛肺疫に罹患した牛、右は罹患していない牛\n\n# 一般化線形混合モデル（ランダム切片）\nglmer(cbind(incidence, size - incidence) ~ period |> as.numeric() + (1 | herd), family = \"binomial\", data = cbpp)\n```\n\n`lme4`パッケージの他に、RではGLMMの計算に関わるパッケージとして、[`glmm`](https://cran.r-project.org/web/packages/glmm/index.html) [@glmm_bib]や[`MCMCglmm`](https://cran.r-project.org/web/packages/MCMCglmm/index.html) [@MCMCglmm_bib]などがあります。一般化線形モデル・一般化線形混合モデルについては、やや古典の教科書となってきていますが、[データ解析のための統計モデリング入門](https://www.amazon.co.jp/%E3%83%87%E3%83%BC%E3%82%BF%E8%A7%A3%E6%9E%90%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B5%B1%E8%A8%88%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80%E2%80%95%E2%80%95%E4%B8%80%E8%88%AC%E5%8C%96%E7%B7%9A%E5%BD%A2%E3%83%A2%E3%83%87%E3%83%AB%E3%83%BB%E9%9A%8E%E5%B1%A4%E3%83%99%E3%82%A4%E3%82%BA%E3%83%A2%E3%83%87%E3%83%AB%E3%83%BBMCMC-%E7%A2%BA%E7%8E%87%E3%81%A8%E6%83%85%E5%A0%B1%E3%81%AE%E7%A7%91%E5%AD%A6-%E4%B9%85%E4%BF%9D-%E6%8B%93%E5%BC%A5/dp/400006973X/ref=sr_1_2?crid=2YDRTUCPZM4HJ&dib=eyJ2IjoiMSJ9.cLlyysXZ_iLOvRYhmMJO8JrLu9tI7C8BlfM7l-0RNeVcFhLjF1qiYu15YvB-rT3Lrpa8oFEXcgLjWYGoh0zZkiPv9d5OFqty6iHTINEyi_6ufuJ_m6rRoH5wQ7TGJFAN651BEnLDZSDbd00hNfVQe6E6exjz-me5Pc9uszWcbYM0xrlzNDIJLfKjaDW54iHjw0crxJ2958tU_HIWu8CyQKgGozQCr5-qa18BMNosh4lsn-4zDcwPLFxvELOeJV8Wl5Spd9jMCTr1kH-fLzwap-WclLOmTVanOXxEYKktzUo.AC94qccYjYbiT6GFuTJIqo4x3g9GOmWkp_8PFHe2fec&dib_tag=se&keywords=%E7%B5%B1%E8%A8%88%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0&qid=1727527212&sprefix=toukeimoderin%2Caps%2C173&sr=8-2)を読まれるのが良いでしょう。\n\n## ベイズモデル\n\nGLMMよりも更に複雑な回帰を行いたい場合には、**ベイズ統計モデリング**というものを用いることになります。ベイズ統計とは、ベイズの法則を用いた統計手法で、複雑な回帰や時系列解析、地理空間情報の解析等に用いられている手法です。\n\n:::{.callout-tip collapse=\"true\"}\n\n## ベイズの定理\n\nベイズの定理は条件付き確率に関する法則で、以下の式で表されるものです。\n\n$$p(A|B)=\\frac{p(A \\cap B)}{p(B)}$$\n\n上式について、下のベン図（venn plot）を利用して考えることにします。全体で50、Aに20、Bに20、AとBの重なっている部分（これが$A \\cap B$、AかつB）が15とすると、$p(A|B)$、つまりBの条件のもとでAである確率は、Bである確率$p(B)=20/50$、AかつBである確率$p(A \\cap B)=15/50$から、以下の式で求まります。\n\n$$p(A|B)=\\frac{p(A \\cap B)}{p(B)}=\\frac{15}{50}/\\frac{20}{50}=15/20$$\n\n```{r, echo = FALSE}\npacman::p_load(gplots)\nA <- rep(c(\"a\", \"b\", \"c\"), c(10, 5, 5))\nB <- rep(c(\"a\", \"b\", \"d\"), c(10, 5, 5))\nvenn(list(A, B), small = 0, simplify = TRUE)\n```\n\nベイズの定理は、AとBを入れ替えても当然成り立ちます。\n\n$$p(B|A)=\\frac{p(A \\cap B)}{p(A)}$$\n\n上式の$p(A|B)$と$p(B|A)$では、$p(A \\cap B)$の部分が共通しています。この$p(A \\cap B)$で両方の式を解くと、\n\n$$p(A \\cap B) = p(A|B) \\cdot p(B) = p(B|A) \\cdot p(A)$$\n\nとなります。$p(A \\cap B)$は無視して、この式を$p(A|B)$について解くと、\n\n$$p(A|B) = \\frac{p(B|A) \\cdot p(A)}{p(B)}$$\n\nという形に変形することができます。ベイズ統計で用いられるのはこちらの式で、この式もベイズの定理と呼ばれます。分母の$p(B)$は一旦無視すると、\n\n$$p(A|B) \\propto p(B|A) \\cdot p(A)$$\n\nという形に変形できます。この式を見ると、$p(A)$は既知のAの確率、$p(B|A)$はAとBが入れ替わっている、つまり尤度で、尤度と既知の確率の掛け算に条件付き確率$p(A|B)$が比例する、という式になっています。この式のうち、$p(A)$を**事前分布**、$p(B|A)$をデータから得られる**尤度**、$p(A|B)$を**事後分布**とします。この式は既知の事前分布とデータから計算できる尤度が分かれば、データが得られた後に更新された事後分布がわかるという、データが取れたときの確率の更新の式として用いられています。\n\nただし、このベイズの定理を用いて確率を数理的に計算するのは難しいため、数理的に計算ができる事前分布である共役事前分布というものを用いたり、乱数計算（Malkov Chain Monte Carlo法：MCMC）を用いて計算するのが一般的です。\n\n:::\n\n非常に複雑な回帰を行うときや、時系列・空間地理情報の統計において[状態空間モデル](https://logics-of-blue.com/%E7%8A%B6%E6%85%8B%E7%A9%BA%E9%96%93%E3%83%A2%E3%83%87%E3%83%AB%E3%81%A8%E3%81%AF/)というものを利用する場合以外ではベイズモデルを使用することはあまりないと思いますが、ベイズモデルを使って簡単な線形回帰を行うこともできます。\n\nとりあえずベイズ統計を試してみたいのであれば、[`brms`パッケージ](https://cran.r-project.org/web/packages/brms/index.html) [@brms_bib1; @brms_bib2; @brms_bib3]を利用するのが良いでしょう。`brms::brm`関数を用いると、`glm`などと同じように関数を設定し、回帰を行うことができます。\n\nベイズ統計では、パラメータ（傾きや切片）は事後分布として、幅をもって推定されます。この事後分布の最頻値を**MAP（maximum a posteriori）推定値**と呼び、95%区間などの区間推定値を**ベイズ信用区間**と呼びます。また、`brm`では`prior`引数に事前分布を設定する必要があります。事前分布の設定がおかしいと計算できない場合もありますので、データを見て慎重に事前分布を定める必要があります。\n\n以下の計算の例では、Regression CoefficientsのEstimateが各パラメータのMAP推定値、95% CIがベイズ信用区間となります。\n\n```{r}\n# ベイズモデルでの回帰\npacman::p_load(brms)\nfit1 <- brm(rating ~ period + carry + cs(treat),\n            data = inhaler, family = sratio(\"logit\"),\n            prior = set_prior(\"normal(0,5)\"), chains = 2)\nsummary(fit1)\n\n# 計算結果をグラフとして表示（ヒストグラムがパラメータの事後分布）\nplot(fit1, ask = FALSE)\n```\n\n`brm`関数は[Stan](https://mc-stan.org/) [@stan_bib]という乱数計算プログラムに依存しています。さらに複雑なベイズ統計を用いる場合には、[rstan](https://cran.r-project.org/web/packages/rstan/index.html) [@rstan_bib]や[CmdStanR](https://github.com/stan-dev/cmdstanr/tree/master)といったパッケージを利用し、Stanの言語で統計モデルを直接記述し、計算する必要があります。興味がある方には教科書（[データ解析のための統計モデリング入門](https://www.amazon.co.jp/%E3%83%87%E3%83%BC%E3%82%BF%E8%A7%A3%E6%9E%90%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B5%B1%E8%A8%88%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0%E5%85%A5%E9%96%80%E2%80%95%E2%80%95%E4%B8%80%E8%88%AC%E5%8C%96%E7%B7%9A%E5%BD%A2%E3%83%A2%E3%83%87%E3%83%AB%E3%83%BB%E9%9A%8E%E5%B1%A4%E3%83%99%E3%82%A4%E3%82%BA%E3%83%A2%E3%83%87%E3%83%AB%E3%83%BBMCMC-%E7%A2%BA%E7%8E%87%E3%81%A8%E6%83%85%E5%A0%B1%E3%81%AE%E7%A7%91%E5%AD%A6-%E4%B9%85%E4%BF%9D-%E6%8B%93%E5%BC%A5/dp/400006973X/ref=sr_1_2?crid=2YDRTUCPZM4HJ&dib=eyJ2IjoiMSJ9.cLlyysXZ_iLOvRYhmMJO8JrLu9tI7C8BlfM7l-0RNeVcFhLjF1qiYu15YvB-rT3Lrpa8oFEXcgLjWYGoh0zZkiPv9d5OFqty6iHTINEyi_6ufuJ_m6rRoH5wQ7TGJFAN651BEnLDZSDbd00hNfVQe6E6exjz-me5Pc9uszWcbYM0xrlzNDIJLfKjaDW54iHjw0crxJ2958tU_HIWu8CyQKgGozQCr5-qa18BMNosh4lsn-4zDcwPLFxvELOeJV8Wl5Spd9jMCTr1kH-fLzwap-WclLOmTVanOXxEYKktzUo.AC94qccYjYbiT6GFuTJIqo4x3g9GOmWkp_8PFHe2fec&dib_tag=se&keywords=%E7%B5%B1%E8%A8%88%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0&qid=1727527212&sprefix=toukeimoderin%2Caps%2C173&sr=8-2)、[RとStanではじめる ベイズ統計モデリングによるデータ分析入門](https://www.amazon.co.jp/dp/B07WFD5RFS/)や[StanとRでベイズ統計モデリング]((https://www.amazon.co.jp/dp/4320112423/))）を読むことをおススメします。\n\n## ガウス過程回帰\n\nガウス過程回帰はベイズの法則を用いて、説明変数xと目的変数yの非線形な関係を回帰する方法です。ベイズ推定する回帰の方法ですので、結果は幅を持った形で推定されます。この手法は回帰ではありますが、上記のようなパラメータを求めて数式が得られるような手法ではなく、主に予測的に用いる方法です。`predict`関数を用いて、ある説明変数に対する目的変数の値の予測を行う形で用います。\n\nRでは、`kernlab`パッケージ[@kernlab_bib1; @kernlab_bib2]の`gausspr`関数を用いて、ガウス過程回帰を計算できます。`gausspr`関数では説明変数、目的変数に当たる変数をそれぞれ`x`、`y`引数に設定して計算します。計算結果は`gausspr`クラスのオブジェクトで、回帰線上の点の位置や標準偏差を求める場合には、`predict`関数を用いることになります。\n\n```{r, filename=\"ガウス過程回帰\"}\npacman::p_load(kernlab)\nx <- seq(-20, 20, 0.1)\nd1 <- data.frame(x = x, y = sin(x) / x + rnorm(401, sd = 0.03))\nplot(d1) # 回帰するデータ\n\n# これがガウス過程回帰の計算\nfit <- gausspr(x = d1$x, y = d1$y, variance.model = T)\n\n# 回帰の結果を見てもよくわからない\nfit\n\n# xに対する代表値・SDを予測する\nd <-data.frame(x, pred = predict(fit, x))\nd$sd <- predict(fit, x, type = \"sdeviation\") \n\n# 結果をプロット\nggplot()+\n  geom_point(data = d1, aes(x = x, y = y, color = 1), size = 1) +\n  geom_ribbon(data = d, aes(x = x, ymax = pred + sd, ymin = pred - sd, color = 2, fill = 2), alpha = 0.5)+\n  geom_line(data = d, aes(x = x, y = pred, color = 2, alpha = 0.5), linewidth = 1)\n```\n\n## 説明変数がたくさんある場合の回帰\n\n一つの目的変数に対して説明変数が数多く存在する場合には、回帰を行う際に問題が生じることがあります。主に注意が必要となるものは、**過学習**と**多重共線性**の2つです。この2つの問題に対応するため、数多く存在する説明変数から、特に目的変数への影響が大きく、意味がありそうなものを選択する手法がいくつか存在します。以下に、この説明変数の選択（**モデル選択**）を行う手法をいくつか紹介します。\n\n:::{.callout-tip collapse=\"true\"}\n\n## 説明変数の数と過学習\n\n一般線形モデル（重回帰、分散分析）、一般化線形モデル、線形混合モデルのいずれにおいても、説明変数はデータのある限り、いくらでも追加することができます。しかし、説明変数をデータの数と同じだけ設定すると、決定係数は1、つまり、必ずすべての点を通る線となります。例えば、下図のようにExcelで6次の多項式回帰（説明変数が6つに増えている）を行えば、グネグネした曲線ですべての点を通る線を引けることがわかるでしょう。\n\n![図：Excelで6次の多項式回帰で線を引く](./image/excel_polynomial.png)\n\nしかし、データの特徴を捉えるという意味では、このグネグネした曲線はあまり役に立ちません。例えば、上の多項式近似ではx=1とx=2の間にピークが一つありますが、このピークが現実的に起こりうるかというと、そういうことはなさそうです。したがって、xの値からyの値を予測する場合、多項式近似の曲線より、すべての点を通らない直線の方が、回帰としては意味がありそうです。\n\nこのように、説明変数が多くなると、回帰はデータを示す点を通りやすくなりますが、予測性は失われていきます。このような回帰の特徴のことを**過学習**と呼びます。この過学習を避けるために、説明変数の数はできるだけ多くし過ぎず、かつ必要な説明変数を十分に含めた回帰を行うことが望ましいとされています。\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## 説明変数間の相関と多重共線性\n\n説明変数が多くなると、説明変数の間に相関が生じることがあります。説明変数間に相関があると、説明変数の傾きがうまく求まらなくなる問題、**多重共線性**の問題、というものが生じます。\n\n多重共線性について直感的に捉えるには、目的変数yの説明変数x~1~とx~2~に直線的な関係がある場合（相関係数が1の場合）を考えてみると良いでしょう。\n\n目的変数yはx~1~とx~2~により、直線的な関係で示すことができるとき、以下のような式の関係で表すことができます。\n\n$$y = ax_{1} + bx_{2}$$\n\naとbは係数（傾き）です。x~1~とx~2~が独立、つまりx~1~とx~2~に相関がなければ、y、x~1~、x~2~の数値の組が2つあれば、aとbを連立方程式で求めることができます。\n\n一方、x~1~とx~2~に直線的な関係がある場合には、x~1~とx~2~の関係は以下の式で表すことができます。\n\n$$x_{1} = cx_{2}$$\n\ncは係数です。この時、aとbを求めることを考えて式を変形すると、\n\n$$ y= ax_{1} + bx_{2} = ax_{1} + bcx_{1} = (a+bc)x_{1}$$\n$$ y= ax_{1} + bx_{2} = acx_{2} + bx_{2} = (ac+b)x_{2}$$\n\nとなります。この式においてxやyの値が分かれば、a+bcやac+bの値を求めることができます。しかし、この値からわかるのはaとbの関係だけで、aとbを一意に決める、つまりa=◯、b=●といった解を求めることはできません。\n\nこの例では説明変数間の関係を非常に単純化していますが、説明変数間に相関があると傾きが求まらなくなる、ということはイメージできるかと思います。多重共線性は正確には統計における行列計算に問題が生じることで計算結果が不安定になることを指します。\n\n多重共線性を避けるためにも説明変数の数を多くしすぎず、互いに相関の無い説明変数だけを選ぶことは重要となります。\n\n:::\n\n## AICによるモデル選択\n\n「目的変数を説明するのに必要十分な説明変数」を適切に選ぶことが、説明変数が多い回帰では重要となります。例えば、学生の数学の成績を目的変数として回帰を行うときに、くじ引きで決めた学生の座席の位置を説明変数としても普通は何の意味も無いはずです。したがって、座席の位置は説明変数に入れない方がいいということは直感的にわかるかと思います。\n\nとは言っても、説明変数の組み合わせは説明変数の数が増えると増大していきますし、実際に目的変数に影響を与えうるのかよくわからない説明変数も増えていきます。\n\n説明変数の組み合わせのことを、回帰の**「モデル」**と呼びます。説明変数の組み合わせ、つまり数多くあるモデルから、適切なモデルを選び出すことを、**モデル選択**と呼びます。モデル選択の手法には様々なものがあります。最もよく知られているモデル選択の方法は、**AIC（赤池情報量基準、Akaike's Information Criterion）**によるモデル選択です。\n\nAICは、最尤推定の際に用いる尤度（likelyhood）に、説明変数の数をペナルティとして与えた数値です。AICは以下の計算式で求めることができます。\n\n$$ AIC = -\\ln(Likelyhood) + 2 \\cdot K $$\n\n上式で、$\\ln(Likelyhood)$は対数尤度、Kは説明変数の数を示します。AICによるモデル選択では、**AICが小さいモデルほど、目的変数をうまく説明できている**として、AICを最小にするモデルを選択します。説明変数の数の2倍を足し算していることで、説明変数がたくさん含まれるモデルにはAICが大きくなるペナルティが付く、つまり選ばれにくくなります。\n\n一般化線形モデルを計算する`glm`関数を用いると、AICの計算結果を得ることができます。例えば、以下の例では`iris`の`Sepal.Length`を回帰する7つのモデル、説明変数の組み合わせ、のAICを計算しています。AICの結果から、最後のモデル、3つ説明変数があるモデルでAICが最小となる、つまりこの3つ説明変数があるモデルを選択するということになります。\n\n```{r, filename=\"glm関数でAICを求める\"}\nc(\n  glm(Sepal.Length ~ Sepal.Width, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Petal.Length, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Petal.Width, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Sepal.Width + Petal.Length, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Petal.Length + Petal.Width, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Sepal.Width + Petal.Width, data = iris, family = \"gaussian\") |> _$aic,\n  glm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, data = iris, family = \"gaussian\") |> _$aic\n)\n```\n\n説明変数が3つぐらいなら$_{3}C_{1} +_{3}C_{2}+_{3}C_{3}$、つまり7通りのモデルについてAICを調べればモデル選択を行うことができますが、例えば説明変数が20個あれば、`r options(scipen=100); k <- 0; for(i in 1:20){k <- k + choose(20, i)}; k`通りと膨大なモデルを比較する必要があります。モデルに交互作用を加えると、更に多くの比較が必要となります。\n\nこのような煩雑なAICの計算のために、RにはAICによるモデル選択を自動的に行ってくれる関数である、`step`関数が備わっています。`lm`や`glm`に説明変数をすべて含むformula（**フルモデル**）を設定し、その返り値を`step`関数の引数とすることで、各モデルのAICを自動的に比較し、AIC最小モデルを選択してくれます。\n\n```{r, filename=\"step関数によるAIC最小モデルの選択\"}\n# 回帰の返り値をlm_irisに代入\nlm_iris <- \n  lm(iris$Sepal.Length ~ \n       iris$Sepal.Width + \n       iris$Petal.Length + \n       iris$Petal.Width + \n       iris$Species)\n\n# 下の例ではフルモデル（説明変数をすべて含むモデル）が選択されている\n# trace = 1とすると、AIC選択の過程が表示される\nstep(lm_iris, trace = 0) \n```\n\n## スパース回帰\n\nAICによるモデル選択はわかりやすく単純ですが、説明変数が多くなると、上記のようにどうしても繰り返し計算回数が多くなり、計算コストがかかるようになります。説明変数が10個ぐらいならまだ何とかなりますが、現代のデータでは説明変数の数が非常に多い場合もあります。あまりに説明変数が多いと、AICによるモデル選択ではモデルを最適化するのに時間がかかってしまいます。\n\nこのような場合に、ある程度自動的にモデル選択を行うような回帰のことを**スパース回帰**と呼びます。スパース回帰は、二乗誤差を計算する際に、正則化項というものを加えることで、各説明変数の傾きを調整する回帰の方法です^[かなり端折って説明しています。スパース回帰については、文献[@大森敏明2015KJ00009904410; @川野秀一2017]をご参考下さい]。正則化項の入れ方によって、スパース回帰は**リッジ回帰**、**ラッソ回帰**と、**エラスティックネット**と呼ばれる手法の3つに分かれます。\n\nRでスパース回帰を行う場合には、[glmnetパッケージ](https://cran.r-project.org/web/packages/glmnet/index.html) [@glmnet_bib1; @glmnet_bib2; @glmnet_bib3]を用います。\n\n```{r, filename=\"ライブラリの読み込み\"}\n## スパース回帰のライブラリ（mlbenchはデータを取得するために読み込み）\npacman::p_load(glmnet, mlbench)\n```\n\n`BostonHousing`は、1970年国勢調査（センサス）におけるボストンの各地域の住宅価格と、その地域の犯罪率、非小売業の面積の割合、築年数の古い建物の割合、高速道路までのアクセス、税金等を表にしたものです。重回帰の例として、住宅価格をその他のデータで説明する、つまり住宅価格を目的変数、その他のデータを説明変数として用いられることの多いデータです。\n\nこの`BousonHousing`を用いて、AICによるモデル選択とスパース回帰を比較していきます。\n\n```{r, filename=\"BostonHousingのデータ\"}\ndata(\"BostonHousing\")\nhead(BostonHousing) # データにmlbenchパッケージのBostonHousingを用いる\n\n# 前処理\ntempBoston <- BostonHousing\ntempBoston$chas <- as.numeric(tempBoston$chas)\n```\n\n### データの正規化\n\n説明変数である地域の犯罪率、非小売業の面積の割合、築年数の古い建物の割合、高速道路までのアクセス、税金等は単位も値もまちまちで、データによって1000倍以上も値が異なります。このような大きく値が異なる説明変数を用いて回帰を行うと、傾き（係数）の単位が大きく異なることとなり、どの説明変数が目的変数に影響を与えているのか、分かりにくくなります。\n\nこのように、説明変数の桁や平均値等が大きく異なる場合には、まずデータを**正規化（normalization）**します。**正規化とは、データの平均値が0、標準偏差が1となるように、データを変換すること**を指します。このようなデータの変換を行うことで、説明変数間の桁や平均値を統一し、傾きの意味を理解しやすくすることができます。上記の重回帰や一般化線形モデルなどでも同様に、データをあらかじめ正規化しておくことは重要となります。\n\nRでデータの正規化を行う場合には、`scale`関数を用います。`scale`関数はベクターもしくはデータフレームを引数に取り、ベクターの場合はそのベクターの平均と標準偏差を、データフレームの場合には列ごとの平均と標準偏差をそれぞれ0、1に変換します。\n\n```{r, filename=\"説明変数の正規化\"}\n# 説明変数になるデータをscale関数で正規化\ntempBoston[1:13] <- tempBoston[1:13] |>  scale()\n\n# 平均が0、標準偏差が1になる\ntempBoston[1:13] |> apply(2, mean) |> round(digits = 3)\ntempBoston[1:13] |> apply(2, sd)\n```\n\n### AICでモデルを選択する\n\nまずは、`step`関数でモデル選択を行います。`step`関数の引数は`lm`関数や`glm`関数の返り値ですので、説明変数をすべて使ったフルモデルの`lm`関数の返り値が必要となります。\n\nただし、あまりに説明変数が多いと、一つづつ`+`でつなぐのは大変です。Rでは、formulaの右辺、説明変数の欄に`.`（ピリオド）を入力すると、データフレームのうち、目的変数以外のすべての列を説明変数とすることができます。以下の例では、`BousonHousing`の`medv`（家の価格のデータ）を目的変数、その他の列のデータをすべて説明変数とした`lm`関数の返り値を`lm_model`に代入しています。\n\nこの`lm_model`を用いて`step`関数でモデル選択をすると、下記のように切片（intercept）を除いて11個の説明変数の傾きが計算されます。この`step`関数の計算過程で、`indus`と`age`、非小売業の面積の割合と築年数の古い建物の割合の項が抜けていることがわかります。\n\n```{r, filename=\"step関数でモデル選択\"}\ncolnames(tempBoston) # medvを除くと13列のデータになっている\n\n# とりあえずlmとStepでやってみる\n# 説明変数を.で指定すると、目的変数以外のすべてのデータを説明変数に設定する\nlm_model <- lm(medv ~ ., data = tempBoston)\nstep(lm_model, trace = 0)\n```\n\n### ラッソ回帰\n\n同様の回帰をスパース回帰の一つである**ラッソ（lasso）回帰**を用いて行います。\n\nスパース回帰では、まず正規化項の係数（λ、ラムダ）というものを求める必要があります。このλを求めるための関数が、`glmnet`パッケージの`cv.glmnet`関数です。\n\n`cv.glmnet`関数はformulaを引数に取らず、引数`x`に各列が説明変数である行列、引数`y`に目的変数であるベクターを指定します。さらに、`glm`関数と同様に目的変数の分布として`family`引数、ラッソ回帰を指定するための引数である`alpha=1`をそれぞれ指定します。\n\nこの`cv.glmnet`関数の返り値（下の例では`cvlasso_m`）を`plot`関数の引数に取ると、Mean-squared error（平均2乗誤差）とラムダの関係を示したグラフが表示されます。このグラフのうち、縦線が引いてある2本のうちラムダの小さい方の値を、正規化項の係数λとして採用します。ですので、下の`BousonHousing`の例では、log(λ)=-3.7付近の値をλとして採用し、ラッソ回帰を行うこととなります。\n\nこの-3.7の点線の上側には、11と記載されています。この11は選択された説明変数の数を示しています。つまり、λを点線の値に指定すると、ラッソ回帰で11個の説明変数が選択され、2つが落とされるということになります。\n\n```{r, filename=\"ラッソ回帰：λを求める\"}\n# ラッソ回帰：正規化項の係数を求める\n# 乱数計算を含むため、seedを設定しないと計算値は変化する\ncvlasso_m <- \n  cv.glmnet(\n    x = tempBoston[,1:13] |> as.matrix(), \n    y = tempBoston$medv, \n    family = \"gaussian\", \n    alpha = 1)\n\n# 左側の点線のラムダを採用する\nplot(cvlasso_m)\n\n# 大きい方のlog(λ)の点線の値\ncvlasso_m$lambda.1se |> log() \n\n# 小さい方のlog(λ)の点線の値（こちらを採用する）\ncvlasso_m$lambda.min |> log() \n```\n\nラッソ回帰の計算は`glmnet`関数で行います。`glmnet`関数の引数はほぼ`cv.glmnet`関数と同じです。ラムダを指定せずに`glmnet`関数での計算を行うと、正規化項の大きさ（L1 norm）やラムダと傾きの関係を求めることができます。この関係を求めるときには、`glmnet`関数の返り値を`plot`関数の引数とします。ラムダとの関係を知りたい場合には`plot`関数の引数に`xvar=\"lambda\"`を追加します。グラフの上に表示される数値は選択される説明変数の数を示しています。lambdaが大きく、L1 normが小さくなるとグラフは0に収束していきますが、これはlambdaとL1 normに従い、傾きが0、つまり説明変数から脱落するものが多くなっていくことを示しています。\n\n```{r, filename=\"ラッソ回帰：傾きの計算1\"}\n# ラッソ回帰：正規化項の係数を入力せずに計算\nlasso_m <- \n  glmnet(x = tempBoston[,1:13], \n         y = tempBoston$medv, \n         family = \"gaussian\", \n         alpha = 1)\n\n# 正則化項（L1）の大きさと傾き\nplot(lasso_m)\n\n# ラムダの大きさと傾き\nplot(lasso_m, xvar = \"lambda\")\n```\n\n`cv.glmnet`関数でλを計算した値がある場合、`glmnet`関数の`lambda`引数に`cv.glmnet`関数で計算したλの値を指定します。\n\nこの`glmnet`関数の結果をそのまま見てもよくわかりませんが、返り値はS4オブジェクトとなっており、`$`を用いて情報を取り出すことができます。傾きは`$beta`で呼び出すことができます。\n\n```{r, filename=\"ラッソ回帰：ラムダを指定して傾きの計算\"}\n# ラッソ回帰：正規化項の係数を入力して計算\nlasso_m2 <- \n  glmnet(x = tempBoston[,1:13], \n         y = tempBoston$medv, \n         family = \"gaussian\", \n         lambda = cvlasso_m$lambda.min, \n         alpha = 1)\n\n# モデルと自由度、ラムダ等が帰ってくる\nlasso_m2\n\n# 傾きの項（.は傾き0になっている）\nlasso_m2$beta\n```\n\n上記の結果を見ると、`indus`と`age`の結果（s0）が`.`（ピリオド）になっています。この`.`は傾きが0、つまりモデルに組み込まないことを示しています。`step`関数で落とされた`indus`と`age`がラッソ回帰でも落とされていることがわかります。また、`rm`の傾きが大きく、`lstat`の傾きが小さいことがわかります。`rm`は1住居あたりの部屋数、`lstat`は地位の低い住民の割合ですので、住宅価格は部屋数が増えると高くなり、地位の低い住民の割合が増えると下がる傾向にあることがわかります。\n\n### リッジ回帰\n\n**リッジ（ridge）回帰**は正規化項の種類（L2正規化項）がラッソ回帰（L1正規化項）とは異なる、スパース回帰の一つです。リッジ回帰では、AICによるモデル選択やラッソ回帰とは異なり、説明変数の選択は行われません。リッジ回帰は多重共線性がある、説明変数同士に相関がある場合に、妥当な傾きを計算するのに有用な方法です。\n\nリッジ回帰の場合にもラッソ回帰と同様に、`cv.glmnet`関数でλを計算した上で、`glmnet`関数で傾きを求めます。ただし、リッジ回帰を行うときには引数`alpha`に`0`を指定します。\n\n```{r, filename=\"リッジ回帰：λを求める\"}\ncvridge_m <- \n  cv.glmnet(\n    x = tempBoston[,1:13] |> as.matrix(), \n    y = tempBoston$medv, \n    family = \"gaussian\", \n    alpha = 0)\n\nplot(cvridge_m)\n\ncvridge_m$lambda.min %>% log\n```\n\nラッソ回帰ではグラフの上の数値が右に行くほど減っていきますが、リッジ回帰では減っていかない、つまり説明変数が落とされることはないことがわかります。\n\n```{r, filename=\"リッジ回帰：傾きを求める\"}\nridge_m <- \n  glmnet(\n    x=tempBoston[,1:13], \n    y=tempBoston$medv, \n    family=\"gaussian\", \n    lambda=cvridge_m$lambda.min, \n    alpha=0)\n\nridge_m$beta\n```\n\n実際に係数を確認すると、ラッソ回帰では.で表示されていた`indus`と`age`も0にはなっておらず、説明変数から外されていないことがわかります。\n\n### エラスティックネット\n\nエラスティックネットは、ラッソ回帰とリッジ回帰を混ぜ合わせたような、中間的なスパース回帰です。エラスティックネットはラッソ寄り、リッジ寄りのスパース回帰として設定することができます。このラッソ寄り、リッジ寄りの設定は、`alpha`引数の値で指定し、`alpha`が1に近いとラッソ寄り、0に近いとリッジ寄りの回帰となります。下の例では`alpha`を0.5としていますが、実際にデータに用いる場合には`alpha`の値を最適化して用います。このように、計算においてある程度自分で最適化が必要となるパラメータのことを機械学習の分野では**ハイパーパラメータ**と呼びます。\n\n```{r, filename=\"エラスティックネット\"}\n# 実際にはアルファを最適化して利用する\ncven_m <- \n  cv.glmnet(\n    x = tempBoston[,1:13] |> as.matrix(), \n    y = tempBoston$medv, \n    family = \"gaussian\", \n    alpha = 0.5)\n\nplot(cven_m)\n\ncven_m$lambda.min %>% log\n\nen_m <- \n  glmnet(\n    x = tempBoston[,1:13], \n    y = tempBoston$medv, family=\"gaussian\", \n    lambda = cven_m$lambda.min, \n    alpha = 0.5)\n\nen_m$beta\n```\n\n## 主成分回帰\n\n説明変数間に相関があると多重共線性の問題が起こります。ですので、説明変数をうまく変換して説明変数間の相関をなくしてやれば、多重共線性の問題なく回帰を行うことができます。\n\nデータ変換のうち、**主成分分析（Primary Component Analysis、PCA）**は多次元のデータの特徴を捉えるために用いられる手法の一つです（[28章](./chapter28.html)を参照）。詳細は省きますが、主成分分析で変換すると、変換後のデータ（第一主成分、第二主成分…）の間の相関係数が0、つまり相関のない状態になります。この性質を用いて、主成分分析でデータ変換したものを説明変数にすることで多重共線性を避けて回帰を行う方法のことを**主成分回帰（Primary Component Regression、PCR）**と呼びます。\n\n主成分回帰では、まず説明変数を主成分分析を用いて、主成分に変換します。この変換した主成分を用いて目的変数を説明する回帰を行います。主成分への変換に伴い、元の説明変数と目的変数の関係が不明瞭になりますので、回帰をデータの説明に使うのには適していませんが、この回帰の結果を目的変数の予測に用いることができます。\n\nRでは、主成分分析は`prcomp`関数で行います。`prcomp`の返り値は主成分への変換を行うための`prcomp`クラスのオブジェクトで、主成分は`$x`で取り出します。後は`lm`関数で説明変数に主成分を指定して回帰を行うだけです。\n\n`$rotation`でデータを主成分に変換する際の係数が求まります。また、説明変数を主成分に変換する際には`predict`関数を用います。`predict`関数の第一引数に`prcomp`オブジェクトを、第二引数に変換したいデータをデータフレームで指定します。計算した主成分を、`lm`オブジェクトを用いた`predict`関数に与えて予測すれば、主成分回帰による予測値を得ることができます。\n\n```{r, filename=\"主成分回帰\"}\n# 主成分への変換\npc <- iris[,2:4] |> prcomp(scale = T)\n\npc$x |> head() # 変換後の主成分（PC1～PC3）\n\npc$rotation # 主成分への変換の係数\n\n# 目的変数をデータフレームに付け加える\npc1 <- pc$x |>  as.data.frame()\npc1$Sepal.Length <- iris$Sepal.Length\n\n# 主成分で回帰（主成分4つをすべて用いる）\npcr_lm <- lm(Sepal.Length ~., data = pc1)\n\n# 予測の例\nexample_iris <- data.frame(Sepal.Width = 5, Petal.Length = 6, Petal.Width = 3)\n\n# 予測に用いる説明変数を主成分に変換\npc_example <- predict(pc, example_iris)\npc_example\n\n# 主成分を用いて予測値を計算\npredict(pcr_lm, pc_example |> as.data.frame())\n```\n\n主成分回帰は[plsパッケージ](https://cran.r-project.org/web/packages/pls/index.html) [@pls_bib]の`pcr`関数を用いても行うことができます。\n\n```{r, filename=\"plsパッケージのpcr関数で主成分回帰\"}\npacman::p_load(pls)\ndata(yarn)\n\n# PCRの計算（ncompは回帰に用いる主成分の数）\nyarn.pcr <- pcr(density ~ NIR, ncomp = 6, data = yarn, validation = \"CV\") \nyarn.pcr |> summary() # 回帰結果の表示\n```\n\n\n## 部分的最小二乗回帰\n\n**部分的最小二乗回帰（Partial Least Squares regression、PLS回帰）**は主成分回帰（PCR）と同じく説明変数を変換して回帰を行う方法ですが、変換を行う際に、目的変数と変換後の説明変数の間の共分散が大きくなるよう調整することで、多重共線性の問題をより小さくしています。\n\nPLS回帰は分析化学の分野で、吸光度などのデータから目的変数、例えば物質の濃度など、を予測するために開発され、用いられています。吸光度などの化学データでは、一般的に1検体につき波長ごとの吸光度として1000以上の値が求まりますので、目的変数（1検体に1濃度）に対して非常に多くの説明変数（1検体につき、1000以上の吸光度の数値）がある、つまり多重共線性が非常に起こりやすいデータとなっています。説明変数をPCRよりもうまく変換することで、この多重共線性の問題を起こりにくくした手法がこのPLSです。\n\n### PLS：データの準備とクロスバリデーション\n\nRのPLS回帰の計算では、機械学習でよく用いられる**クロスバリデーション**という方法が用いられます。クロスバリデーションとは、手持ちのデータを**訓練データ**と**テストデータ**の2つに分割し、訓練データを用いて回帰を行い、テストデータで回帰の精度を評価する方法のことです。クロスバリデーションを行うことで、訓練データに用いていない、新規データでの予測精度を評価することができます。\n\nPLS回帰に用いる、以下の`yarn`のデータセットは、PET yarn（ポリエステル糸）の近赤外吸光分光データ（Near Infra Red、[NIR](https://ja.wikipedia.org/wiki/%E8%BF%91%E8%B5%A4%E5%A4%96%E7%B7%9A%E5%88%86%E5%85%89%E6%B3%95)）と糸の密度（`density`）の関係を示したデータです。このデータセットでは、予めクロスバリデーション用に`train`という列が追加されており、21行が`TRUE`、つまり訓練データで、残りの7行が`FALSE`、つまりテストデータとなっています。\n\n```{r, filename=\"PLSに用いるデータ：yarn\"}\n# yarnはplsパッケージのデータセット\npacman::p_load(pls)\ndata(yarn) # ポリエステル繊維のNIR（近赤外吸収）データ\ncolnames(yarn) # NIRにはNIR.1～NIR.268の列が登録\n\ndim(yarn)\n\nsummary(yarn$train) # 21データが訓練、7データがテストデータ\n```\n\nRでは、`pls`パッケージの`plsr`関数を用いてPLS回帰を行うことができます。`plsr`関数の第一引数はformulaです。`ncomp`引数は回帰に用いる説明変数変換後のパラメータの数で、増やすとデータへの適合度は高くなりますが、過学習のリスクも大きくなります。\n\n`validation`には用いるバリデーションの方法を指定します。`validation=\"CV\"`では、`train`の列の論理型を用いてクロスバリデーションを行います。leave-one-outと呼ばれる、データの一つだけをテストデータとして、その他のデータを訓練データとする場合には、`validation=\"LOO\"`と指定します。\n\n```{r, filename=\"部分的最小二乗回帰（PLS）\"}\nyarn.pls <- \n  plsr(\n    density ~ NIR, \n    ncomp = 6, \n    data = yarn, \n    validation = \"CV\")\nyarn.pls |> summary()\n```\n\nPLS結果を用いた予測には、`predict`関数を用います。`predict`関数の第一引数に`plsr`関数の返り値、`comps`引数には上の`yarn.pls|>summary()`の結果として示されている`comps`のうち、回帰に用いるものを指定します。通常は`plsr`関数の`ncomp`に指定した数値までのベクターで指定することになります。`newdata`には予測したいデータのデータフレームを指定します。\n\n```{r, filename=\"PLSの結果を用いてデータを予測する\"}\n# モデルにデータを与えてpredictすることで用いる\nresult_prediction <- predict(\n  yarn.pls, \n  comps = 1:6, \n  newdata = yarn[!yarn$train,])\n\n# 左がテストデータ、右が予測値\ndata.frame(testresult = yarn[!yarn$train,]$density, result_prediction) |> \n  knitr::kable()\n```\n\n回帰からの予測の結果が上の表となります。左の列がテストデータの測定値、右のデータがPLSからの予測値です。概ねどのサンプルでも`density`が正しく予測されているのがわかるかと思います。\n\n## ニューラルネットワーク（回帰）\n\nより機械学習的に、予測的な回帰を行う方法が、**ニューラルネットワーク（Neural Network）**です。ニューラルネットワークはその名の通り、神経細胞の構造を真似たような形でデータを学習し、予測を行うことができる手法です。ニューラルネットワークには回帰の他に、分類も行うことができます。分類に関するニューラルネットワークについては、[次の章](./chapter27.html)で説明します。\n\nニューラルネットワークは今（2023年）をときめくChatGPTなどの生成AIの根幹技術の一つで、ニューラルネットワークを発展させたディープニューラルネットワーク（DNN）が生成AIの一部に用いられています。\n\n:::{.callout-tip collapse=\"true\"}\n\n## ニューラルネットワークの仕組み\n\nニューラルネットワークの基本単位は、**単純パーセプトロン**と呼ばれるものです。単純パーセプトロンとは以下の図で示すように、a~1~、a~2~、a~3~のデータが与えられたとき、それぞれのデータに**重み（w）**を掛け、**バイアス（b）**を足したものです。\n\n![](./image/perceptron.png){width=50%}\n\nただし、このYを求めるときにデータの変換を行います。この変換を行うための関数のことを**活性化関数**と呼びます。活性化関数にはソフトマックス変換やロジスティック変換、Relu（Yが0以下なら0、Yが0より大きければYをそのままとする式）を用いるのが一般的です。\n\nソフトマックス変換\n$$\\sigma(z_k)=\\frac{exp(z_k)}{\\sum^{n}_{i=1}exp(z_i)}$$\n\nロジスティック変換\n\n$$Y=\\frac{1}{1+exp(-(w_{1}a_{1}+w_{2}a_{2}+w_{3}a_{3}+b))}$$\n\nReluでの変換\n\n$$\\left\\{\\begin{align*}Y = 0 \\quad (Y \\leqq 0) \\\\ Y = w_{1}a_{1}+w_{2}a_{2}+w_{3}a_{3}+b \\quad (Y > 0)\\end{align*}\\right.$$\n\nこの単純パーセプトロンで回帰も分類もできるのですが、複雑な問題には対応できません。単純パーセプトロンを組み合わせ、積み重ねたものがニューラルネットワークです。\n\n![](./image/neuralnetwork.png)\n\nニューラルネットワークは単純パーセプトロンを組み合わせ、入力層、中間層、出力層の各層としたものです。このニューラルネットワークを用いることで、複雑な回帰や分類にも対応することができます。学習の過程で重みやバイアスが計算されますが、この計算にはバックプロパゲーションと呼ばれる方法が用いられています。このバックプロパゲーションによる計算にはたくさんの行列演算が含まれるため、行列演算をたくさん行うことが得意なGPUが学習に用いられています。\n\nこのニューラルネットワークの中間層を更に積み重ね、途中で畳み込みやプーリングと呼ばれるデータの変換を用いたもののことをディープニューラルネットワーク（DNN）と呼びます。DNNでは入力層が数万～数十億、中間層が数十層となる場合もあり、非常に複雑な分類問題を予測することが可能です。現在AIと呼ばれているものは、このDNNに強化学習を組み合わせた大規模言語モデル（LLM）と呼ばれるもので、入出力をヒトに見やすい形にしたものだと思います。\n\n:::\n\nRでニューラルネットワークを用いる場合には、[neuralnet](https://cran.r-project.org/web/packages/neuralnet/index.html)パッケージ[@neuralnet_bib]の`neuralnet`関数を用います。`neuralnet`関数はformulaを引数に取る関数ですので、まず`iris`のデータを用いてformulaを準備します。formulaの形は`lm`関数などと同じで、`目的変数~説明変数`の形で準備します。\n\n```{r, filename=\"ニューラルネットワーク：formulaの準備\"}\npacman::p_load(neuralnet)\nformula_iris <- \n  as.formula(\n    \"Sepal.Length ~\n      Sepal.Width +\n      Petal.Length +\n      Petal.Width +\n      Species\"\n  )\n```\n\n`neuralnet`関数は、この`formula`の他に、`data`、隠れ層（`hidden`）、活性化関数（`act.fct`）を引数に取ります。隠れ層とは、ニューラルネットワークの中間層のことを指します。以下の式では、隠れ層としてパーセプトロン3つ、3つの2層をベクター（`c(3,3)`）で設定しています。\n\n`neuralnet`関数の返り値を`plot`すると、各入力に対する重みとバイアスを図で表示してくれます。黒の数値が重みで、青の数値はバイアスを示します。\n\n```{r, filename=\"neuralnet関数で2層ニューラルネットワークを計算\"}\n# 2層（nodeが3、3）\nset.seed(0)\n\n# 説明変数はスケーリングする\niris_scale <- scale(iris[, 2:4]) |> as.data.frame()\n\n# 種は―1～1にスケーリング\niris_scale$Species <- iris$Species |> as.numeric() - 2 \n\n# 目的変数は0～1にスケーリング\niris_scale$Sepal.Length <-\n  (iris$Sepal.Length - min(iris$Sepal.Length)) / (max(iris$Sepal.Length) - min(iris$Sepal.Length))\n\n\nnn_iris <- neuralnet(\n  formula = formula_iris,\n  data = iris_scale,\n  hidden = c(3, 3),\n  act.fct = \"logistic\", # ソフトマックス（この他に\"tanh\"を選べる）\n  linear.output = T # 出力層に活性化関数を適用するかどうか\n)\nplot(nn_iris, rep = \"best\")\n```\n\n同様に、パーセプトロンが2個、3個、2個のニューラルネットワークを計算する場合には、`hidden=c(2,3,2)`と隠れ層を設定します。\n\n```{r, filename=\"neuralnet関数で3層ニューラルネットワークを計算\"}\n# 3層（nodeが2、3、2）\nset.seed(0)\nnn_iris2 <- neuralnet(\n  formula = formula_iris,\n  data = iris_scale,\n  hidden = c(2, 3, 2),\n  act.fct = \"logistic\", \n  linear.output = T\n)\nplot(nn_iris2, rep = \"best\")\n```\n\n`neuralnet`関数の返り値を`predict`関数の引数にすることで、予測を行うことができます。ただし、データをあらかじめスケーリングしていること、活性化関数がソフトマックスであることから、計算結果は0～1までの値として得られます。この予測値をうまく変換してやれば、元の値を評価することができます。下のニューラルネットワークの構造では悪くはないのですが、正確には予測できていないことがわかります。このような場合には、データ変換の方法、隠れ層や活性化関数、その他の引数を最適化する必要があります。\n\n```{r, filename=\"neuralnet関数の返り値で予測\"}\nnn_iris3 <- neuralnet(\n  formula = formula_iris,\n  data = iris_scale,\n  hidden = c(4, 4),\n  act.fct = \"logistic\", \n  linear.output = T \n)\n\n# 上のニューラルネットワークで予測する\npredict(nn_iris3, iris_scale[1:5,])\n\n# 予測値と実際の値の比較\npred_real <- data.frame(\n  # 予測値を変換\n  prediction = predict(nn_iris3, iris_scale[1:50,]) * (max(iris$Sepal.Length) - min(iris$Sepal.Length)) + min(iris$Sepal.Length),\n  real_value = iris$Sepal.Length[1:50] # 実際の値\n)\n\nplot(pred_real)\n```\n\nニューラルネットワークに関する他のパッケージには、[nnet](https://cran.r-project.org/web/packages/nnet/index.html)パッケージ [@nnet_bib]があります。\n\n:::{.callout-tip collapse=\"true\"}\n\n## Rでディープニューラルネットワーク\n\n現代の機械学習やディープニューラルネットワークのほとんどのパッケージはPythonのライブラリとして提供されています。Rでは、これらのPythonのライブラリを用いたRのライブラリを用いることで、Pythonでできるようなディープニューラルネットワークの手法を用いることができるようになっています。\n\nPythonの機械学習プラットフォームである[Tensorflow](https://www.tensorflow.org/?hl=ja)をRから利用する[tensorflow](https://tensorflow.rstudio.com/)パッケージ、Tensorflowのニューラルネットワークライブラリである[Keras](https://keras.io/)をRから利用する[keras](https://cran.r-project.org/web/packages/keras/index.html)パッケージ、RからPythonのニューラルネットワークライブラリである[Pytorch](https://pytorch.org/)を利用するためのライブラリである[torch](https://torch.mlverse.org/)などを用いることで、Rでもディープニューラルネットワークを試すことができます。\n\n:::\n\n## カーネル密度推定\n\nカーネル密度推定は、データの分布をカーネル密度という、滑らかな曲線に変換する手法です。Rにはこのカーネル密度を表示するための手法がたくさん存在します。その一つが[20章](./chapter20.html)で説明した`density`関数です。`density`関数の引数にベクターを与えるとカーネル密度を計算してくれます。この`density`関数の返り値を`plot`関数の引数にすると、カーネル密度をグラフにしてくれます。\n\n同様のグラフは[ggplot2](./chapter21.html)の`geom_density`関数を用いても描画できます。カーネル密度の計算は[KernSmooth](https://cran.r-project.org/web/packages/KernSmooth/index.html)パッケージ [@KernSmooth_bib]の`bkde`関数を用いても計算することができます。\n\n```{r, filename=\"カーネル密度推定\"}\n# カーネル回帰\nhead(faithful)\nx <- faithful$waiting\n\nhist(x, xlim = c(40, 100))\npar(new  =T)\ndensity(x) |> plot(xlim = c(40, 100), main = \"\", xlab = \"\", ylab = \"\", axes = FALSE)\n\n# KernSmooth::bkde関数を用いる方法\npacman::p_load(KernSmooth)\nest <- bkde(faithful$waiting, bandwidth = 3) %>% as.data.frame\nggplot()+\n  geom_line(data = est, aes(x = x, y = y*950))+\n  geom_histogram(data = faithful, aes(x = waiting, fill = 1), alpha = 0.5)+\n  theme(legend.position = \"none\")\n```\n\n## 非線形最小二乗法：nls関数\n\n上記のガウス回帰過程やニューラルネットワーク、カーネル密度推定とは異なる非線形の回帰の方法として、非線形最小二乗法というものがあります。この非線形最小二乗法では、線形回帰と同様に2乗誤差を最小とすることで回帰を行う方法ですが、求めるパラメータは切片や傾きのような直線性を示すものではなく、自分で設定した関数のものとなる点が異なります。線形回帰と同様に、データが正規分布することを仮定しているため、正規分布しないデータでは適切に回帰を行うことができません。\n\nまた、2乗誤差を最小化する問題（最適化問題）を解く方法として、[ガウス-ニュートン法](https://ja.wikipedia.org/wiki/%E3%82%AC%E3%82%A6%E3%82%B9%E3%83%BB%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3%E6%B3%95)を用いており、[局所最適化](https://jp.mathworks.com/help/optim/ug/local-vs-global-optima.html)と呼ばれる解にしか到達しない問題が起こることもあります。\n\nRで非線形最小二乗法を行うための関数が`nls`関数です。`nls`関数は引数に回帰したい関数の数式と各パラメータの初期値、データフレームを取ります。`nls`関数の使い方は`lm`関数とよく似ていて、`summary`関数を用いれば計算結果の詳細を、`predict`関数を用いれば回帰からの予測を得ることができます。\n\n```{r, filename=\"nls関数で非線形最小二乗法\"}\nDNase1 <- subset(DNase, Run == 1)\nplot(density ~ conc, data = DNase1)\n\n# SSlogis関数は初期値を自動設定してくれる（self start）nlsのロジスティック回帰用の関数\nfm1DNase1 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1) \n# Asymは漸近線を示すパラメータ、xmidは変曲点のx軸の値を示すパラメータ、\n# scalはスケールパラメータ\nsummary(fm1DNase1)\n\n# predict関数で予測することができる\npredict(fm1DNase1, data.frame(conc = seq(0, 12, by=0.1))) |> head()\n\n# 回帰結果のグラフ\nd <- data.frame(conc = seq(0, 12, by=0.1), pred = predict(fm1DNase1, data.frame(conc = seq(0, 12, by = 0.1))))\nggplot()+\n  geom_point(data = DNase1, aes(x = conc, y = density, color = \"#F8766D\"))+\n  geom_line(data = d, aes(x = conc, y = pred), color = \"#00BFC4\")+\n  theme(legend.position = \"none\")\n```\n\n## LOESS・LOWESS平滑化\n\nLOESS平滑化（locally estimated scatterplot smoothing）とLOWESS平滑化（Locally Weighted Scatterplot Smoothing）はどちらも局所回帰と呼ばれる手法を指しており、部分的な回帰をつなぎ合わせて全体として1つの回帰を行う手法です。部分的な回帰には多項式回帰を用いるのが一般的です。多項式回帰と多項式回帰をつなぎ合わせることで、全体として滑らかな曲線でデータを表現することができます。\n\nRでは、`loess`関数でLOESS平滑化、`lowess`関数を用いてLOWESS平滑化の計算を行います。どちらも同じ計算を行う関数ですが、関数の使い方が少し異なります。`loess`関数は`loess`オブジェクトを返す関数で、`predict`関数を用いて予測値を計算する形になっています。また、平滑化の幅を指定する`span`引数を設定することで、より細かな値の変動に対応した平滑化を行うこともできます。\n\n```{r, filename=\"LOESS平滑化\"}\nloess_cars <- loess(dist ~ speed, data = cars) # spanのデフォルト値は0.75\nsummary(loess_cars)\n\nloess_cars2 <- loess(dist ~ speed, cars, span = 0.3) # spanを短く設定\n\n# 赤がspan=0.75、青がspan=0.3\nplot(cars, xlim = c(0, 30), ylim = c(0, 120))\npar(new = T)\nplot(\n  seq(5, 30, by = 0.1), \n  predict(loess_cars, data.frame(speed = seq(5, 30, by = 0.1))), \n  type = \"l\", \n  xlim = c(0, 30), \n  ylim = c(0, 120),\n  xlab = \"\",\n  ylab = \"\",\n  col = 2)\npar(new = T)\nplot(\n  seq(5, 30, by = 0.1), \n  predict(loess_cars2, data.frame(speed = seq(5, 30, by = 0.1))), \n  type = \"l\", \n  xlim = c(0, 30), \n  ylim = c(0, 120),\n  xlab = \"\",\n  ylab = \"\",\n  col = 5)\n```\n\n`lowess`関数は平滑化後の`x`と`y`のセットをリストとして返す関数で、`plot`関数や`lines`関数の引数に取ることで平滑化した線を描画することができます。平滑化計算における説明変数側の値の幅は`delta`引数で指定します。デフォルトでは横軸を100分割して平滑化することになっています。部分最適化の幅を指定する引数が`f`で、`f`に小さい値を指定することで、より細かな値の変動を捉えることができます。\n\n`loess`、`lowess`のどちらを使っても結果自体には大差はありませんが、`loess`関数の方が予測値の融通が利きやすい仕様になっています。\n\n```{r, filename=\"LOWESS平滑化\"}\nlowess(cars) # 返り値は同じ長さのxとyのリストになる\n\nplot(cars, main = \"lowess(cars)\")\nlines(lowess(cars), col = 2)\nlines(lowess(cars, f = 0.1), col = 5) # 部分最適化の幅を狭くする\n```\n\n## spline回帰\n\n**spline回帰**は、loessと似ていますが、多項式の関数（2次関数や3次関数など）でデータを各部分ごとに回帰し、その多項式の微分値が一致する部分で滑らかにつなぐことで、全体として平滑な曲線で回帰する、非線形の回帰の方法です。spline回帰はLOESS平滑化とは計算のアルゴリズムが異なります。\n\nspline回帰のイメージを以下の図に示します。点で示されているデータを赤と青の2つの2次関数で回帰し、微分値が同じになる点（赤と青の境目）でつなぎ合わせて滑らかな1つの線にしています。このつなぎ目のことをknot（結び目）と呼びます。\n\n```{r, echo=FALSE}\nx <- seq(-10, 10, by=0.05)\ny <- 3 * x^2\nd <- data.frame(x, y)\n\n\nx2 <- seq(0, 20, by=0.05)\ny2 <- -1.5 * (x2 - 15)^2 + 225\nd2 <- data.frame(x2, y2)\n\n\nset.seed(2)\nd3 <- data.frame(\n  x = seq(-10, 20, by=2), \n  y = c(3 * seq(-10, 5, by=2) ^ 2 + rnorm(8, 0, 25),\n        -1.5 * (seq(5, 20, by=2) - 15)^2 + 225 + rnorm(8, 0, 25)\n    ))\n\nplot(d3,  \n  xlim=c(-10, 20), \n  ylim=c(-112.5, 300),\n  main=\"spline平滑化のイメージ\",\n  cex = 2,\n  pch = 19)\npar(new=T)\nplot(\n  d |> filter(x <= 5) |> _$x, \n  d |> filter(x <= 5) |> _$y,  \n  xlim=c(-10, 20), \n  ylim=c(-112.5, 300), \n  type=\"l\", \n  col=2,\n  lwd=4, xlab=\"\", ylab=\"\")\npar(new=T)\nplot(\n  d |> filter(x > 5) |> _$x, \n  d |> filter(x > 5) |> _$y,  \n  xlim=c(-10, 20), \n  ylim=c(-112.5, 300), \n  type=\"l\", \n  col=2,\n  lwd=0.5, xlab=\"\", ylab=\"\")\npar(new=T)\nplot(\n  d2 |> filter(x2 > 5) |> _$x2, \n  d2 |> filter(x2 > 5) |> _$y2,  \n  xlim=c(-10, 20), \n  ylim=c(-112.5, 300), \n  type=\"l\", \n  col=4,\n  lwd=4, xlab=\"\", ylab=\"\")\npar(new=T)\nplot(\n  d2 |> filter(x2 <= 5) |> _$x2, \n  d2 |> filter(x2 <= 5) |> _$y2,  \n  xlim=c(-10, 20), \n  ylim=c(-112.5, 300), \n  type=\"l\", \n  col=4,\n  lwd=0.5, xlab=\"\", ylab=\"\")\n```\n\nRでspline回帰を行う際には、`smooth.spline`関数を用います。`smooth.spline`関数は`x`（説明変数）、`y`（目的変数）をそれぞれ引数に取り、`smooth.spline`クラスのオブジェクトを返す関数です。\n\n`smooth.spline`関数ではcubic smoothing spline（3次スプライン）という、3次関数を滑らかにつなぎ合わせたspline回帰を行います。このcubic smoothing splineでは、knotとknotの間ごとに3次関数への回帰が最小二乗法で計算されます。ただし、この回帰においては、曲線の曲がり具合（wiggliness）が大きいとペナルティがつくような最小二乗法の計算が行われます。ペナルティの大きさはGCV（Generalized Cross Varidation）という手法で自動的に設定されます。別途`penalty`変数に数値を設定すると、ペナルティの大きさを調整することができます。大きめの`penalty`を設定すればより滑らかな、小さめの`penalty`を設定すればより曲がりくねった形の回帰となります。\n\nまた、cubic smoothing splineでは、knotの位置をあらかじめ設定しておく必要があります。`smooth.spline`関数ではknotの数は自動的に設定される仕組みになっています。\n\n```{r, filename=\"spline回帰\"}\nBJsales_d <- as.data.frame(BJsales) |> mutate(time = 1:150)\n\n# スプライン曲線の計算（ペナルティを1.4に設定）、結果にはGCVの結果などが表示される\nsmooth.spline(BJsales_d$time, BJsales_d$x, penalty = 1.4)\n\n# 黒線が生データ、赤線がスプライン曲線\nplot(BJsales, col = 1, xlim = c(0, 150), ylim = c(200, 260))\npar(new = T)\nsmooth.spline(BJsales_d$time, BJsales_d$x, penalty = 1.4) |> \n  plot(type = \"l\", col = 2, xlim = c(0, 150), ylim = c(200, 260), xlab = \"\", ylab = \"\")\n```\n\n## 加法モデル（additive model）\n\n上記のように、説明変数が1つ、従属変数が1つの場合には、`smooth.spline`関数を用いた回帰により、滑らかな非線形回帰を行うことができます。このspline回帰を説明変数が複数の場合、つまり重回帰のような場合に拡張したものが**加法モデル**（additive model）です。\n\n加法モデルのいいところは、説明変数に対して目的変数が直線的な関係でなくても回帰が行えるということです。上述の線形モデルでは、単調増加・単調減少の現象を取り扱い、回帰する線は直線・指数関数・ロジスティック関数の主に3つとなります。しかし、実際の現象では説明変数に最適値があったり、目的変数が飽和するようなパターンも多くみられます。このような現象に対しては線形モデルではなく、非線形である加法モデルを用いた方がうまく説明できる可能性があります。ただし、説明変数に対する傾きを数値で示すことはできないため、結果の解釈は難しくなります。\n\nRでは、加法モデルの計算に`mgcv`パッケージ[@mgcv1_bib; @mgcv2_bib; @mgcv3_bib; @mgcv4_bib; @mgcv5_bib]を用います。`mgcv`では、主に3種類のspline回帰を用いて複雑な非線形回帰に対応します。\n\n- cubic regression spline：上記の`smooth.spline`で用いられているものと同じものです。knotの間隔はデフォルトでは説明変数の幅を10分割する形で設定されます。knotの位置を最適化すれば、非常に滑らかな非線形回帰を行うことができます。\n- thin plate regression spline：cubic regression splineと同じく3次関数で非線形回帰を行うspline回帰ですが、knotの位置が自動的に最適化される点が異なります。計算が重く、データ数が多いと時間がかかります。\n- tensor product spline：複数の説明変数に対して、多次元的なspline回帰を行うための手法です。thin plate regression splineよりも計算が軽いため、データが多い場合に適しています。\n\n`mgcv`のデフォルトのspline回帰の手法はthin plate regression splineです。thin plate regression splineはthin plate splineと呼ばれる手法の計算量を小さくしたものです。thin plate spline自体は計算量が大きすぎて使いにくいため、`mgcv`では対応していません。この他にB-splineやP-splineなどの、別のsplineの手法を用いることもできますが、特に理由がない限り使用する必要はないでしょう。thin plate splineに関しては[こちらの小林景先生（慶應義塾理工学部）のページ](https://www.math.keio.ac.jp/~kei/GDS/2nd/spline.html)に詳しく記載されています。\n\n回帰の計算をペナルティ付き最小二乗法で計算する点も`smooth.spline`関数と同じです。ペナルティ付き最小二乗法はP-IRLS（Iteratively Reweighted Least Squares）と呼ばれる繰り返し計算手法で計算します。\n\nペナルティ付き最小二乗法のペナルティの大きさは`smooth.spline`と同じくGCVか、UBRE（Un-biased Risk Estimator）と呼ばれる手法のどちらかで計算されます。特に手法を指定しない場合にはGCVによりGCV-scoreが計算され、GCV-scoreを最小化するペナルティの大きさが決定されます。\n\n### 一般化加法モデル（Generalized Additive Model、GAM）\n\n線形モデル（LM）に対して一般化線形モデル（GLM）があるのと同様に、加法モデル（AM）に対しては**一般化加法モデル（Generalized Additive Model、GAM）**があります。\n\n加法モデルでは、目的変数が正規分布すると仮定してspline曲線による非線形重回帰を行います。この目的変数の分布を正規分布以外に拡張したものが、一般化加法モデル（GAM）です。目的変数が正規分布することを仮定する加法モデルではペナルティ付き最小二乗法でsplineを求めますが、一般化加法モデルではペナルティ付き最尤法でsplineを求めます。\n\n一般化加法モデルでは、一般化線形モデルのように目的変数の分布（family）とリンク関数（link）を指定します。GLMと同様に目的変数の分布とリンク関数はセットになっているため、familyを設定すれば、リンク関数を別途設定する必要はありません。\n\n### mgcvでGAMを計算する\n\n`mgcv`パッケージでは、`gam`関数を用いてGAMを計算することができます。`gam`関数の使い方は`glm`関数によく似ていますが、説明変数の設定方法が異なります。\n\n`mgcv`パッケージでspline回帰による回帰を行う場合には、説明変数を`s`関数の引数に取ります。\n\n以下の例では、31本のブラックチェリー（Purnus serotina）のデータ（`trees`）において高さ（`Height`）と直径（`Girth`）から幹の体積（`Volume`）を求める演算をGAMで行っています。説明変数である`Height`と`Girth`は`s`関数の引数に指定しています。`glm`関数と同じく、データはデータフレームとして、`data`引数に指定します。このように指定することで、目的変数-説明変数の関係をsplineによる非線形として設定することができます。`s`関数内で特に引数を指定しない場合には、thin plate regression splineによる計算が行われます。\n\n`gam`関数の返り値を`plot`関数の引数に指定することで、各説明変数と目的変数の関係をグラフで示すことができます。グラフの実線は推定値で、点線は信頼区間を示します。x軸に示されている短い縦線はデータの位置を示しています。\n\n```{r, filename=\"gam関数で一般化加法モデルを計算\"}\npacman::p_load(mgcv)\n\ngam_trees <- gam(Volume ~ s(Girth) + s(Height), data = trees)\n\nsummary(gam_trees)\n\npar(mfrow = c(1, 2))\nplot(gam_trees)\n```\n\nグラフの縦軸ラベルに記載されている数値はsplineの自由度です。GAMでは自由度が非常に重要な要素の一つで、spline曲線で用いられている係数などの数を反映しています。自由度が大きすぎると過学習である可能性があります。一方で、周期性のある時系列データなどでは、自由度が小さいと結果を十分に説明できなくなるため、自由度がある程度大きい必要があります。`s`関数ではデフォルトの自由度の最大値として10が設定されています。自由度の最大値は`s`関数内で`k`引数を指定することで変更することができます。\n\nまた、説明変数と目的変数の関係が線形であることが分かっている場合には、`s`関数の引数とせずにつなぐことで、その説明変数のみsplineとすることなくモデルに組み込むことができます。\n\n```{r, filename=\"heightのみ線形として演算する\"}\ngam_trees1 <- gam(Volume ~ s(Girth) + Height, data = trees)\n\n# 線形の成分はplot関数では表示されない\nplot(gam_trees1)\n```\n\n\n### bs引数でsplineの種類を指定する\n\n以下の例では、1973年のNYの大気汚染データ（`airquality`）のうち、オゾン量（`Ozone`）を目的変数、日照（`Solar.R`）、風量（`Wind`）、気温（`Temp`）、5月1日からの日数（`days`）を説明変数とするGAMの計算を行っています。\n\n```{r, filename=\"airqualityのデータをGAMで計算\"}\npacman::p_load(mgcv)\n\naq <- airquality |> mutate(days = 1:nrow(airquality)) # 前準備\n\n# GAMの演算\nresult_gam <- gam(Ozone ~ s(Solar.R) + s(Wind) + s(Temp) + s(days), data = aq)\n\npar(mfrow = c(2,2))\nplot(result_gam, select = 1);plot(result_gam, select = 2)\nplot(result_gam, select = 3);plot(result_gam, select = 4)\n```\n\n上の結果では、`days`の回帰結果がほぼ一定に見えます。つまり、`days`は`Ozone`にほとんど影響を与えていないように見えます。このような説明変数は、GLMのモデル選択やスパース回帰では取り除かれる可能性があります。\n\nGAMの結果に`step`関数によるモデル選択を適用することはできません。`gam`では、`step`関数の代わりに、`s`関数内で引数を指定することにより、モデル選択ができるようにしています。\n\n`s`関数の`bs`引数は通常splineの手法を指定するための引数です。`bs=\"cr\"`でcubic regression spline、`bs=\"tp\"`でthin plate regression splineを指定することができます（tensor product splineには`s`とは別の関数が準備されています。後ほど説明します）。`bs`引数に指定可能な手法は`?smooth.terms`（もしくは[こちらのページ](https://stat.ethz.ch/R-manual/R-patched/RHOME/library/mgcv/html/smooth.terms.html)）にまとめられています。また、cubic regression splineを選択した場合には、knotの位置を`knot`引数で設定することもできます（thin plate regression splineを用いる場合には原理的に`knot`を設定する必要がありません）。\n\nこの`bs`引数に指定できる手法のうちには、「shrinkageが可能な手法」、というものが含まれています。このshrinkageというのは、`s`関数の結果をほぼ0とする、つまりスパース回帰のように説明変数を取り除くことができるようにすることを意味します。shrinkageが可能な手法は`\"cs\"`（cubic regression splineでshrinkage可能な手法）と`\"ts\"`（thin plate regression splineでshrinkage可能な手法）の2つです。`s`関数内で`bs=\"cs\"`もしくは`bs=\"ts\"`を指定することで、その説明変数が目的変数に影響を与えていない場合には説明変数からある程度取り除くことができます。\n\nただし、`step`関数やスパース回帰のようには説明変数をうまく取り除けないので、AICなどを用いたモデル選択も行うことになります。`lm`や`glm`と同じく、`AIC`関数の引数に`gam`の返り値を取ることでAICを計算することができます。\n\n同様に、`bs`引数にはcyclicな、始めと終わりの値が同じとなるsplineを指定することもできます。代表的なcyclicな方法は`\"cc\"`（cubic regression splineのcyclic版）です。時系列などで、ある一定の時期ごとに同じ値に戻るような場合には、`bs=\"cc\"`と指定することでより単純で分かりやすいモデルを選択することができます。\n\n```{r, filename=\"shrinkage可能な手法を用いる\"}\nresult_gam2 <- \n  gam(\n    Ozone ~ \n      s(Solar.R, bs = \"ts\") + \n      s(Wind, bs = \"ts\") + \n      s(Temp, bs = \"ts\") + \n      s(days, bs = \"ts\"), \n    data = aq)\n\nplot(result_gam, select = 4) # daysは残っているが、0付近に集まる\n\n# tsのモデルの方がわずかにAICが小さい\nAIC(result_gam)\nAIC(result_gam2)\n```\n\n### s関数に2つの説明変数を含める\n\n上記の例では、`s`関数それぞれに説明変数を設定していましたが、`s`関数には2つ以上の説明変数を同時に設定することもできます。下の例では、3つの説明変数を`s`関数の引数に指定しています。このように指定することで、多次元のスプラインを用いてGAMの計算を行うことができます。\n\nまた、このように複数の説明変数を一度にスプライン回帰する場合には、tensor product splineを用いることで計算コストを小さくすることができます。tensor product splineを用いる場合には、`s`関数の代わりに、`t2`関数を用います。\n\nただし、`summary`関数の結果を見るとわかる通り、複数の説明変数を用いたスプラインを作成すると、結果の解釈はより難しくなる傾向があります。\n\n```{r, filename=\"複数の説明変数を用いたスプライン\"}\n# thin plate regression splineで複数の説明変数を加える\ngam_trees2 <- gam(Volume ~ s(Girth, Height, k = 4), data = trees)\n\n# tensor product splineで複数の説明変数のsplineを作成\ngam_trees3 <- gam(Volume ~ te(Girth, Height), data = trees)\n\nsummary(gam_trees2)\nsummary(gam_trees3)\n\n# thin plate regression splineでAICが最も小さい\nAIC(gam_trees) # thin plate regression spline\nAIC(gam_trees2) # thin plate regression spline（複数の説明変数をs関数に含める）\nAIC(gam_trees3) # tensor product spline\n```\n\n### ペナルティの調整\n\nペナルティを調整する場合には、`gamma`引数を指定します。`gamma`引数のデフォルトは1で、大きくするとより滑らかな、小さくするとより曲がりくねった結果が得られます。[教科書](https://www.amazon.co.jp/-/en/Simon-N-Wood/dp/1498728332)[@mgcv4_bib]では、この`gamma`を`1.4`に指定するのがよいとされていますので、デフォルトの`gam`関数ではやや曲がりくねった結果を得られやすいことになります。\n\n```{r, filename=\"ペナルティをgammaで調整する\"}\n# gammaを1.4に指定する\nresult_gam3 <- \n  gam(\n    Ozone ~ \n      s(Solar.R) + s(Wind) + s(Temp), \n    data = aq,\n    gamma = 1.4)\n\n# gammaを0.1に指定する\nresult_gam4 <- \n  gam(\n    Ozone ~ \n      s(Solar.R) + s(Wind) + s(Temp), \n    data = aq,\n    gamma = 0.1)\n\n# 左（gamma = 1.4）は滑らか、右（gamma = 0.1）は曲がりくねった結果になる\npar(mfrow = c(1, 2))\nplot(result_gam3, select = 1)\nplot(result_gam4, select = 1)\n```\n\n### by引数\n\n`s`関数内では`by`引数に説明変数を設定することができます。例えばAが目的変数、BとCが説明変数の場合に、`gam(A~s(B, by=C))`と設定すると、数式モデルとしては以下のように、Bによるスプライン回帰にCを掛けた形での回帰を行うことになります。\n\n$$A=f(B) \\cdot C + \\epsilon$$\n\nf(x)はスプライン回帰の式を示します。この`by`引数の使い方はわかりにくいのですが、例えば地域ごとの経済状況を非線形回帰する場合に、国によって施策が異なり、国境線を境に大きく経済状況が異なる場合、その施策の有り・無しを1と0の説明変数として`by`引数に設定すれば、施策の効果を評価した上での回帰を行うことができます。\n\n```{r, filename=\"by引数を設定して評価する\", eval=FALSE}\nresult_gam7 <- \n  gam(\n    Ozone ~ \n      s(Solar.R, by = days), \n    data = aq)\n```\n\n### predict関数で予測する\n\n`lm`や`glm`と同様に、`gam`でも`predict`関数により結果の予測値を出力することができます。`predict`関数の使い方も`lm`や`glm`と類似していて、回帰のオブジェクト（`gam`オブジェクト）と予測したいデータを含むデータフレームを引数に取ります。また、標準誤差は引数に`se.fit=TRUE`と設定することで計算することができます。\n\n```{r, message=FALSE, warning=FALSE, filename=\"predict関数での予測\"}\nresult_gam2d <- \n  gam(\n    Ozone ~ \n      s(Solar.R) + s(Wind), \n    data = aq)\n\nd <- \n  expand.grid(\n    Solar.R = seq(7, 334, by = 1),\n    Wind = seq(1.7, 20.7, by = 0.1)\n  )\n\npredict(result_gam2d, d) |> head(5) # ベクターが返ってくる\n\nd.pred <- cbind(d, pred = predict(result_gam2d, d))\n\n# 回帰結果は曲面として得られる（下の図は点の集合になっている）\nd.pred |> \n  plotly::plot_ly(\n    x = ~Solar.R, y=~Wind, z=~pred, size=0.1, color=~pred\n  )\n```\n\n加法モデルについては、こちらの[東京大学の資料](https://ibis.t.u-tokyo.ac.jp/suzuki/lecture/2015/dataanalysis/L12.pdf)も参考になりますので、一読されるとよいでしょう。\n\n### 一般化加法混合モデル（GAMM）\n\n線形モデルに対して線形混合モデル、一般化線形モデルに対して一般化線形混合モデルがあるように、一般化加法モデルに対しては**一般化加法混合モデル**（Generalized Additive Mixed Model、GAMM）があります。\n\n一般化線形混合モデルでは`lme4`や`lmerTest`などのライブラリが必要でしたが、GAMMは`mgcv`パッケージの`gam`関数を用いて計算することができます。\n\n`gam`関数内では、ランダム効果となる説明変数を`s`関数内で宣言し、`bs=\"re\"`を引数として設定します。`lmerTest`のように`|`を使ってランダム効果を設定する必要はありません。\n\nGAMMについては[論文](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6542350/pdf/peerj-07-6876.pdf)[@pedersen2019hierarchical]に詳しく記載されていますので、一読されることをおすすめいたします。\n\n```{r, filename=\"一般化加法混合モデル：GAMM\"}\n# Pedersen et al. (2019)に記載の例 https://peerj.com/articles/6876/#supplemental-information\nCO2 |> head(5)\n\nplot(CO2)\n\nCO2 <- transform(CO2, Plant_uo = factor(Plant, ordered = FALSE))\n\nCO2_modG <- \n  gam(\n    log(uptake) ~ \n      s(log(conc), k = 5, bs = \"tp\") + \n      s(Plant_uo, k = 12, bs = \"re\"), # reはランダム効果\n    data = CO2, \n    method = \"REML\", \n    family = \"gaussian\")\n```\n\n結果の表示には`gratia`パッケージ[@gratia_bib]を用いてみます。`gratia`は`gam`の結果を`ggplot2`ベースのグラフにしてくれるライブラリです。\n\n```{r, filename=\"GAMMの結果をプロットする\"}\npacman::p_load(gratia) # グラフをggplot2準拠にするパッケージ\ndraw(CO2_modG) # concの効果をプロット\n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"chapter26.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","lightbox":"auto","bibliography":["references.bib"],"editor":"source","theme":{"light":"united","dark":"cyborg"},"toc-expand":2,"code-block-bg":true,"code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}