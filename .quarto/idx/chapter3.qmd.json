{"title":"オブジェクトと変数・定数","markdown":{"headingText":"オブジェクトと変数・定数","containsRefs":false,"markdown":"\n```{r, setup, include=FALSE, echo=FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE\n)\n```\n\n\n## プログラミング言語としてのR\n\nR言語は統計の計算を行うために開発されたプログラミング言語です。プログラミング言語としての仕様は[S言語](https://ja.wikipedia.org/wiki/S%E8%A8%80%E8%AA%9E)という、[ベル研究所](https://www.bell-labs.com/)によって開発された言語を参考としています。R言語は、「動的型付け、型推論、インタプリタ型、オブジェクト指向の関数型言語」というタイプのプログラミング言語です。プログラミング未体験の方にはすべての単語が意味不明だと思いますが、単語の意味については順々に紹介していきます。\n\nまずは、**「インタプリタ」**について説明します。インタプリタとは、プログラムをコンパイルすることなく実行することができる環境のことを指します。\n\nこの、**「コンパイル」**というのは、プログラムを機械語に置き換える変換のことを指します。\n\n**「機械語」**というのも聞き覚えがない言葉だと思います。機械語とは、コンピュータが読み取れる、1と0だけからなる数字の列のことです。コンピュータは我々の言語や画像などをそのまま処理することはできず、1ビット単位（1と0）の情報だけを取り扱うことができます。プログラミング言語のうち、例えばCやJavaでは、プログラムはまず機械語に変換、コンパイルされます。コンパイルされたプログラムだけがコンピュータ上で実行できます（下図1）。\n\n![図1：コンパイルと機械語への変換](./image/compile.png)\n\n一方、インタプリタ型の言語では、プログラミング言語をコンパイルすることなく実行することができます。インタプリタ型の言語には[Python](https://www.python.org/)や[Ruby](https://www.ruby-lang.org/ja/)、[PHP](https://www.php.net/)などがあります。コンパイルには通常時間がかかりますが、インタプリタ型言語ではコンパイルに時間をかけることなく、すぐにプログラムを実行することができるというメリットがあります。一方で、コンパイルを除いたプログラムを実行・完了するまでの時間はコンパイルを行うプログラミング言語よりも長くなるというデメリットもあります。\n\nRはインタプリタ型の言語ですので、記述したプログラム（スクリプトとも呼びます）はすぐに実行されます。一方で、Rでの計算速度はインタプリタ型言語の中でもかなり遅い部類に入ります。ただし、Rは主にad hocな（その場一回限りの）統計解析に用いられる言語です。1回限りであれば、それほど計算が早くなくても問題とはなりませんし、入力したプログラムがすぐに実行されるという性質も統計解析との相性がよいものです。コンピュータの性能も昔より遥かに高くなっており、R言語での計算が遅いと感じることは減ってきています。\n\n## オブジェクトとは？\n\nRは**オブジェクト指向（Object oriented）**の言語である、とされています。この**「オブジェクト指向」**という言葉はプログラミング言語ではよく用いられるものですが、厳密な定義は複雑です。\n\nこの**オブジェクト**というのは、プログラミングで取り扱う「もの」すべてを指す言葉です。プログラミングでは、**数値**や**文字**などを取り扱い、数値の演算を行ったり、文字に対して検索や置換、文字の追加などを行います。このとき、取り扱う数値や文字はオブジェクト、つまりプログラミングで用いる「もの」であるということになります。Rでは数値や文字の他に、**因子（factor）**や**論理値（booleanまたはlogical）**、**関数（function）**などを取り扱います。これらのすべてがプログラミングで取り扱う「もの」、つまりオブジェクトです。\n\n上で述べたように、プログラミングで用いるオブジェクトには数値、文字、因子、関数など、様々な種類のものがあります。数値も文字もプログラミングで扱う「もの」であることは共通していますが、数値と文字に対して同じ演算をしたい、ということは通常ありません。数値なら掛け算や割り算を行うことがあっても、文字に対して掛け算や割り算はしません。プログラミング言語も、数値なら数値の演算、文字なら文字の演算を行う必要があります。このように、数値なら数値の、文字なら文字の処理を行うために、オブジェクトには**「型（type）」**というものがあります。\n\n```{r, filename=\"型と演算の関係\", error=TRUE}\n1 * 1 # 数値同士を掛け算することがあっても、\n\n1 * \"dog\" # 数値と文字列を掛け算できてしまうと困る（エラーが出る）\n```\n\n## 型（type）とは？\n\n**型（type）**とは、そのオブジェクトの種類を定めるためのラベルのようなものです。例えば、Rで数値を入力すると、Rは自動的にその数値がnumericであると認識します。同様に、\"（ダブルクオーテーション）で文字を囲うと、Rは自動的にその文字がcharacter（文字列型）であると認識します。Rはこの認識した型に従い、そのオブジェクトに対する演算を行います。\n\nオブジェクトの型は`mode`関数で確認することができます。関数については後ほど詳しく説明します。\n\n```{r, filename=\"mode関数で型を確認する\"}\nmode(1) # 1は数値\nmode(\"Hello world\") # \"Hello world\"は文字列\nmode(\"1\") # \"1\"は文字列\n```\n\n上記のように、「`1`」の数字を`mode()`のカッコの中に入れると、numericが返ってきます。これは、`1`というオブジェクトの型がnumeric（数値）であることを示しています。同様に、ダブルクオーテーションで囲まれた`\"Hello world\"`を`mode()`のカッコに入れると、characterが返ってきます。これは、`\"Hello world\"`の型がcharacter（文字列）であることを意味しています。では、ダブルクオーテーションで囲まれた`\"1\"`がどうなるかというと、これはcharacter、つまり文字列になります。\n\nRでは、このように「ダブルクオーテーションで囲まれている」というオブジェクトの状態を調べ、囲まれていればそのオブジェクトは文字列型であると判断します。同様に、オブジェクトが「数値でかつダブルクオーテーションに囲まれていない」場合には、そのオブジェクトが数値型であると判断します。このように、プログラム上でオブジェクトの型を特に指定していなくても、Rは自動的にそのオブジェクトの型を決定してくれます。このようなプログラムの性質を**「型推論」**と呼びます。\n\nでは、Rの代表的な型について、これから簡単に説明していきます。\n\n### 文字列（character）\n\n一般的なプログラミング言語で最も取り扱うことが多いオブジェクトは**文字列型（character）**です。文字列、つまり文章などを検索したり、一部を取り出したり、条件に合っているか確認したりすることはプログラミング利用の目的の一つとなります。\n\nRは統計学のプログラミング言語ですので、どちらかというと文字列よりは数値を取り扱うことが多いのですが、文字列を取り扱える仕組みも一通り備えています。\n\nRで文字列型のオブジェクトを作成するときには、`\"`（ダブルクオーテーション）もしくは`'`（シングルクォーテーション）で文字を囲みます。ダブルクオーテーション・シングルクオーテーションのどちらを用いても文字列のオブジェクトを作成することはできます。クオーテーションが無い場合にはエラーとなります。\n\n```{r, filename=\"文字列オブジェクトの例\", error=TRUE}\n\"Hello world\" # ダブルクオーテーションで囲った場合\n\n'Hello R' # シングルクオーテーションで囲った場合\n\nHello world # エラー\n```\n\nダブルクオーテーションとシングルクオーテーションには違いはありません。どちらを用いても問題ないのですが、Rではダブルクオーテーションを用いるのが一般的です。\n\nRでは、文字列を入力すればその文字列がそのまま表示されますが、文字列の表示を明示したい場合には`print`関数を用います。\n\n```{r, filename=\"print関数\"}\nprint(\"Hello world\")\n```\n\n\n#### エスケープ文字（エスケープシーケンス）\n\nプログラミング言語によっては、ダブルクオーテーションとシングルクオーテーションで**エスケープ文字（エスケープシーケンス）**の取扱いに違いがある場合があります。エスケープシーケンスとは、バックスラッシュ（\\\\、日本語キーボードでは¥）とアルファベットを組み合わせて、特定の意味を持たせる表現のことを指します。例えば、`\\n`は改行を、`\\t`はタブを示す記号です。RではC言語由来のエスケープシーケンスを利用できます。以下の表1にエスケープシーケンスの例を挙げます。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  escapeSequence = c('\\\\a', '\\\\b', '\\\\f', '\\\\n', '\\\\r', '\\\\t', '\\\\v', '\\\\\\\\', \"\\\\\\'\", '\\\\\\\"'),\n  represent = c(\"アラート\", \"バックスペース\", \"ページ分割\", \"改行\", \"キャリッジリターン\", \"水平タブ\", \"垂直タブ\", \"バックスラッシュ\", \"シングルクオーテーション\", \"ダブルクオーテーション\")\n)\ncolnames(d) <- c(\"エスケープシーケンス\", \"エスケープシーケンスの意味\")\nknitr::kable(d, \"html\", caption=\"表1：エスケープシーケンスの例\")\n```\n\nRのデータをテキストファイルなどに書き出すときには、エスケープシーケンス、特に`\\n`（改行）や`\\t`（タブ）を用いることがあります。データ書き出しの際のエスケープシーケンスに関しては、[13章](./chapter13.html)で詳しく説明します。\n\nエスケープシーケンスを変換した文字列を表示する場合には、`writeLines`関数を用います。\n\n```{r, filename=\"writeLines関数で文字列にエスケープシーケンスを反映\"}\nwriteLines(\"Hello world\")\n\nwriteLines(\"Hello\\nworld\") # \\nは改行に変換\n\nprint(\"Hello\\nworld\") # print関数はエスケープシーケンスを変換しない\n```\n\n#### 文字列を結合する\n\nRで文字列を用いるときに、文字列Aと文字列Bをくっつけたい、ということがあります。このようなときに用いるのが、`paste`関数です。`paste`関数はカッコの中に2つ以上の文字列をコンマでつないで入れると、文字列をスペースを挟んでつなぎ合わせてくれます。文字列の間にスペースが必要ない場合には、`paste0`関数を用います。\n\n```{r, filename=\"文字列をつなぐpaste関数\"}\npaste(\"Hello\", \"world\")\n\npaste0(\"Hello\", \"R\")\n```\n\n文字列の取扱いに関しては、[9章](./chapter9.html)で詳しく説明します。\n\n### 数値（numeric）\n\nRは統計の言語ですので、数値データを取り扱う機会が特に多くなります。グラフを記述したり、データを要約する場合にも主に取り扱うのは数値です。Rでは、数値は**numeric**という型を持ちます。\n\n#### 数値型のdouble（浮動小数点）とinteger（整数）\n\n数値には更に詳細な型があります。詳細な型は`typeof`関数で調べることができます。Rでの数値は通常doubleという型を持ちます。\n\n数値にはdouble以外に、integer（整数）という型もあります。Rで整数型の数値を利用する時には、数字の後ろにLをつけます。また、数値であってもダブルクオーテーションで囲うと文字列 （character）になります。\n\n```{r, filename=\"double型とinteger型\"}\nmode(1) # modeでの型はnumeric\n\ntypeof(1) # これはdouble\n\ntypeof(1L) # これはinteger\n\ntypeof(\"1\") # これはcharacter\n```\n\nRではintegerを取り扱う機会は非常に少なく、通常数値はdoubleとして取り扱います。\n\n:::{.callout-tip collapse=\"true\"}\n\n## Rでの数値型\n\n多くのプログラミング言語では、小数点を含む数値は、その精度（桁数）により、single（浮動小数点型）、double（倍精度浮動小数点型）などの型を持ちます。このsingleはdoubleよりオブジェクトのファイルサイズが小さい代わりに、あまり大きい桁数の数値は取り扱えないという特徴があります。Rにはsingleという型はありません。\n\n:::\n\n#### クラス（class）\n\nRではオブジェクトは型以外に、**クラス（class）**という性質を別に持っています。Rでの数値型は、numeric（数値）というクラスを持ちます。クラスの確認には`class`関数を用います。\n\n```{r, filename=\"クラス、モードとtypeof関数\"}\nmode(1) # 型はnumeric\n\ntypeof(1) # typeofだとdouble\n\nclass(1) # クラスはnumeric\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## アトリビュート（attribute)\n\nRのオブジェクトは型だけでなく、アトリビュート（attribute）という性質を別に持っています。クラスはこのアトリビュートの一つです。オブジェクト指向プログラミングではクラスは非常に重要な意味を持ちますので、[18章](./chapter18.html)で詳しく説明します。\n\n:::\n\n#### 演算子（operator）\n\n数値を扱う際には、四則演算等の計算を行うことがあります。この四則演算を行うための記号のことを、**演算子**と呼びます。Rでは以下の四則演算子を利用できます。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  operator = c(\"+\", \"-\", \"*\", \"/\", \"%%\", \"%/%\", \"^\"),\n  meaning = c(\"足し算\", \"引き算\", \"掛け算\", \"割り算\", \"剰余（割り算の余り）\", \"整数の割り算\", \"累乗\")\n)\n\ncolnames(d) <- c(\"演算子\", \"演算の種類\")\n\nknitr::kable(d, caption=\"表2：Rで使える演算子\")\n```\n\n演算子それぞれの計算結果は以下のようになります。演算子の意味はExcelなどで用いられているものとほぼ同じです。\n\n```{r, filename=\"四則演算の例\"}\n3 + 2 # 足し算\n\n3 - 2 # 引き算\n\n3 * 2 # 掛け算\n\n3 / 2 # 割り算\n\n3 %% 2 # 剰余（余り）\n\n3 %/% 2 # 整数の割り算\n\n3^2 # 累乗\n```\n\n数値については[8章](./chapter8.html)で詳しく説明します。\n\n### 論理型（logical）\n\n**論理型（logical）**は、**TRUE（真）**と**FALSE（偽）**からなる2値の型です。TRUEとFALSEはその名の通り、その関係が正しいか、間違っているかを意味するものです。論理型はそのまま使用することもありますが、プログラミングでは**比較演算子**と共に用いることが多い型です。\n\n#### 比較演算子\n\n**比較演算子**とは、演算子の右と左を比較して、その関係が正しい（`TRUE`）のか、間違っているのか（`FALSE`）を返す演算子です。比較演算子の例を以下に示します。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  operator = c(\"==\", \"!=\", \"<\", \"<=\", \">\", \">=\", \"&\", \"&&\", \"|\", \"||\"),\n  meaning = c(\"等しい\", \"等しくない\", \"小なり\", \"小なりイコール\", \"大なり\", \"大なりイコール\", \"かつ\", \"かつ\", \"または\", \"または\")\n)\n\ncolnames(d) <- c(\"比較演算子\", \"比較演算子の意味\")\nknitr::kable(d, caption=\"表3：Rで使える比較演算子\")\n```\n\n`&`と`|`は比較演算子同士を結びつけるための演算子（論理演算子）です。`&`と`&&`、`|`と`||`の違いについては、[4章](./chapter4.html)で説明します。\n\n比較演算子を用いた演算の例を以下に示します。比較演算子や論理型は主に**条件分岐**で用います。\n\n```{r, filename=\"比較演算子\"}\n1 == 1 # 等しいのでTRUE\n1 == 2 # 等しくないのでFALSE\n\n1 != 1 # 等しいのでFALSE\n1 != 2 # 等しくないのでTRUE\n\n1 < 2 # 2は1より小さいのでTRUE\n1 < 1 # 1は1より小さくないのでFALSE\n\n1 <= 2 # 2は1より小さいのでTRUE\n1 <= 1 # 1は1に等しいのでTURE\n\n3 > 2 # 3は2より大きいのでTRUE\n2 > 2 # 2は2より大きくないのでFALSE\n\n3 >= 2 # 3は2より大きいのでTRUE\n2 >= 2 # 2は2と等しいのでTRUE\n\n1 == 1 & 2 == 2 # TRUEかつTRUEなのでTRUE\n1 == 1 & 2 == 3 # TRUEかつFALSEなのでFALSE\n\n1 == 1 | 2 == 2 # TRUEまたはTRUEなのでTRUE\n1 == 1 | 2 == 3 # TRUEまたはFALSEなのでTRUE\n```\n\n#### 演算子の優先順位\n\n数値の計算で掛け算・割り算を足し算・引き算より前に計算するように、演算子の優先順位、計算する順番は決まっています。概ね通常の計算と同じですが、以下のような順序で演算子は計算されます。\n\n1.  カッコでくくられている計算\n2.  累乗（`^`）\n3.  剰余・整数の割り算（`%%`・`%/%`）\n4.  掛け算・割り算（`*`・`/`）\n5.  足し算・引き算（`+`・`-`）\n6.  比較演算子（`==`、`!=`、`<`、`<=`、`>`、`>=`）\n7.  論理演算子（`&`、`|`）\n\n計算式は長くなることが多く、演算子の計算順を間違う場合も多いため、優先する計算は積極的にカッコで囲むとよいでしょう。\n\n```{r, filename=\"演算子の計算順序\"}\n(2 + 1) / 3 # カッコ内は最優先\n\n2 ^ 3 %% 5 # 累乗は剰余より先に計算(8/5の余り)\n\n3 / 3 %% 2 # 剰余は割り算より先に計算（3/1を計算）\n\n3 / 3 + 1 # 割り算は足し算より先に計算\n\n3 + 3 > 5 # 比較演算子は足し算より後に計算\n\n5 > 1 & 6 > 2 # 論理演算子は最後に計算\n```\n\n### その他の型・クラス\n\n以上の3つ（文字列、数値、論理型）がRでの基本的な型になります。しかし、Rにはこの3つ以外の型を持つオブジェクトも存在します。\n\n#### 欠損値など\n\nデータ分析では欠損値や、計算結果が表示できないもの、計算結果が無限大になるものなど、データとしてうまく取り扱えない値が生じることがよくあります。このような場合に対応するため、Rは欠損値、計算できない値、無限大にそれぞれ`NA`、`NaN`、`Inf`という型が設定されています。Rでは中身が何もないオブジェクト、`NULL`というものを作成することもできます。\n\n```{r, filename=\"欠損値、非数、無限大\"}\nNA # 欠損値（Not Available）\n\n0/0 # 非数（NaN、Not a Number）\n\n1/0 # 無限大（Inf）\n\n10000^1000000 # 大きすぎて取り扱えない数値もInfになる\n\nNULL # 中身がないオブジェクト（NULL）\n```\n\n#### 複素数（complex）\n\nRでは複素数（整数+虚数）を取り扱うこともできます。複素数を表すときには、数値の後に`i`を入力します。\n\n```{r, filename=\"複素数の作成と演算\"}\n1 + 1i # 複素数\n\nmode(1 + 1i) # 複素数の型はcomplex\n\n(1 + 1i) + (3 + 3i) # 複素数同士の足し算\n```\n\n#### 日時のクラス（Date、POSIXct、POSIXlt、difftime）\n\n日付は数値や文字列とは異なる性質を持ちます。統計では日付や時間を演算に用いることもあります。Rでは日付はDateというクラスを持ちます。また、日時のデータはPOSIXctやPOSIXltというクラスに属します。\n\nDateやPOSIXct、POSIXltは引き算などの演算に用いることができます。日時の差はdulationsというクラスを持ちます。\n\nDate、POSIXct、POSIXlt、dulationはいずれもクラスで、データの型としてはdouble、つまり数値型のデータとして取り扱われます。\n\n```{r, filename=\"日時のクラスと型\"}\nSys.Date() # 現在の日付を表示する関数\n\nclass(Sys.Date()) # 日付のクラスはDate\n\ntypeof(Sys.Date()) # 日付の型はdouble\n\n\nSys.time() # 現在の日時を表示する関数\n\nclass(Sys.time()) # 日時のクラスはPOSIXctとPOSIXlt\n\ntypeof(Sys.time()) # 日時の型はdouble\n\n\nSys.Date() - as.Date(\"2023-01-01\") # 2023/1/1から今日までの日数\n\nclass(Sys.Date() - as.Date(\"2023-01-01\")) # 日時の差のクラスはdifftime\n```\n\n## 変数と定数\n\n### 変数\n\nココまでは、数値や文字列などの、単純なオブジェクトについて説明してきました。単純なオブジェクトはプログラミングの要素として重要です。しかし、オブジェクトを毎回作成し直すのは面倒です。オブジェクトを作ったら、それを一時的に保管しておいて、後から演算に使える方が便利です。\n\n電卓では、このような「一時的に結果を記録する」方法として、メモリー機能があります。Excelなどでは、計算結果をセルに記録しておくこともあるでしょう。プログラミング言語にも、計算結果を一時的に保管しておくものが準備されています。この「計算結果を一時的に保管しておくもの」のことを、プログラミング言語では**変数**と呼びます。\n\n変数には名前がついています。名前付きの箱の中にオブジェクトを入れているようなものが変数です。下の図では、変数「`dog`」にオブジェクト「`\"犬\"`」を入れています。「`\"犬\"`」を取り出して使いたいときには、変数である「`dog`」を持ってくればよい、ということになります。\n\n![図2：変数のイメージ](./image/variable_image.png)\n\nRで変数を作成する場合には、変数名に「`<-`」の記号でオブジェクトを**代入**します。\n\n```{r, filename=\"変数への代入\"}\ndog <- \"inu\" # dogという変数に\"inu\"という文字列を代入する\nnumber <- 1 # numberという変数に、1という数値を代入する\ndog # 変数dogには\"inu\"が入っている\n\nnumber # 変数numberには1が入っている\n```\n\n変数には型・クラスがあり、代入したオブジェクトと同じ型・クラスを持つことになります。また、変数はそのまま演算に用いることができます。\n\n```{r, filename=\"変数の型\", error=TRUE}\nmode(dog) # dogの中身は文字列\n\nmode(number) # numberの中身は数値\n\n\npaste(dog, \"walk\") # dogの中身と\"walk\"をつなぐ\n\nnumber + 5 # numberの中身に5を足す\n\ndog + 1 # dogの中身は文字列なので、足し算はできない\n```\n\n変数への代入は、「`=`」や「`->`」の演算子によっても行うことができます。ただし、これらを代入に用いると、プログラムを読み解くのが難しくなるため、Rでは「`<-`」を用いることが推奨されています。\n\n```{r, filename=\"=や->による代入\"}\ndog = \"犬\" # イコールも代入に使うことができる\n2 -> number # ->も代入に使える（方向は<-と逆になる）\n\ndog\n\nnumber\n```\n\n定義されている変数の一覧を確認するには、`ls`関数を用います。\n\n```{r, filename=\"変数の確認\"}\nls()\n```\n\n### 変数と定数\n\n変数のうち、一度代入したら中身を変えられないもののことを**定数**と呼びます。他のプログラミング言語では定数を設定できるものが多いのですが、Rには定数を設定する方法はありません。変数の中身はいつでも置き換えできます。変数を置き換えると、置き換えに用いたオブジェクトの型・クラスに従い、変数の型・クラスも置き換わります。\n\n```{r, filename=\"変数の置き換え\"}\ndog <- \"inu\" # 変数に文字列を代入\nmode(dog) # 型は文字列になる\n\ndog <- 1 # 変数に数値を入れ直す\nmode(dog) # 変数の型は数値になる\n```\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## Rにおけるデータ型の変換\n\n多くのプログラミング言語では、上記のように変数の型が変化するのを抑える仕組み（型宣言）を持っています。型宣言が必要な言語では、変数は厳密に型のチェックを受けます（静的型付け）。Rにはこのような仕組みがなく、代入されたオブジェクトに従って型が決まり、型チェックされることなくプログラムが実行されます。このような言語のことを動的型付けと呼びます。\n\nプログラム中で変数の型が変わると、バグの原因となります。Rでは、プログラムを書いているうちに変数の型が変化していて、正しい計算結果が得られない、ということがたびたび起きます。変数の型を常に確認しながらプログラミングした方がよいでしょう。\n\n:::\n\n定数とは少し異なりますが、Rでは代入なしに使える変数もあります。例えば、円周率のπは「`pi`」という変数名で始めから登録されています。このような変数にも別のオブジェクトを代入することはできますが、後々混乱する原因となるため避けたほうがよいでしょう。\n\nまた、統計手法を試すためのデータが代入されている変数（データセット）もたくさん設定されています。データセットについては、[14章](.chapter14.html)で詳しく説明します。\n\n```{r, filename=\"あらかじめ設定されている変数\"}\npi # 円周率\n\nletters # アルファベット（小文字）\n\nLETTERS # アルファベット（大文字）\n\nmonth.abb # 月（短縮表記）\n\nmonth.name # 月\n\npi <- 3 # piに3を代入する\npi # piは3になってしまう\n```\n\n```{r, echo=FALSE}\npi <- 3.14159265358979 # 紛らわしいので元に戻しておく\n```\n\n### 値渡しと参照渡し\n\nRでは、変数への代入が行われるたびに、その変数に対するメモリのアドレスを新規に作成し直す、という特徴があるため、他の言語で理解が必要となる値渡しと参照渡しの問題がほとんど起きません。\n\n```{r, filename=\"値渡し\"}\nx <- 1 # xに1を代入\ny <- x # yにxを代入（yとxはメモリを共有）\nx <- 2 # xに2を代入（xのメモリのアドレスが変わる）\nx # xは新しいアドレスを参照（2が返ってくる）\ny # yは古いアドレスを参照（1が返ってくる）\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## 参照渡し\n\n上のコードでは、参照渡しであれば、xの値が2になった場合、xとメモリを共有しているyも2になります。Rでは、代入時にメモリのアドレスが別に準備されるため（値渡し）、参照渡しが起こることは基本的にありません。この特徴はプログラミング初心者には優しいのですが、変数の変更のたびにメモリ上にオブジェクトを新規作成するため、Rの実行速度が遅い原因になります。\n\n:::\n\n## 便利なオブジェクト・クラス\n\nここまでは、オブジェクトが一つだけの場合のデータ型や、変数について見てきました。しかし、統計で取り扱うのは、複数の数値や記録です。数値や記録がたくさんある場合には、数値や記録を一つづつ別々に取り扱うのは非効率です。多くのプログラミング言語では、このような複数の数値や記録を取り扱う専用のクラスを備えています。Rでは、複数の記録を取り扱うクラスとして、**ベクター（vector）**、**リスト（list）**、**データフレーム（data.frame）**、**行列（matrix）**の4つが用いられます。以下にこの4つについて簡単に説明します。それぞれのクラスについてはさらに別章で詳しく説明します。\n\n### ベクター（vector）\n\nRで最も基本的なオブジェクトは、**ベクター（vector）**です。ベクターは同じ型を持つオブジェクトの集まりで、1次元の、つまり縦横の構造がないデータとして取り扱われます。ベクターは`c`関数（`c`はcombine、「結合する」の意味）で作成することができます。\n\nベクターは同じ型を持つデータの集まりです。ですので、ベクターの要素に文字列が交じると、自動的にすべての要素が文字列になる、という特徴があります。\n\n```{r, filename=\"ベクターの作成\"}\nvec_n <- c(1, 2, 3, 4) # 数値のベクター\nvec_c <- c(\"dog\", \"cat\", \"pig\", \"horse\") # 文字列のベクター\nvec_temp <- c(1, 2, 3, \"dog\") # 文字列が交じると文字列のベクターになる\n\nvec_n\n\nvec_c\n\nvec_temp\n```\n\nRでは数値1つや文字列1つの要素も、ベクターとして取り扱われます。ですので、Rのオブジェクトの最小単位はベクターとなります。要素が1つであれば、`c`関数でつなぎ合わせる必要はありません。\n\n```{r, filenames=\"要素が1つだけのベクター\"}\n1 # 数字1つでもベクター\n\n\"Hello world\" # 文字列1つでもベクター\n```\n\n\n:::{.callout-tip collapse=\"true\"}\n\n## 本文でのvectorの表記について\n\nvectorはベクトルと表記されることもあります。この文書では、Rのオブジェクトをベクター、方向と大きさを持つ量のことをベクトルと表記することとします。\n\n:::\n\n#### ベクターに要素を追加する\n\nベクターに要素を追加するために、`append`関数というものが用意されています。しかし、上記の`c`関数でもベクターに要素を追加することができます。\n\n`append`関数では位置を特定して要素を追加することができますが、位置を特定して要素を追加することはまれです。\n\n```{r, filename=\"ベクターに要素を追加する\"}\nappend(vec_n, 5) # 上の数値ベクターに5を追加\n\nc(vec_n, 5) # 上と同じ\n```\n\n#### ベクターの要素を取り出す\n\nベクターの要素を取り出すときには、**インデックス**というものを用います。インデックスとは、ベクターなどの複数の値を取り扱うオブジェクトにおいて、値のある位置を示す数値のことです。インデックスはベクターの変数の後に、四角カッコ（`[ ]`）に数値を入れることで指定することができます。Rではインデックスは1から始まります。\n\n![図3：ベクターとインデックス](./image/vector_index.png)\n\n```{r, filename=\"ベクターの要素をインデックスで取り出す\"}\nvec <- c(4, 3, 2, 1) # 数値のベクターを作成する\nvec[1] # インデックス1には4が入っている\n\nvec[3] # インデックス3には2が入っている\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## 他言語でのインデックス\n\n多くのプログラミング言語では、インデックスは0から始まります。インデックスが1から始まるプログラミング言語はまれです。\n\n:::\n\n#### ベクターの要素の置き換え\n\nベクターの要素を置き換えるときには、置き換えたいベクターのインデックスを指定し、数値などを代入します。この時、数値のベクターの要素を文字列に置き換えると、ベクター全体が文字列に置き換わるので注意して下さい。\n\n```{r, filename=\"ベクターの要素を置き換える\"}\nvec # 数値のベクター\n\nvec[3] <- 5 # インデックス3の数値を5に置き換える\nvec # 3番めが2から5に置き換わる\n\nvec[4] <- \"dog\" # インデックス4の数値を\"dog\"（文字列）に置き換える\nvec # ベクターはすべて文字列になる\n```\n\n#### ベクターの要素を取り除く\n\nベクターの要素を取り除くときには、**ベクターのインデックスをマイナス**で指定します。マイナスのインデックスで指定した要素は取り除かれ、ベクターの長さが短くなります。\n\n```{r, filename=\"ベクターの要素を取り除く\"}\nvec\nvec[-3] # インデックス3の要素（5）を取り除く\n```\n\n#### ベクターの演算\n\nベクターは、そのまま演算に用いることができます。数値のベクターに数値を足せば、ベクターのすべての要素に数値が足されます。文字列のベクターに`paste`関数で文字を継ぎ足せば、すべての要素に文字が継ぎ足されます。\n\n```{r, filename=\"ベクターを演算に用いる\"}\nvec_n # 数値のベクター\nvec_n + 5 # 数値のベクターに5を足すと、すべての要素に5が足される\n\nvec_c # 文字のベクター\npaste(vec_c, \"is an animal.\") # 文字のベクターにpaste関数で文字をつなぎ合わせる\n```\n\nベクターについては[11章](.chapter11.html)でさらに詳しく説明します。\n\n\n### 因子（factor）\n\n**因子（factor）**はR以外のプログラミング言語にはないクラスの一つです。因子とは、**カテゴリ**を表すときに用いるクラスです。カテゴリとは、例えば男性/女性や、成人/未成年、喫煙者/非喫煙者などの、そのデータの性質を表す要素のことを指します。統計では、例えば男性と女性で分けて数値を集計する、といったシチュエーションがたくさんあります。このように、カテゴリごとの集計や統計を行いやすくするために準備されているクラスが因子です。因子は`factor`関数を用いて作成します。\n\n```{r, filename=\"因子型（factor）\"}\nfactor(\"male\") # 男性を示す因子\n\nclass(factor(\"male\")) # 因子のクラスはfactor\n```\n\n#### 因子のレベル（levels）\n\n因子には、**レベル（levels）**というアトリビュートが付いています。因子はカテゴリを示すものですので、通常1つだけで用いることはありません（カテゴリが1つだけであれば、カテゴリ分けする必要がありません）。つまり、因子は複数の要素を持つベクターとして作成することになります。このときのベクター内の各カテゴリ（男性・女性など）のことをレベルと呼びます。因子については[10章](./chapter10.html)で詳しく説明します。\n\n### リスト（list）\n\n統計の計算をしていると、複数の計算結果をまとめて取り扱いたい、という場合があります。ベクターは1次元のオブジェクトで、かつすべての要素のデータ型が同じですので、ベクターでは型や長さの違う、様々な結果を一度に取り扱うことはできません。このような、型の違うデータを一度に取り扱うときに用いられるのが、**リスト（list）**と呼ばれるオブジェクトです。リストは、様々なオブジェクトをまとめて一つにしたようなデータ構造を持ちます。リストを作成するときには、`list`関数を用います。\n\n```{r, filename=\"リスト（list）の作成\"}\nvec1 <- c(1, 2, 3, 4) # 数値のベクター\nvec2 <- c(\"dog\", \"cat\", \"pig\", \"horse\") # 文字列のベクター\nnum <- 10 # 数値\nchar_temp <- \"Hello world\" # 文字列\n\nlist_temp <- list(vec1, vec2, num, char_temp) # 色々な要素をリストにまとめる\nlist_temp # まとめたリストを表示\n```\n\n#### リストの要素を取り出す\n\nリストの要素を取り出す場合には、ベクターと同様にインデックスを用います。ただし、リストのインデックスは多層化、ネストされているため、呼び出しはやや複雑です。リストの要素を取り出すときには、四角カッコを2重にして用います（`[[ ]]`）。`[[1]]`で呼び出すと、リストの1番目の要素を呼び出すことになります。ベクターと同様に**`[1]`で呼び出すと、リストの1番目の要素を、リストとして呼び出す**ことになり、要素までたどり着けません。\n\n```{r, filename=\"リストの要素を取り出す\"}\nlist_temp[[1]] # リストの1番目の要素を取り出す\n\nlist_temp[[2]] # 2番目の要素を取り出す\n\nlist_temp[1] # リストの1番目の要素を、リストとして取り出す\n\nlist_temp[[1]][1] # リストの1番目の要素（ベクター）の、1番目の要素を取り出す\n```\n\nリストについては、[12章](./chapter12.html)で詳しく説明します。\n\n### データフレーム（data.frame）\n\n**データフレーム（data.frame）**はExcelの表のように、行と列を持ち、長方形の形に整形された表形式のオブジェクトです。データフレームはExcelの表のように取り扱うことができます。\n\nデータフレームは**縦方向（列）に同じデータ型**を持つ、ベクターの集合になっています。データフレームは横方向（行）には異なる型を持つことができますが、縦方向（列）は必ず同じ型を持つ必要があります。列はベクターですので、ベクターと同じように**数値の列の1つのデータを文字列に置き換えると、その列のデータが全て文字列に変換される**という特徴があります。\n\nデータフレームは`data.frame`関数を用いて作ることができます。データフレームを作成するときには、**「列名」=「列の要素」**という形でカッコの中に入力します。\n\n```{r, filename=\"データフレームの作成\"}\nd <- data.frame( # データフレームを作成する（各列を同じ長さにする）\n  number = c(1, 2, 3, 4), # 1列目は数値\n  animal = c(\"dog\", \"cat\", \"pig\", \"horse\"), # 2列目と3列目は動物と果物\n  fruits = c(\"apple\", \"orange\", \"banana\", \"grape\")\n)\n\nd # データフレームの表示\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## データフレームとリスト\n\nデータフレームは同じ長さのベクターをリストにしたものです。ですので、縦（列）はベクターとして同じ型を持ちます。データフレームはリストでもあるので、リストと同じように取り扱うこともできます。\n\n:::\n\n#### データフレームの次元（dimension）と行数・列数\n\nデータフレームには、**次元（dimension）**という性質（アトリビュート、attribute）があります。この次元とは、行の数、列の数のことです。次元を取得する時には、`dim`関数を用います。また、行の数、列の数はそれぞれ`nrow`関数、`ncol`関数で取得することができます。\n\n```{r, filename=\"データフレームの次元を取得する\"}\ndim(d) # 次元の取得（前が行の数、後ろが列の数）\nnrow(d) # 行の数\nncol(d) # 列の数\n```\n\n#### データフレームのインデックス\n\nベクターやリストと同じく、データフレームでもインデックスで要素を取り出すことができます。データフレームのインデックスは、**`[行, 列]`**という形で指定します。行も列も、1行目・1列目のインデックスが1となります。\n\nデータフレームでは、行だけ、列だけをインデックスとして指定することもできます。**行だけをインデックスとして指定した時（`[行, ]`の形で指定）には、その行がデータフレームとして取り出されます**。一方、**列だけを指定した時（`[, 列]`の形で指定）には、その列がベクターとして取り出されます**。データフレームを行と列で取り出した場合には異なるものが取り出されるので、特にデータフレームの行を取り出す際には注意が必要です。\n\n```{r, filename=\"データフレームの要素を取り出す\"}\nd\n\nd[2, 3] # 2行3列目のデータを取り出す\n\nd[2, ] # 2行目を取り出す（データフレーム）\n\nd[, 3] # 3列目を取り出す（ベクター）\n```\n\nデータフレームの列は、列の名前を用いても取り出すことができます。列を取り出すときには、**\\$（ドルマーク）に列名**を繋げて記述します。\n\n```{r, filename=\"列を列名で呼び出す\"}\nd$number # 1列目の列名はnumber\n\nd$animal # 2列目の列名はanimal\n\nd$fruits # 3列目の列名はfruits\n```\n\n#### データフレームの要素の置き換え\n\nデータフレームの要素の置き換えは、ベクターと同じように、置き換えたい場所のインデックスを指定して、値を代入する形で行います。この時、その置き換える列の型と代入するデータの型が異なると、列の型がすべて置き換わることがあるので注意が必要です。\n\n```{r, filename=\"データフレームの要素を置き換える\"}\nd[2, 3] <- \"peach\" # 2行3列目の要素をpeachに置き換える\nd # 2行3列目がpeachに置き換わる\n\nd[2, 1] <- \"tomato\" # 2行1列目をtomato（文字列）に置き換える\nd # 2行1列目がtomatoに置き換わる\n\nmode(d[, 1]) # 1列目が文字列に置き換わる\n```\n\n#### データフレームの行・列の削除\n\nデータフレームの行や列を削除する場合には、ベクターと同じように、インデックスをマイナスで与えます。インデックスをマイナスで指定することで、そのインデックスの行・列を取り除くことができます。ただし、データフレームの1つの要素だけを削除することはできません（指定した行・列がまるごと削除されます）。1つの要素だけを取り除く場合には、その要素のインデックスに対して`NA`を代入するとよいでしょう。\n\n```{r, filename=\"データフレームの行・列を削除する\"}\nd # 元々のデータフレームは4行3列\n\nd[-1, ] # 1行目を削除\n\nd[, -1] # 1列目を削除\n\nd[-2, -3] # 2行目と3列目を削除\n\nd[2, 3] <- NA # 1要素だけを取り除くときは、NAを代入する\n```\n\n### 行列（matrix）\n\n**行列（matrix）**は、線形代数（高校数学での行列計算）に用いるものです。行列は基本的には一つの型の要素からなる、行と列のあるオブジェクトです。行列はデータフレームとよく似ていますが、データフレームが列方向のベクターのリストであるのに対し、行列は次元（dimension）を持つベクターに近いものとなります。\n\nRで行列を作成するときには、`matrix`関数を用います。`matrix`関数では、カッコの中に、ベクター、行数、列数を指定する数値を与えます。\n\n```{r, filename=\"行列を作成する\"}\n# 2行3列の行列\nmat <- matrix(c(1,2,3,4,5,6), nrow=2, ncol=3) # nrowは行数、ncolは列数\nmat\n```\n\n#### 行列の次元とインデックス\n\n行列の次元とインデックスは、データフレームとほぼ同じように取り扱うことができます。行列の行・列に名前をつけることもできます。従って、列を取り出すときに列名を利用することもできます。取り出したものはいずれもベクターになります。要素・行・列の削除もデータフレームと同じ方法で行います。\n\n```{r, filename=\"行列の要素の取り出し\"}\nmat[1, 1] # 1行1列目の要素\n\nmat[1, ] # 1行目の要素（ベクター）\n\nmat[, 1] # 1列目の要素（ベクター）\n\ndim(mat) # matのdimensionを表示\n\nnrow(mat) # matの行数を表示\n\nncol(mat) # matの列数を表示\n```\n\n#### 行列の演算\n\nデータフレームとは異なり、数値の行列は演算に用いることができます。行列（線形代数）の計算のために、Rには行列積、外積、クロネッカー積に対応する演算子が準備されています。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  operator = c(\"%*%\", \"%o%\", \"%x%\"),\n  meaning = c(\"行列の積\", \"外積\", \"クロネッカー積\")\n)\n\ncolnames(d) <- c(\"行列の演算子\", \"演算子の意味\")\nknitr::kable(d, caption=\"表4：Rで使える行列の演算子\")\n```\n\n```{r, filename=\"行列の演算\"}\nmat2 <- matrix(c(1, 2, 3, 4, 5, 6), nrow=3, ncol=2)\n\nmat %*% mat2 # 行列の積\n\nmat %o% mat2 # 外積\n\nmat %x% mat2 # クロネッカー積\n```\n\n#### 3次元以上のオブジェクト：array\n\n行列はベクターに次元を2つ（行と列）与えたものですが、3次元以上の次元を与えることもできます。このような3次元以上のデータを取り扱う場合には、arrayというオブジェクトを使用します。arrayは`array`関数で作成することができ、各次元の数（行数、列数に当たるもの）をベクターで与えます。統計やデータ解析で3次元以上のデータを取り扱うことは比較的まれです。\n\n```{r, filename=\"arrayを作成する\"}\narray(c(1, 2, 3, 4, 5, 6, 7, 8), dim = c(2, 2, 2)) # 2行2列2シートの行列\n```\n\n### その他のオブジェクト\n\nRに基本的に備わっているオブジェクトとして、ベクター、リスト、データフレーム、行列の他に、**時系列（time series、ts）**というオブジェクトがあります。時系列とは、例えば株価や為替相場の時間変化のような、時間とともに定期的に記録されたデータのことを指します。時系列はクラスとして設定されており、中身はベクターです。\n\n```{r, filename=\"時系列データ（ts）\"}\nco2[1:10] # 1959年からのCO2濃度の推移\n\nclass(co2) # クラスはts\n\ntypeof(co2) # 型はdouble\n```\n\n## 関数\n\nここまでに、`mode`関数、`typeof`関数、`class`関数、`c`関数、`list`関数、`data.frame`関数、`matrix`関数など、様々な関数を用いて、オブジェクトの型やクラスを調べたり、ベクターやリストなどを作成してきました。R言語の**関数**とは、**オブジェクトに一定の演算を加えて、結果を表示するオブジェクト**のことを指します。関数のクラスは**function**（関数）、型も**function**です。\n\n```{r, filename=\"オブジェクトとしての関数\"}\nclass(typeof) # 関数のクラスはfunction\n\nmode(typeof) # 関数の型もfunction\n```\n\nRでの関数は、**引数**と呼ばれる、カッコの中に記載されたオブジェクトに対して、一定の演算を加えるものです。Excelの関数をイメージしていただければ理解しやすいと思います。関数のイメージを図にすると、以下のようになります。\n\n![図4：関数のイメージ図](./image/function_image.png)\n\nRには`mean`関数という、数値の平均値を表示してくれる関数があります。上の図では、ベクターである、`c(5, 10, 15)`を引数として与えると、`mean`関数は引数を読み取って平均値を計算し、平均値である10を表示してくれます。この、表示される関数の計算結果のことを、**返り値**と呼びます。\n\n```{r, filename=\"関数、引数と返り値\"}\nvec <- c(5, 10, 15) # 引数とするベクター\nmean(vec) # mean関数に引数vecを与えると、10が返り値として返ってくる\n```\n\nRには、上記の関数以外にも、数値や文字列、データフレームを演算するための関数を数多く備えています。\n\n```{r, filename=\"代表的な関数と、関数としての演算子\"}\nsd(vec) # 標準偏差を計算する関数\n\nmedian(vec) # 中央値を計算する関数\n\nlog10(vec) # 常用対数を計算する関数\n\nexp(vec) # ネイピア数の指数を計算する関数\n\nmode(`+`) # 演算子の+の型はfunction（関数）\n\n`+`(2, 3) # 関数なので、引数を2つ取ると足し算になる\n\nmode(`[`) # インデックスも関数\n\nmode(`if`) # if（条件分岐）も関数\n\nmode(`for`) # for（繰り返し文）も関数\n```\n\n:::{.callout-tip  collapse=\"true\"}\n\n## Rでの関数\n\nRでは、演算子やインデックス指定、条件分岐、繰り返し文も関数です。\n\n:::\n\nこのように、Rでは多くの演算を関数によって処理しています。この性質から、Rは**関数型言語**であるとされています。\n\n:::{.callout-tip collapse=\"true\"}\n\n## Rと関数型言語\n\n正確には、Rは厳密な意味では関数型言語ではないように思います。関数型言語には[Haskell](https://www.haskell.org/)などがありますが、関数型言語では再帰的関数（関数内で関数を呼び出す）ような処理を用いて繰り返し計算を避ける場合が多く、Rのような逐次型処理に慣れていると読みにくいコードをよく書くイメージがあります。Rでも再帰的関数を用いることはできますが、頻繁には使用されません。\n\n:::\n\n### 関数を自作する\n\nどのようなプログラミング言語にも、関数を自作する方法が備わっています。Rでは、`function`文を用いて関数を自作することができます。関数を変数に代入して用いるのが一般的な関数の作成方法です。`function`文の書き方は以下の通りです。\n\n**関数名 \\<- function(引数群){引数を使った処理}**\n\n関数の返り値は、`return`関数を使って明示することもできますが、単に最後に記載したオブジェクトを返り値とすることもできます。\n\nまた、Rでは`function`と書く代わりに、`\\`（バックスラッシュ）を`function`の代わりに用いることもできます。\n\n作成した関数を用いて演算するときには、「関数名(引数)」という形で表記します。これは`mode`関数や`class`関数の使い方と同じです。\n\n```{r, filename=\"関数を自作する\"}\n# 引数をそのまま帰す関数\nreturn_selfx <- function(x){return(x)} # 返り値をreturn関数で表示\nreturn_selfy <- function(y){y} # 最後に返り値を書く\nreturn_selfz <- \\(z){z} # functionの代わりにバックスラッシュを用いる\n\n# どれも同じ演算をする関数になる\nreturn_selfx(1)\n\nreturn_selfy(1)\n\nreturn_selfz(1)\n```\n\n実際に関数を作るときには、もう少し複雑な処理を`{ }`（中かっこ）の中に書きます。処理は一つ一つ改行しながら書き、最後に返り値を書きます。中かっこの中で改行を行っても問題ありませんが、引数のかっこ（「`)`」）の後にかっこの前側（「`{`」）が記載されている必要があります。\n\n```{r, filename=\"関数内の処理の書き方\"}\n# sum2関数を作成する\nsum2 <- function(x, y, z){ # 引数はx、y、zの3つ\n  sum_of_xyz <- x + y + z # 引数を足し算する\n  sum_of_xyz # 足し算したものを返り値にする\n}\n\nsum2(x = 1, y = 2, z = 3)\n```\n\n上の例のように、引数を指定するときには、引数の種類を明示的に記載することもできます。明示的に記載する場合には、**「引数名=値」**という形で書きます。引数名を省略した場合には、記載した引数の順番に従って、引数が用いられます。\n\n関数を作成するときには、**引数のデフォルト値**を設定しておくこともできます。デフォルト値が設定されている関数では、その引数を入力しなかったときには、自動的に引数にデフォルト値が入ります。\n\n```{r, filename=\"引数のデフォルト値と省略\", error=TRUE}\nsum3 <- function(x, y = 1){ # yのデフォルト値を1とする\n  return(x + y)\n}\n\nsum3(x = 1, y = 2) # 引数を明示的に記載\n\nsum3(1, 2) # xに1、yに2が入る\n\nsum3(1) # 引数yが省略されているので、デフォルト値（1）が用いられる\n\nsum3(y = 1) # xにはデフォルトが設定されていないので、省略できない\n```\n\n## 型・クラスの確認と変換\n\n### 型・クラスの確認：is.関数群\n\nRでは、型やクラスを確認するための関数として、`typeof`関数・`mode`関数・`class`関数以外に、`is.`関数というものを備えています。`is.`関数を用いると、オブジェクトの型が、ある型と一致しているかどうかを確認することができます。引数が数値であるかどうかは、`is.numeric`関数、`is.integer`関数、`is.double`関数を用いて確認することができます。例えば**`is.numeric(1)`は`TRUE`**を返し、**`is.numeric(\"dog\")`は`FALSE`**を返します。この`is.`関数には、文字列や`NA`、`NaN`等を確認する関数もあります。`is.`関数を以下の表2に示します。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  isfunc = c(\"is.numeric(x)\", \"is.integer(x)\", \"is.double(x)\", \"is.complex\", \"is.character(x)\", \"is.logical(x)\", \"is.factor(x)\", \"is.atomic(x)\", \"is.list(x)\", \"is.matrix(x)\", \"is.data.frame(x)\", \"is.na(x)\", \"is.nan(x)\", \"is.null(x)\", \"is.infinite(x)\"),\n  meaning = c(\"数値型\", \"整数型\", \"double型\", \"複素数型\", \"文字列型\", \"真偽型\", \"因子型\", \"ベクター\", \"リスト\", \"マトリックス\", \"データフレーム\", \"NA\", \"NaN\", \"NULL\", \"無限大\")\n)\n\ncolnames(d) <- c(\"is.関数名\", \"チェックする型\")\nknitr::kable(d, caption=\"表2：xの型の確認に用いる関数\")\n```\n\n`is.`関数の中では、`is.na`関数の使用頻度が高いです。`is.na`関数を用いると、ベクターやデータフレームからNAを含む要素をうまく取り除くことができます。\n\n```{r, filename=\"is.関数群\"}\nc(is.numeric(1), is.numeric(\"1\")) # 文字列（\"1\"）は数値ではない\n\nc(is.integer(1L), is.integer(1)) # Lが付いていないとdoubleになる\n\nc(is.double(1), is.double(1L)) # Lが付いているとintegerになる\n\nc(is.complex(1+1i), is.complex(1+1)) # iがあると複素数になる\n\nc(is.character(\"dog\"), is.character(1)) # 数値は文字列ではない\n\n# 0はFALSE扱いされるが、logicalではない\nc(is.logical(T), is.logical(0), is.logical(\"dog\")) \n\nc(is.factor(factor(1)), is.factor(1))\n\nc(is.atomic(1), is.atomic(list(1))) # ベクターはTRUE、リストはFALSE\n\nc(is.vector(1), is.vector(list(1))) # is.vectorもあるが、リストもTRUEになる\n\nc(is.list(list(1)), is.list(1))# ベクターはFALSE、リストはTRUE\n\nc(is.matrix(matrix(1, ncol=1)), is.matrix(1))\n\nc(is.data.frame(data.frame(1)), is.data.frame(list(1))) # リストはFALSE\n\n# NAとNaNはNA扱い、NULLは無いもの扱い\nc(is.na(NA), is.na(1), is.na(NaN), is.na(Inf), is.na(NULL)) \n\n# NULLは無いもの扱い\nc(is.nan(NA), is.nan(1), is.nan(NaN), is.nan(Inf), is.nan(NULL))\n\n# NULLを評価する\nc(is.null(NA), is.null(1), is.null(NaN), is.null(Inf), is.null(NULL)) \n\n# NULLは無いもの扱い\nc(is.infinite(NA), is.infinite(1), is.infinite(NaN), is.infinite(Inf), is.infinite(NULL)) \n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## atomicなベクター\n\nベクターは`is.atomic`関数で評価します。これは、ベクターのことをatomic vectorと呼ぶためです。atomic vectorはvectorと同じ意味を持ちます。エラーやメッセージには時々このatomic vectorという表記が出てきますが、これは通常のベクターのことを述べているだけで、atomic vectorという特別なものがあるわけではありません。\n\n:::\n\n### 型・クラスの変換：as.関数群\n\n`is.`関数はデータのクラスや型をチェックし、論理型を返す関数です。Rには、関数名がよく似た`as.`関数があります。`as.`関数は、引数の型を指定した型に変換する関数です。例えば、`as.numeric`関数は引数をnumericに変換する関数です。`as.`関数の一覧を以下の表3に示します。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  asfunc = c(\"as.numeric(x)\", \"as.integer(x)\", \"as.double(x)\", \"as.complex\", \"as.character(x)\", \"as.logical(x)\", \"as.factor(x)\", \"as.Date\", \"as.POSIXct\", \"as.POSIXlt\", \"as.list(x)\", \"as.matrix(x)\", \"as.data.frame(x)\", \"as.null(x)\"),\n  meaning = c(\"数値型に変換\", \"整数型に変換\", \"double型に変換\", \"複素数型に変換\", \"文字列型に変換\", \"真偽型に変換\", \"因子型に変換\", \"日時型に変換\", \"POSIXct型に変換\", \"POSIXlt型に変換\", \"リストに変換\", \"マトリックスに変換\", \"データフレームに変換\", \"NULLに変換\")\n)\n\ncolnames(d) <- c(\"as.関数名\", \"変換する型\")\nknitr::kable(d, caption=\"表3：xの型の変換に用いる関数\")\n```\n\n```{r, filename=\"as.関数群\"}\nas.numeric(TRUE)\n\nas.integer(1.1)\n\nas.double(1L)\n\nas.complex(1)\n\nas.character(1)\n\nc(as.logical(1), as.logical(0))\n\nas.factor(c(\"dog\", \"cat\"))\n\nas.Date(\"2022-02-22\") # わかりにくいが、日付型になっている\n\n# わかりにくいが、日時型になっている\nas.POSIXct(\"2022-02-22 15:00:00\")\n\nas.POSIXlt(\"2022-02-22 15:00:00\")\n\nas.list(1)\n\nas.data.frame(list(1, 1))\n\nas.matrix(data.frame(x=1, y=1))\n\nas.null(1)\n```\n\n## NAの取り扱い\n\nRでは、データに欠測値（`NA`）、計算できない値（`NaN`）、空の値（`NULL`）、無限大（`Inf`）が含まれることがあります。これらのうち、`NA`と`NaN`を取り除く関数が`na.omit`関数です。`na.omit`関数はベクターやデータフレームを引数に取り、`NA`と`NaN`を取り除いてくれる関数です。`NA`と異なり、`Inf`は取り除かれません。\n\n```{r, filename=\"na.omit関数\"}\nvec <- c(1, NA, NaN, NULL, Inf) # NULLは要素として含められない\nvec\n\nna.omit(vec)\n```\n\n## 予約語\n\n上の例では関数や変数に名前をつけていますが、関数名や変数名の付け方にはルールがあります。\n\n-   名前の始めに数値（1、2など）をつけることはできない\n-   名前の始めにアンダーバー（\\_）を用いることはできない\n-   大文字と小文字は区別される（SUMとsumは別扱い）\n-   演算子や記号（`!`や`?`、`+`、`-`、`#` など）は使えない\n-   **予約語**を用いることはできない\n\n**予約語（reserved word）**とは、R言語がすでに役割を与えているために、関数名や変数名には使用できない文字列です。Rで設定されている予約語は以下の通りです。\n\n-   if\n-   else\n-   repeat\n-   while\n-   function\\\n-   for\n-   in\n-   next\n-   break\n-   TRUE\n-   FALSE\n-   NULL\n-   Inf\n-   NaN\n-   NA\n-   NA_integer\\_\n-   NA_real\\_\n-   NA_complex\\_\n-   NA_character\\_\n-   ...\n-   ..1\n-   ..2\n\n:::{.callout-tip collapse=\"true\"}\n\n## Rでのピリオドの取り扱い\n\nRでは、ピリオド（.）が予約語に含まれていないため、変数名にピリオドを利用することができます。ただし、他の言語ではこのピリオドをメソッド（method）という、関数の仲間のようなものに用いることが多く、勘違いを起こしやすい表記になります。Rでも変数名にピリオドを用いないほうがよいとされています。\n\n:::\n\n## ヘルプ\n\nヘルプを呼び出すことでRの関数の使い方を確認することができます。ヘルプは関数名の前に`?`を付けて実行することで呼び出すことができます。RStudioでは、右下のパネルにヘルプの内容が表示されます。\n\n```{r, filename=\"ヘルプの呼び出し\", eval=FALSE}\n?mean # mean関数のヘルプを呼び出す\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"chapter3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","lightbox":"auto","bibliography":["references.bib"],"editor":"source","theme":{"light":"united","dark":"cyborg"},"toc-expand":2,"code-block-bg":true,"code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}