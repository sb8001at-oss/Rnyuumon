{"title":"条件判断（Control structures）","markdown":{"headingText":"条件判断（Control structures）","containsRefs":false,"markdown":"\n```{r, setup, include=FALSE, echo=FALSE}\nknitr::opts_chunk$set(\n  collapse = TRUE\n)\n```\n\n## 条件判断とは？\n\nプログラミングでは、ある条件のときはこの処理、別の条件のときはこの処理...、といった具合に、条件によって行う処理を変えたいことがよくあります。例えば、じゃんけんでは出した手の条件によって勝ち・負け・引き分けという3つの処理を行うことになります。このように、条件によって処理を変えることを、**条件判断**と呼びます。\n\n## 条件と論理型（logical）\n\n条件として用いられるのは、**論理型（logical）**です。論理型は`TRUE`（真）と`FALSE`（偽）の2つの値を持ちます。論理型はそれそのものを用いる場合と、比較演算子の演算結果として得る場合があります。Rでは、**`TRUE`を`T`、`FALSE`を`F`**と表記することができます。\n\n```{r, filename=\"論理型\"}\nTRUE\n\nFALSE\n\nT\n\nF\n\nc(T, F, T, F) # logicalはベクターにもできる\n\n1 < 3 # 3は1より大きいのでTRUE\n\n1 > 3 # 1は3より大きくないのでFALSE\n```\n\n## 数値としての論理型\n\n論理型は、Rの内部では数字として取り扱われています。Rでは**`TRUE`は`1`、`FALSE`は`0`**と同一です。ですので、ベクター中の`TRUE`の数を足し算で計算することができます。また、**`0`以外が`TRUE`、`0`が`FALSE`**として扱われる場合もあります。条件判断では`0`を`FALSE`として用いる場合もあります。\n\n```{r, filename=\"数値としての真偽値\"}\nT + T + F # 足し算すると2が返ってくる\n\nvec <- c(T, T, F, T, F, T, F)\nsum(vec) # sumはベクターの要素を足し算する関数\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## 他言語でのTRUEとFALSEの数値変換\n\nRではTRUEが1、FALSEが0ですが、他の言語ではFALSEが-1のものもあります。言語によりTRUE/FALSEの仕様は異なります。\n\n:::\n\n## 論理演算子\n\n論理型は、**論理演算子**による計算に使うことができます。Rでの論理演算子は**`&`、`&&`、`|`、`||`**の4つです。このうち、`&&`と`||`は、ベクターの**始めの値だけ**を評価するという特徴を持っています（Rのバージョン4.3以降ではベクターを比較するとエラーが出ます）。`&&`と`||`を用いるとプログラムが予想外の挙動を取ることがあるので、できるだけ`&`と`|`だけを用いたほうがよいでしょう。RにはNAND（否定論理積）、NOR（否定論理和）などを表す専用の論理演算子はありませんが、XOR（排他的論理和）を表す関数（`xor`関数）はあります。XORは2つの論理型に対し、どちらかがTRUEならTRUEを、両方がFALSEならFALSEを返す演算子です。\n\n```{r, filename=\"論理演算子\", echo=FALSE}\nd <- data.frame(\n  operator = c(\"&\", \"&&\", \"|\", \"||\", \"!\", \"xor\",\"any\", \"all\"),\n  meaning = c(\"論理積（AかつB）\", \"論理積（ベクターの始めの要素のみ評価）\", \"論理和（AまたはB）\", \"論理和（ベクターの始めの要素のみ評価）\", \"否定演算子（真偽を反転）\", \"排他的論理和\", \"いずれかが真の時に真を返す\", \"すべてが真の時に真を返す\")\n)\n\ncolnames(d) <- c(\"論理演算子\", \"演算子の意味\")\nknitr::kable(d, caption=\"表1：Rで使える論理演算子\")\n```\n\n```{r, filename=\"論理演算子による演算\", error=TRUE}\nlogic1 <- c(T, F)\nlogic2 <- c(F, F)\nlogic1 & logic2 # & は論理積（AND）\n\nlogic1 | logic2 # | は論理和（OR）\n\nlogic1 && logic2 # 1番目の項目同士のみを比較する\n\nlogic1 || logic2\n\nxor(logic1, logic2) # 排他的論理和\n\nany(logic1) # 片方がTRUEなのでTRUE\n\nall(logic1) # すべてがTRUEでは無いのでFALSE\n```\n\n論理演算子として、**`!`（エクスクラメーションマーク、否定演算子）**も用いることができます。`!`は論理型の前に置くことで、論理型を反転（`TRUE`を`FALSE`に、`FALSE`を`TRUE`に）させます。\n\n```{r, filename=\"!による論理値の反転\"}\n!TRUE\n!FALSE\n\n!(1 < 3)\n!(1 > 3)\n```\n\n## 条件分岐の文\n\n上記のように、比較演算子や論理演算子を用いると、論理型を得ることができます。この論理型に従い、行う処理を変えるものを、**条件分岐**と呼びます。条件分岐では、条件分岐の文（Control structures）というものが用いられます。Rでは、条件分岐の文として、**if文とswitch文**の2つが設定されています。\n\n```{r, echo=FALSE}\nd <- data.frame(\n  meaning = c(\"if文\", \n            \"ifelse関数\", \n            \"switch文\"),\n  structure = c(\"if(条件式){TRUEのときの演算}else{FALSEのときの演算}\", \n                \"ifelse(条件式, TRUEのときの演算, FALSEのときの演算)\", \n                \"switch(評価する値, 評価の既定値=既定値のときの演算)\")\n)\n\ncolnames(d) <- c(\"条件分岐\", \"条件分岐の形式\")\nknitr::kable(d, caption=\"表2：Rで使える条件分岐\")\n```\n\n### if文\n\n`if`文は最もシンプルな条件分岐の文です。`if`文では、**条件式**に従い、実行する処理が変わります。Rでの`if`文は、以下の形を取ります。\n\n**if(条件式){TRUEのときに実施する処理}**\n\n条件式を**`if()`**のカッコの中に書きます。`if`文は1行で書くこともできますし、複数行に渡って書くこともできます。複数行に処理を書くときには、**中括弧（`{}`）**を条件式の後に書き、中括弧の中に処理を書きます。\n\n```{r, filename=\"if文の使い方\"}\nif(TRUE) \"Hello R\" # 1行で書く場合（\"Hello R\"が返ってくる）\n\nif(FALSE) \"Hello FALSE\" # 条件式がFALSEなので、何も返ってこない\n\nif(TRUE){ # 複数行で書く時には中括弧（{}）を用いる\n  \"Hello R\"\n}\n\nif(FALSE){\"Hello FALSE\"} # 1行のif文で中括弧を使ってもよい\n```\n\n`if`文の条件が`0`のときには、`0`が`FALSE`であると判断されて、処理が実行されません。一方で条件が`0`以外である場合には、`TRUE`であると判断されて処理が実行されます。`if(0)`とするとその処理が行われないので、**Rでは`if(0)`がコメントアウトに使われる**こともあります。\n\n```{r, filename=\"条件式が数値の時のif文\"}\nif(0){\"0はFALSEなので、これは表示されません\"}\n\nif(-1){\"-1はTRUE扱いなので、表示されます\"}\n\nif(-0.005){\"0以外はTRUEとして処理されます\"}\n```\n\n#### if else文\n\n`if`文ではさらに条件を分岐させることもできます。条件を追加する場合には、`if`文の後に、`else if()`を繋げます。`else if()`のカッコの中に2つ目の条件を書くことで、条件を分離させることができます。`else`だけを書いて、`if()`の条件式をつけない場合には、どの条件にも合わない時に実行する処理になります。ですので、`if else`文は以下の形を取ります。\n\n**if(条件式1){**\\\n**式1がTRUEのときの処理**\\\n**}else if(条件式2){**\\\n**式1がFALSE、式2がTRUEのときの処理**\\\n**}else{**\\\n**式1、2がFALSEのときの処理**\\\n**}**\n\n```{r, filename=\"if else文\"}\nx <- 2 # xは2\n\n# xは2なので、2番目の処理が返ってくる\nif(x == 1){ # =が1つだと代入になるのでエラーが出る\n  \"first\"\n} else if(x == 2){\n  \"second\"\n} else {\n  \"others\"\n}\n```\n\n#### ifelse関数\n\n条件分岐が2つしかない場合には、`ifelse`関数を用いることもできます。`ifelse`関数は3つの引数、「(条件式)、(`TRUE`のときの処理)、(`FALSE`のときの処理)」を取ります。条件が1つだけで、簡単な処理のみを行うのであれば`ifelse`関数で十分な場合もあります。\n\n```{r, filename=\"ifelse関数\"}\n# TRUEなので2番目の処理が返ってくる\nifelse(1 < 3, \"One is smaller than three.\", \"One is not smaller than three.\")\n\n# FALSEなので3番目の処理が返ってくる\nifelse(1 > 3, \"One is larger than three.\", \"One is not larger than three.\") \n```\n\n### switch文\n\n条件式ではなく、特定の値に対応して処理を変えたい場合には、`switch`文を用います。`switch`文では、**始めの引数が条件を指定する値、それに続く引数が条件に対応した処理**となります。条件を指定する値には、数値または文字列を用いることができます。条件が数値の場合と文字列の場合では、やや使い方が異なります。\n\n```{r, filename=\"switch文（条件が数値のとき）\"}\n# 条件が1のときは、2番目の引数の処理が返ってくる\nswitch(1, \"first\", \"second\", \"third\") \n\n# 条件が2のときは、3番目の引数の処理が返ってくる\nswitch(2, \"first\", \"second\", \"third\") \n\n# 条件が5のときは、6番目の引数の処理がないので何も返ってこない\nswitch(5, \"first\", \"second\", \"third\") \n```\n\n```{r, filename=\"switch文（条件が文字列のとき）\"}\n# 条件式に対応したもの（=で繋いだもの）が返ってくる\nswitch(\"dog\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n\nswitch(\"monkey\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n\n# horseは引数に登録していないので、何も返ってこない\nswitch(\"horse\", dog = \"犬\", cat = \"猫\", monkey = \"猿\", pig = \"豚\")\n```\n\n:::{.callout-tip collapse=\"true\"}\n\n## ライブラリで設定されている条件分岐\n\nインストールしたばかりのRでは、上記の`if`文、`if else`文、`ifelse`関数、`switch`文しか使えませんが、**ライブラリ**というものを用いると、他の条件分岐（`if_else`関数や`case_which`文、`case_when`文）などを用いることもできます。詳細については[16章](./chapter16.html)で説明します。\n\n:::","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"output-file":"chapter4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","lightbox":"auto","bibliography":["references.bib"],"editor":"source","theme":{"light":"united","dark":"cyborg"},"toc-expand":2,"code-block-bg":true,"code-block-border-left":"#31BAE9"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}